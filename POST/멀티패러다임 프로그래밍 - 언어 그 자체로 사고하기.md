고백부터 하자면, 모든 패러다임을 온전히 이해하고 있지는 않다. 하지만 이 책에서 각각의 장점을 살려 통합적 사고로 구현하려는 설계 철학은 인상적이었다. 특정 패러다임에 얽매이지 않고 상황에 맞는 최적의 접근법을 선택하는 유연함이 현대 개발자에게 필요한 사고방식이지 않을까 하는 생각으로 읽어나가기 시작했다.

실무에서 `map`, `filter`, `reduce`와 같은 내장함수를 종종 사용하게 되는데, 정작 그런 내장함수가 어떻게 구현되었는지는 생각한 기억이 별로 없다. ‘프론트엔드 기술 면접 준비’라는 제목의 포스팅으로 종종 마주했던 이야기를 정작 실무에서 작업하다 보면 크게 관심을 두지 못했던 것이다. 이 책은 바로 그 지점에서 출발한다. 객체지향 기반 언어들이 반복자 패턴을 통해 이터레이션 프로토콜을 구현해 왔고, 함수를 인자로 전달하는 등 일급 함수의 특성이 추가되면서 이터레이터 헬퍼 함수들이 구현될 수 있었다고 언급한다. 제네레이터를 통해 `map`이나 `for…of` 등을 만드는 과정이나 이터러블을 받아 순회하면서 특정 값을 반환하는 과정을 직접 구현하고 있는데, 차분하게 따라갈 수 있기에 호기심을 자극하는 과정이었다.

2장은 LISP 계열 언어인 클로저를 예시로 LISP를 설명한다. LISP을 처음 접했지만, 다양한 계열의 언어가 익숙하지 않더라도 앞서 기본 개념을 먼저 설명해 주고 있기 때문에 프로그래밍의 전반적인 개념만 알고 있어도 큰 무리 없이 읽어 나갈 수 있었다. 마음먹고 찾을 일이 없으면 다른 언어의 선언 방식을 볼 일이 많이 없었는데, 다양한 언어를 접해볼 기회였다.

책에서 TypeScript를 주요 언어로 사용하는 만큼 JavaScript에 대한 심화적인 학습이 되기도 한다. 하나를 꼽자면, 최근에는 `Promise`를 직접 작성할 일이 많진 않지만, `Promise`에 대한 본질적인 이해를 돕기 위해 별도의 단락으로 설명을 이어가는 부분이 있다. 예컨대 `Promise.race`는 병렬로 실행된 여러 `Promise` 중 가장 먼저 완료된 `Promise`의 결과나 에러를 반환하는데, 이를 활용해 응답 속도에 따라 다른 UI 요소를 렌더링하는 것이 가능하다. 단순히 `Promise.race`가 무엇인지에서 끝나는 것이 아니라 실제 서비스에 적용할 수 있는 예시가 있다 보니 직접 구현해 보고 싶은 호기심이 든다. 또한 함수형 코드를 명령형으로 변경하면서 단점에 대해 언급하는 부분은 두 개의 코드를 바로 대조할 수 있기에 이해하기 좋았다.

리스트 프로세싱 패턴화 섹션은 실무적으로 사고할 수 있는 예제들이 많다. LLM이나 에이전트를 통해 해당 패턴을 뽑아낼 수 있다고 해도 그 패턴이 현 상황에 적합한지 판단하는 사고력은 여전히 필요하다. 그런 사고를 위해 패턴 하나하나 눈에 담아두는 것은 중요한 일이었다. 

React를 사용한 사람이라면 [`dangerouslySetInnerHTML`](https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html) prop을 접해본 적이 있을 텐데, 애초에 prop의 이름을 보고 추측할 수 있듯이 권장하지 않는 방식이다. HTML 문자열을 DOM에 바로 삽입하는 props으로 XSS 공격이 노출될 가능성이 있다. TSX(JSX)를 통해 삽입되는 "(큰따옴표) 같은 문자열의 경우 별도로 이스케이프 처리를 하고 있지만, [`dangerouslySetInnerHTML`](https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html)는 별도의 이스케이프 없이 삽입되기 때문이다. 물론 prop로 삽입하기 전에 별도의 sanitize-html과 같은 라이브러리로 이스케이프 처리는 가능하지만, 순전히 언어만의 접근으로 그 이스케이프 처리의 과정을 엿볼 수 있다는 점이 흥미로운 부분이었다. 

7장에서는 익숙한 TODO 기능을 추상 클래스와 상속, 제네릭 클래스로 추상화하는 과정 등을 담고 있다. 단순히 라이브러리로 구현해 왔던 기능을 새로운 패러다임으로 접근하는 건 신선했다. 최근엔 React와 더불어 Headless UI 라이브러리까지 사용하고 있어서 특히나 이런 세심한 접근으로 컴포넌트를 구현할 일이 거의 없었는데, 다시 사고하는 법을 배운 느낌이었다.

호기심을 자극하는 즐거운 경험에도 불구하고 내가 한번에 소화하기엔 어려운 섹션들이 꽤 있었다. 도리어 그런 부분이 마음에 들었던 건 내가 성장할수록 재차 이 책을 통해 담금질할 수 있다는 기대 때문이었다. 유독 생명력이 짧은 책들이 있다. 그 이유엔 여러 가지가 있겠지만 사회과학 분야에 시의성에 민감한 책들이 있듯이, 기술 분야에 있어서는 유독 기술 트렌드에 맞닿아 있는 책들이 있기 때문이다. 특히나 기술 트렌드가 자주 바뀌는 요즘 트렌드와 밀접한 책은 잘 팔릴지는 몰라도 그 생명력이 길다고 볼 순 없다. 비단 트렌드에 밀접하지 않더라도 React처럼 변화의 한복판에 놓여 있는 기술을 다루는 책이라면 1~2년 사이에 빛을 잃기도 한다. 그런 면에서 이 책은 트렌드에 밀접한 것이 아닌 언어 근본의 이야기와 소프트웨어 설계 철학에 대해 다루고 있기 때문에 언제든지 반복해서 읽을 수 있다는 생각이 들었다. 매 장이 끝날 때 요약정리가 되어 있어서 리뷰하는 느낌으로 훑어볼 수도 있고, 다시 읽기 전에 한번 훑어보는 것도 가능하기에 다회 독을 위한 좋은 장치가 마련되어 있다. 공교롭게 이 책을 읽을 무렵 사내에서 나와는 다른 스타일의 코드를 받아 분석해야 할 일이 생겼는데, 지지부진하게 느꼈던 그 일을 즐거운 호기심으로 확장할 수 있었던 건 이 책에 가진 가치관에 공감할 수 있었기 때문이라는 생각이 든다.

꼭 개발이 아니더라도 문화 콘텐츠나 비즈니스 분야에서 ‘Back to basic’이라는 표현을 종종 쓰곤 한다. 기본, 근본으로 돌아가서 돌이켜 보자는 의미로 해석할 수 있는 그 말은 기술에서도 적용 가능한 말이라고 생각한다. 이 책을 읽는다는 건, 눈앞에 보이는 영역이 React와 같은 라이브러리라 할지라도 결국 근원으로 들어가면 JavaScript임을 다시 상기할 수 있는 경험이었다. 우스갯소리지만, 어느 날 갑자기 LLM이나 에이전트, React, Vue 같은 라이브러리나 프레임워크가 사라진다고 하더라도 이 책 하나로 모던 웹 개발이 가능하지 않을까. 단순히 프레임워크나 라이브러리 차원의 사고가 아니라 언어 본연의 사고를 하는 책이다.