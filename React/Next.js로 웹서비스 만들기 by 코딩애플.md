# Part 1 : 애플후레시

## Next.js 많이 쓰는 이유를 알아보자

- CSR보다 SSR이 다시 유행함
- client-side rendering은 브라우저에서 html을 실시간으로 만드는 방법
- server-side rendering은 서버에서 html을 미리 만들어 보내줌
- CSR의 문제 → 이쁘고 부드러운 사이트는 만들 수 있으나 구글 검색 노출, 페이지 로딩 속도
- SSR → 서버에서 웹페이지를 다 만들어서 보내주기 때문에 유저한테 JS를 보낼 필요가 없어서 조금 더 가볍고, 구글 검색 노출, 페이지 로딩 속도 좋음 + 원하는 영역에서는 CSR로 처리 가능
- Next.js 13버전 주요 기능
  - 폴더기반 자동라우팅
  - 새로디자인한 서버API 기능
  - 쉬운 DB연결
  - 직관적인 rendering 전략 선택기능
  - hydration없는 server-side rendering
  - 파워풀한 캐싱
  - 이미지와 폰트 최적화

## Next.js 설치와 개발환경 셋팅

- nodejs 18버전 이상에서만 잘돌아감
- node 버전 변경 관련 참고 포스팅
  - nvm 사용 중 "C:\Users\������\AppData\Roaming\nvm could not be found or does not exist. Exiting.”
    [nvm 윈도우 설치 중 C:\Users\������\AppData\Roaming\nvm, The system cannot find the path specified. 문제 해결](https://jinnnkcoding.tistory.com/189)
  - Node.js 최신 버전 업데이트와 버전 변경이 가능한 nvm 사용하기
    [[Node.js] Node와 NPM 버전 확인 및 최신 버전 업데이트](https://mine-it-record.tistory.com/664)
- npx create-next-app@latest
- 폴더&파일 구조
  - app 폴더 → 코드 짤 폴더
  - page.js → 메인 페이지
  - layout.js → page.js를 감싸는 페이지(구조로 보면 page.js의 부모) → page.js 바깥에 적어줘야 할 코드는 여기에 작성 → ex) head 내용, 상단 고정 기능 등
  - globals.css → 모든 전역 css
  - xxx.module.css → 특정 페이지에만 적용 가능한 모듈 css
  - public 폴더 → 이미지 등 소스코드 외의 파일들 보관용
  - api 폴더 → 서버 기능 만드는 곳

## 페이지 레이아웃 만들기 (React 기초문법)

- Next.js는 React 위에 얹혀 사는 프레임워크 같은 거라 React 문법 사용
- 리액트버전 HTML 특징 4개
  - return () 안에 HTML 넣을 때 → 병렬 구조로 넣을 수 없음
  - class 넣고 싶으면 → className
- HTML 안에 변수 넣으려면 → { 변수 }
- inline style 속성 넣으려면 → style={{ color: ‘red’, fontSize: ‘20px’ }} → 기본적으로 JavaScript object 자료형이기 때문에 key값에 대시 기호 같은 걸 적을 수 없음 → 그래서 카멜케이스로 작성

- #페이지 레이아웃 만들 때 레이아웃 안에서 { children } 넣어줘야하고, 인자로도 children 넘겨줘야 함
  ```jsx
  export default function CartLayout({ **children** }) {

    return (
      <div>
        <p>현카무이자이벤트</p>
        **{children}**
      </div>
    )
  }
  ```

## 여러 페이지 만들기 (라우팅)

- 폴더명이 router이름이자 url이 되는 거고, 폴더 밑에는 동일하게 page.js로 작명한 파일 → ex) list라는 폴더를 만들고 그 아래 page.js는 만들면, /list로 접속 시 page.js 내용 보여줌
  1. app폴더 안에 폴더 만들고(그 폴더명이 url에 붙는 이름)
  2. 그 안에 page.js 넣고
  3. 그 안에 레이아웃 작업
- 해당 페이지로 가는 작업을 할 때는 <Link> → a tag와 동일하지만 좀 더 스무스하게 넘겨줌
  ```jsx
  import Image from 'next/image'
  import styles from './page.module.css'
  **import Link from 'next/link'**

  export default function Home() {
    let name = 'park';
    let link = 'http://google.com'

    return (
      <main>
        <div className="navbar">
          **<Link href="/">홈</Link>
          <Link href="/list">List</Link>**
        </div>
        <h1 className="title">Programming Log</h1>
        <p className="title-sub">by dev kim</p>
      </main>
    )
  }
  ```
- header나 gnb, footer 같이 페이지 전체에서 노출되어야 되는 영역은 layout.js body 안에 작성

  ```jsx
  import "./globals.css";
  import { Inter } from "next/font/google";
  import Link from "next/link";

  const inter = Inter({ subsets: ["latin"] });

  export const metadata = {
    title: "Create Next App",
    description: "Generated by create next app",
  };

  export default function RootLayout({ children }) {
    return (
      <html lang="en">
        <body>
          <div className="navbar">
            <Link href="/">홈</Link>
            <Link href="/list">List</Link>
          </div>
          {children} // page.js 들어가는 부분
        </body>
      </html>
    );
  }
  ```

- **page.js 보여줄 때**
  - 옆에 layout.js 있으면 그걸로 page.js 싸맴
  - 상위폴더에 layout.js 있으면 그걸로 1번 싸맴
  - 상위폴더에 또 layout.js가 있으면 그걸로 2번 싸맴
  - (유치원 버전) page.js 보여줄 때는 옆에, 상위에 있는 모든 layout.js 합쳐서 보여줌
  - 페이지 변경과 상관없이 계속 보여줄 UI는 layout.js 쓰면 편할지도

## html을 반복문으로 줄이고 싶으면 map

```jsx
export default function List() {
  let 상품 = ["Tomatoes", "Pasta", "Coconut"];

  return (
    <div>
      <h2 className="title">상품목록</h2>
      {상품.map((item) => {
        return (
          <div className="food">
            <h4>{item} $40</h4>
          </div>
        );
      })}
    </div>
  );
}
```

## Next.js에서 이미지 넣는 법 2개

- public 폴더 밑에서 이미지 관리하고 경로 가져올 때 `/food0.png` 처럼 / 에서 바로 접근 가능
- 이미지를 뿌릴 때 최적화된 이미지로 넣을 수 있음
  - lazy loading, 사이즈최적화 → 이미지가 늦게 떠서 밀려나는 layout shift 현상 방지
- 최적화된 이미지 넣으려면
  - import Image from ‘next/image’
  - <Image /> 컴포넌트 사용
- 최적화 가능한 <Image /> 컴포넌트 제약 조건
  - 이미지 경로를 import해서 넣는 방식으로만 해야 함
  - 반복문을 돌려야 하는 경우 src 안에 require(’이미지경로’) 같이 별도의 문법 적용 필요
  - 외부 이미지 링크를 넣고 싶으면 width, height 속성이 정확히 필요하고 next.config.js에서 별도 remotePatterns 세팅 필요함
  - 때문에 다 만든 후에 최적화하는 것이 좋음

## client/server component, import 문법

- Next.js 컴포넌트는 종류가 2개 → server component / client component
- 아무데나 선언해서 만든 건 server component
- **파일 맨 위에 ‘use client’ 넣고 만든 건 client component**
- **server component - html에 자바스크립트 기능 넣기 불가능, useState, useEffect 등 사용 불가**
- ‘use client’ 선언하고 client component로 변경하면 사용 가능
- **client component 개발 용이함, 로딩 속도 느림(자바스크립트 많이 필요, hydration 필요)**
  - hydration - html을 유저에게 보낸 후에 자바스크립트로 html 다시 읽고 분석하는 일
- **server component 로딩속도 빠름(큰 페이지에 추천)**
- **JS 기능 필요한 작은 페이지에는 client component**

## Component에 데이터 전해주려면 props

- 리액트 문법과 동일함
- 중괄호 열면 변수, 함수 등 아무거나 전송 가능
- 부모 → 자식 전송 가능, 자식 → 부모, 옆집끼리 props 전송 불가능
- 데이터가 많은 컴포넌트에서 가급적 그들 중 최고 부모 컴포넌트에 보관해야 좋음
- **#같은 데이터를 부모에서, 자식에서 또 한번 두 번 가져올 수도 있으나 다른 Vue, React에서는 두 번 호출되기 때문에 비효율적인데, Next.js에서는 같은 데이터 요청이 여러 개면 1개로 압축해줌(deduplication 기능)**

## \***\*좋아요 버튼 만들기 (useState, onClick)\*\***

- useState, 이벤트 설명 리액트와 동일함

## 좋아요 버튼 만들기 2 (array, object state 변경하려면)

- array, object 관련 설명 리액트와 동일함
- 깊은복사, 얇은복사, reference data type 관련 내용
  let arr = [1, 2, 3]
  let arr2 = arr
  **console.log(arr2 == arr) // arr2 값이 바뀌더라도 true임, RAM에 담긴 그 값을 가리키는 화살표가 동일하게 때문, 비교연산자로는 array data 자체가 아닌 화살표만 비교 가능**

# Part 2 : 게시판 프로젝트

## **새로운 프로젝트 생성 / MongoDB 셋팅**

- Database
  - 관계형 Database → PostgreSQL, MySQL, ORACLE
  - 비관계형 Database → **mongoDB**, Cloud Firestore, cassandra → 대용량 트래픽, 분산처리 잘해줌
  - **mongoDB** → JS object 자료형처럼 데이터 저장 가능

## \***\*Next.js에서 MongoDB 사용하기\*\***

### 데이터 삽입 작업

- [mongodb.com](http://mongodb.com) → Database → Browse Collections → Add My Own Data
- database는 그냥 하나의 프로젝트라고 이해하면 좋음
- collection은 하나의 폴더라고 이해하면 좋음
- **collection이라는 폴더를 하나 만들고 그 안에 document라는 걸 만들어서 그 안에 object 자료형 같은 걸 보관**
- 해당 collection에 접근해서 insert document를 통해 자료 삽입

### Next.js 내 세팅

- npm i mongodb
- 호출하고자 하는 페이지에서 호출

  ```jsx
  import { MongoClient } from "mongodb";

  export default async function Home() {
    const url =
      "mongodb+srv://admin:<password>@cluster0.tjgi6mq.mongodb.net/?retryWrites=true&w=majority";
    const client = await MongoClient.connect(url, {
      // DB접속용 url
      useNewUrlParser: true,
    });
    const db = client.db("forum"); // 접속하고자 하는 데이터베이스 이름(ex) forum)
    db.collection("post").find();

    return <div>test</div>;
  }
  ```

- 저렇게 짜면 해당 페이지에서 계속 `connect()`를 실행하기 때문에 별도의 파일로 짜서 호출해옴

  ```jsx
  // util\database.js

  import { MongoClient } from "mongodb";
  const url =
    "mongodb+srv://admin:<password>@cluster0.tjgi6mq.mongodb.net/?retryWrites=true&w=majority";
  const options = { useNewUrlParser: true };
  let connectDB;

  if (process.env.NODE_ENV === "development") {
    // global 변수를 사용해서 개발 단계에선 connect()가 연속적으로 실행되지 않도록 분기처리
    if (!global._mongo) {
      global._mongo = new MongoClient(url, options).connect();
    }
    connectDB = global._mongo;
  } else {
    connectDB = new MongoClient(url, options).connect();
  }
  export { connectDB };
  ```

  ```jsx
  // app\page.js

  import { connectDB } from "@/util/database.js";

  export default async function Home() {
    const client = await connectDB;
    const db = client.db("forum");
    let result = await db.collection("post").find().toArray();
    console.log("result", result);

    return <div>test</div>;
  }
  ```

- DB 입출력 코드는 server component 안에서만 작성하는 게 좋음 → client component는 랜더링해서 유저에게 모든 코드가 날아가기 때문

## 글목록 조회기능 만들기 (DB 데이터 출력)

- 몽고DB 가져와서 map 함수로 반복문 뿌리는 같은 내용

## 상세페이지 만들기 1 (Dynamic route)

- detail 폴더 밑에 [아무이름] 폴더 만들고 그 밑에 page.js 관리하면 detail/아무이름 으로 해당 페이지 접근 가능 → 즉 Dynamic하게 라우팅할 수 있음 ex) http://localhost:3000/detail/adsadad

## 상세페이지 만들기 2 (useRouter)

- useRouter를 사용한 예제

  ```jsx
  "use client";

  import { useRouter } from "next/navigation";

  export default function DetailLink() {
    let router = useRouter();
    return (
      <button
        onClick={() => {
          router.push("/");
        }}
      >
        버튼
      </button>
    );
  }
  ```

- router 관련 함수들
  - router.back() → 뒤로 가기
  - router.forward() → 앞으로 가기
  - router.refresh() → 소프트 리프레시
  - router.prefetch(’/어쩌구’) → 어쩌구의 내용을 미리 로드해줌 → 그 페이지 방문할 때 매우 빠르게 방문 가능
  - server component에도 <Link> 컴포넌트에 prefetch 기본으로 적용되어 있음 → 원치 않으면 refetch={false} 적용
    ```jsx
    <Link href={"/어쩌구"} prefetch={false}>
      링크
    </Link>
    ```
- navigation 관련 함수들
  ```jsx
  "use client";

  import { usePathname, useSearchParams, useParams } from "next/navigation";

  export default function DetailLink() {
    let a = usePathname();
    let b = useSearchParams();
    let c = useParams();
    console.log(a);
  }
  ```

## 글 작성기능 만들기 1 (서버기능 개발은)

- 유저가 작성한 글을 바로 DB로 받는 건 유효성 부분도 그렇고 안전하지 않기 때문에 중간에 글을 체크하고 이상이 없으면 DB에 저장 → 3-tier architecture, 그 중간이 서버
- 그 중간 역할을 하는 서버에서 api 작성, URL과 method가 필요함(GET, POST, PUT, DELETE, PATCH)
- GET 요청 작성
  ```jsx
  export default function handler(요청, 응답) {
    console.log(123);
    return 응답.status(200).json("처리완료"); // 요청을 받아씅면 응답을 해주는 게 좋음
  }
  ```
- form tag 사용해서 GET, POST 요청 가능 - action에는 URL 잘 기입하고 method에는 GET, POST 중에 하나 기입하면 됩니다. (PUT, DELETE는 못씁니다)

  ```jsx
  // (app/write/page.js)

  export default function Write() {
    return (
      <div>
        <h4>글작성</h4>
        <form action="/api/test" method="POST">
          <button type="submit">버튼</button>
        </form>
      </div>
    );
  }
  ```

- 회원가입 과제
  ```jsx
  // app\join\page.js

  export default function Join() {
    return (
      <div>
        <form action="/api/join/new" method="POST">
          <input type="text" name="id" />
          <input type="password" name="password" />
          <button type="submit">회원가입</button>
        </form>
      </div>
    );
  }
  ```

```jsx
// pages\api\join\new.js

import { connectDB } from "@/util/database";

export default async function handler(req, res) {
  const client = await connectDB;
  const db = client.db("forum");
  let result = await db.collection("user").find().toArray();
  console.log(result);

  if (req.method === "POST") {
    for (let i = 0; i < result.length; i++) {
      if (req.body.id === result[i].id) {
        return res.status(500).json("중복아이디");
      }
    }

    try {
      const db = (await connectDB).db("forum");
      let result = await db.collection("user").insertOne(req.body);
      return res.status(200).json("회원가입완료");
    } catch (error) {
      console.log(error);
    }
  }
}
```

## 수정기능 만들기 1

메모 없음

## 수정기능 만들기 2

- app\edit\[id]\page.js
  ```jsx
  import { connectDB } from "@/util/database.js";
  import { ObjectId } from "mongodb";

  export default async function Edit(props) {
    const client = await connectDB;
    const db = client.db("forum");
    let result = await db
      .collection("post")
      .findOne({ _id: new ObjectId(props.params.id) });
    console.log("result", result);

    return (
      <div className="p-20">
        <h4>글수정</h4>
        <form action="/api/post/edit" method="POST">
          <input
            name="title"
            placeholder="글제목"
            defaultValue={result.title}
          />
          <input
            name="content"
            placeholder="글내용"
            defaultValue={result.content}
          />
          <input
            style={{ display: "none" }}
            name="_id"
            defaultValue={result._id.toString()}
          />
          <button type="submit">수정완료</button>
        </form>
      </div>
    );
  }
  ```
- pages\api\post\edit.js
  ```jsx
  import { connectDB } from "@/util/database";
  import { ObjectId } from "mongodb";

  export default async function handler(req, res) {
    if (req.method === "POST") {
      console.log(req.body);

      let newObj = { title: req.body.title, content: req.body.content };

      let db = (await connectDB).db("forum");
      let result = await db
        .collection("post")
        .updateOne({ _id: new ObjectId(req.body._id) }, { $set: newObj });
      console.log("res", res);
      res.redirect(302, "/list");
    }
  }
  ```

## 삭제기능 만들기 1 (Ajax)

Ajax 삭제 기능 강의 3개 일단 스킵


## static rendering, dynamic rendering, cache

### 프로젝트 배포하려면

- npm run build를 통해 build된 결과물을 얻어야 함
- 해당 명령어로 빌드한 후에 터미널을 보면,
    - O → static rendering → (디폴트) npm run build 할 때 만든 html 페이지 그대로 유저에게 보냄 → 값이 변해도 최초에 npm run build 했을 때 나온 페이지만 보내줌
    - λ → dynamic rendering → 유저가 페이지 접속마다 html 새로 만들어서 보내줌
        - `fetch(’/’, { cache: ‘no-store’ }` / `useSearchParams()` / `cookies()` / `headers()` / `[dynamic route]` 관련 함수 등을 사용했을 때 페이지에서 자동으로 dynamic rendering으로 바꿔줌
- 기존 list 페이지 같은 경우 글이 등록/삭제/수정되었을 때 새로 페이지를 그려줘야 하는 이슈 → `export const dynamic = 'force-dynamic'`라는 예약어를 통해서 변경
    
    ```jsx
    import { connectDB } from "@/util/database.js";
    import ListItem from "./ListItem";
    
    **export const dynamic = 'force-dynamic'**
    
    export default async function List() {
      const client = await connectDB;
      const db = client.db("forum");
      let result = await db.collection("post").find().toArray();
      console.log(result);
    
      return (
        <div className="list-bg">
          <ListItem result={result} />
        </div>
      );
    }
    ```
    
- dynamic rendering 단점 → 서버/DB 부담 증가 → 부담스러우면 캐싱 기능 사용 가능
    - 페이지 캐싱: 페이지 완성본을 잠깐 저장해두고 재사용
    - GET요청 결과 캐싱: GET요청결과를 잠깐 저장해두고 재사용 가능

- 캐싱 예시
    
    ```jsx
    export default async function Home() {
    
      await fetch("/URL", { cache: "force-cache" }); // 뒤에 cache 옵션이 없어도 자동으로 cache가 됨
    
      return <div>test</div>;
    }
    ```
    
    ```jsx
    export default async function Home() {
    
      await fetch("/URL", { cache: "no-store" }); // 캐싱 없이 실시간 정보가 필요한 경우 적용 옵션
    
      return <div>test</div>;
    }
    ```
    
    ```jsx
    export default async function Home() {
      await fetch("/URL", { next: { revalidate: 60 } }); // 이러면 60초마다 캐싱된 데이터 갱신해줌, 1초마다 실시간 데이터가 필요 없는 건 이렇게 캐싱해두면 자원을 절약할 수 있음
    
      return <div>test</div>;
    }
    ```
    

- revalidate 예약 변수 쓰면 페이지 단위 캐싱 가능
    
    ```jsx
    import { connectDB } from '@/util/database.js'
    
    export const revalidate = 60; // 누가 페이지 방문시 60초 동안 페이지가 캐싱됩니다
    
    export default async function Home() {
    
      const client = await connectDB;
      const db = client.db('forum');
      let result = await db.collection('post').find().toArray();
    
      return (
        <div>
          test
        </div>
      )
    }
    ```
    

## JWT, session, OAuth 설명시간

- 브라우저 내 쿠키에 저장된 정보는 GET/POST 요청할 때 자동으로 같이 서버에 전송됨 → 즉 로그인했을 때 입장권을 쿠키에 저장함
- 입장권 만들 때 → session 방식 / token 방식
- session 방식
    - session id (이것만 적혀 있음)
    - 장점: 유저의 GET/POST 요청마다 로그인 상태 체크 가능
    - 단점: DB에 무리가 갈 수 있음
- token 방식(사실상 대부분 JWT(JSON Web Token))
    - 장점: DB를 자주 조회하지 않아도 됨 → 유저가 많거나 마이크로서비스 운영중이면 좋음
- OAuth
    - 타 사이트를 통한 서비스 이용
        <!-- 차후 재업로드 및 경로 변경 예상되어 이미지 업로드 안함 -->
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e606d60e-e3c4-4fdd-a0a3-396701c626b6/Untitled.png)
        
    - 소셜 로그인
        <!-- 차후 재업로드 및 경로 변경 예상되어 이미지 업로드 안함 -->
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a57b03f-74c5-46ab-ad98-cb7a2d99ce23/Untitled.png)
        

- Next.js에서 회원기능 구현 → NextAuth.js, Auth.js 주로 사용
    - 소셜로그인, 아이디/비번로그인, JWT, Session, DB adapter
    - 아이디/비번로그인시 JWT 강제로 사용해야 함(session 금지)
    

## 회원기능 만들기 : Auth.js 사용한 소셜로그인

- `npm i next-auth@4.21.1`
- pages\api\auth\[…nextauth].js 파일 생성해서 세팅
    
    ```jsx
    import NextAuth from "next-auth";
    import GithubProvider from "next-auth/providers/github";
    
    export const authOptions = {
      providers: [
        GithubProvider({
          clientId: 'Github에서 발급받은ID',
          clientSecret: 'Github에서 발급받은Secret',
        }),
      ],
      secret : 'jwt생성시쓰는암호'
    };
    export default NextAuth(authOptions);
    ```
    
    - 로그인 방식 하나를 provider라고 함
    - 소셜 로그인은 기본적으로 JWT를 사용함 → 암호 같은 걸 넣어줘야 함
    - 그 후에 라이브러리에 내장된 *`signIn*()` 이라는 함수를 통해 로그인 기능 구현
    - *`````signOut*()` 은 로그아웃
    - 해당 로그인한 사용자 정보를 확인하거나 활용하고 싶으면, *`getServerSession()`*
        
        ```jsx
        import Link from "next/link";
        import "./globals.css";
        import { Inter } from "next/font/google";
        import LoginBtn from "./LoginBtn";
        import { getServerSession } from "next-auth";
        import { authOptions } from "@/pages/api/auth/[...nextauth]";
        
        const inter = Inter({ subsets: ["latin"] });
        
        export const metadata = {
          title: "Create Next App",
          description: "Generated by create next app",
        };
        
        export default async function RootLayout({ children }) {
          let session = await getServerSession(authOptions);
          console.log(session);
          return (
            <html lang="en">
              <body className={inter.className}>
                <div className="navbar">
                  <Link href="/" className="logo">
                    Appleforum
                  </Link>
                  <Link href="/list">List</Link>
                  <LoginBtn></LoginBtn>
                </div>
                {children}
              </body>
            </html>
          );
        }
        ```
        

## 회원기능 만들기 : OAuth + session방식 사용하기

- session 방식으로 관리하고 싶다 → DB adapter 사용
    1. 첫 로그인 시 자동회원가입 (DB에 보관)
    2. 로그인 시 DB에 세션정보 보관
    3. 현재 로그인된 유저 정보 필요하면 DB에서 조회해봄
    

## 회원기능 만들기 : 아이디/비번 + JWT 사용하기

여기서부터