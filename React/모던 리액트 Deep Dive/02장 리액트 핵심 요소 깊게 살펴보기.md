# 2.1 JSX란?

- JSX를 리액트의 전유물로 생각하기 쉬운데, JSX는 리액트가 등장하면서 메타에서 소개한 새로운 구문으로 XML과 유사한 내장형 구문이고, 리액트에 종속되지 않은 독자적인 문법으로 보는 것이 옳습니다. 물론 ECMAScript라고 불리는 자바스크립트 표준의 일부는 아니기 때문에 V8 같은 자바스크립트 엔진이나 브라우저에 의해서 실행되거나 표현되도록 만들어진 구문은 아닙니다. 트랜스파일러를 거쳐서 자바스크립트 런타임이 이해할 수 있는 자바스크립트 코드로 변환됩니다.

## 2.1.1 JSX의 정의

- JSX는 기본적으로 `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXstrings`라는 4가지 컴포넌트를 기반으로 구성되어 있습니다.

### JSXElement

- JSX를 구성하는 가장 기본 요소, HTML의 요소(element)와 비슷한 역할을 합니다. `JSXElement`가 되기 위해서는 다음과 같은 형태 중 하나여야 합니다.
  - `JSXOpeningElement` - 일반적으로 볼 수 있는 요소, `JSXOpeningElement`로 시작했다면 `JSXClosingElement`가 같은 단계에서 선언되어 있어야 올바른 JSX 문법으로 간주합니다.
  - `JSXClosingElement` - `JSXOpeningElement`가 종료됐음을 알리는 요소
  - `JSXSelfClosingElement` - 요소가 시작되고 스스로 종료되는 형태, 내부적으로 자식을 포함할 수 없음
  - `JSXFragment` - 아무런 요소가 없는 형태로 `JSXSelfClosingElement` 형태는 띨 수 없음
- 리액트에서 사용자 컴포넌트는 반드시 대문자로 시작해야 하는데, HTML 태그명과 구분 짓기 위해서 입니다. 굳이 현존하는 HTML 태그만 필터링하지 않고 이런 규칙을 둔 이유는 미래에 추가된 HTML 태그에 대한 가능성을 열어둔 것으로 보입니다.
- `JSXElementName`
  - `JSXElement`의 요소 이름으로 쓸 수 있는 것을 의미하는데, 이름으로 가능한 것은 다음과 같습니다.
    - `JSXIdentifier` - JSX 내부에서 사용하는 식별자, 자바스크립트와 마찬가지로 숫자로 시작하거나 `$`와 `_` 외의 다른 특수문자로 시작할 수 없습니다.
    - `JSXNamespacedName` - `JSXIdentifier:JSXIdentifier`의 조합, 즉 `:` 을 통해 서로 다른 식별자를 이어주는데, 두 개 이상은 불가능합니다.
    - `JSXMemberExpression` - `JSXIdentifier.JSXIdentifier`의 조합, 즉 `.` 을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급합니다. 두 개 이상도 가능합니다.

### JSXAttiributes

- `JSXElement`에 부여할 수 있는 속성을 의미하는데, 단순히 속성을 의미하고 필수값은 아니어서 없어도 에러가 나지 않습니다.
  - `JSXSpreadAttributes` - 자바스크립트의 전개 연산자와 동일한 역할을 한다고 볼 수 있습니다.
    - `{…AssignmentExpression}` - 이 `AssignmentExpression`에는 객체뿐만 아니라 조건문 표현식, 화살표 함수, 할당식 등 `AssignmentExpression`로 취급되는 모든 표현식이 존재할 수 있습니다.
  - `JSXAttribute` - 속성을 나타내는 키와 값으로 짝을 이뤄서 표현합니다.
    - `JSXAttributeName` - 속성의 키 값, `JSXIdentifier`와 `JSXNamespacedName`이 가능하고, `:` 또한 가능합니다.
    - `JSXAttributeValue` - 속성의 키에 할당할 수 있는 값, 자바스크립트 문자열과 동일하게 `‘’`, `“”` 으로 구성되어야 합니다.
      - `{ AssignmentExpression }` - 자바스크립트의 `AssignmentExpression`를 의미합니다. `AssignmentExpression`는 자바스크립트에서 값을 할당할 때 쓰는 표현식을 말하는데, 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능합니다.
      - `JSXElement` - 값으로 다른 JSX 요소가 들어갈 수 있습니다.
      - `JSXFragment` - 별도 속성을 갖지 않는 형태 즉, 비어 있는 형태의 fragment 도 허용됩니다.

### JSXChildren

- `JSXElement`의 자식 값을 나타냅니다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 `JSXChildren`라고 합니다.
  - `JSXChild` - `JSXChildren`을 이루는 기본 단위, `JSXChildren`은 `JSXChild`를 0개 이상 가질 수 있고, 0개 이상이라는 말처럼 `JSXChildren`은 `JSXChild`이 없어도 상관 없습니다.
    - `JSXText` - 다른 JSX 문법과 혼동할 수 있는 `{`, `<`, `>`, `}`을 제외한 문자열입니다.
    - `JSXElement` - 값으로 다른 JSX 요소가 들어갈 수 있습니다.
    - `JSXFragment` - 값으로 fragment가 들어갈 수 있습니다.
    - `{ JSXChildExpression (optional) }` - 이 `JSXChildExpression`은 자바스크립트의 `AssignmentExpression`을 의미하기에 다음과 같은 코드도 올바른 JSX 표현식으로 볼 수 있습니다.
      ```jsx
      // 'foo'라는 문자열 출력

      import React from "react";
      import "./style.css";

      export default function App() {
        return <>{(() => "foo")()}</>;
      }
      ```

### JSXStrings

- HTML에서 사용 가능한 문자열은 모두 `JSXStrings`에서도 가능합니다. 현재의 JSX는 HTML처럼 `\`를 이스케이프 문자열로 처리하고 있지 않는다는 게 자바스크립트와의 차이점이라고 볼 수 있는 부분입니다.

## 2.1.3 JSX는 어떻게 자바스크립트로 변환될까?

- JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 `@babel/plugin-transform-react-jsx` 플러그인을 알아야 하는데, 이 플러그인은 JSX 구문을 자바스크립트 이해할 수 있는 형태로 변환합니다.
- JSX
  ```jsx
  const ComponentA = <A required={true}>Hello World</A>;

  const ComponentB = <>Hello World</>;

  const ComponentC = (
    <div>
      <span>hello world</span>
    </div>
  );
  ```
- 변환 결과
  ```jsx
  "use strict";

  var ComponentA = React.createElement(
    A,
    {
      required: true,
    },
    "Hello World"
  );

  var ComponentB = React.createElement(React.Fragment, null, "Hello World");
  var ComponentC = React.createElement(
    "div",
    null,
    React.createElement("span", null, "hello world")
  );
  ```

## 2.1.4 정리

- 리액트에서 JSX의 모든 구문을 다 활용할 필요가 없다고 판단했기 때문에 낯선 문법이 있을 수도 있습니다. JSX 문법에는 있지만 실제로 리액트에서 사용하지 않는 것은 다음과 같습니다.
  - `JSXNamespacedName`
  - `JSXMemberExpression`

# 2.2 가상 DOM과 리액트 파이버

## 2.2.1 DOM과 브라우저 랜더링 과정

1. 브라우저가 사용자가 요청한 주소에서 HTML 파일을 다운로드 합니다.
2. 브라우저의 랜더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만듭니다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드 합니다.
4. 브라우저의 랜더링 엔진은 이 CSS도 별도로 파싱해서 CSS 노드로 구성된 트리(CSSOM)을 만듭니다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 모든 노드를 방문하는 것은 아니고 사용자 눈에 보이는 노드만 방문합니다. 즉 display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는데, 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서입니다.
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용합니다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있습니다.
   1. 레이아웃(layout, reflow) - 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정인데, 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 됩니다.
   2. 페인팅(painting) - 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정입니다.

![dom-cssom-are-combined-8de5805b2061e_856.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cbe44aa2-7fb2-4c72-86b3-711de49a1f7f/28fb6b6d-4198-4dbd-b928-51d631f05168/dom-cssom-are-combined-8de5805b2061e_856.png)

## 2.2.2 가상 DOM의 탄생 배경

- 레이아웃은 필연적으로 리페인팅이 발생하기 때문에 더 많은 비용이 드는데, 또한 부모의 변경은 자식 요소까지도 변경되어야 하기에 더 많은 비용을 브라우저와 사용자가 지불하게 됩니다. 또한 사용자의 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자 입장에선 수고스러운 일이고, 인터렉션에 따른 DOM의 최종 결과물을 간편하게 제공하는 것은 브라우저 뿐만 아니라 개발자에게도 매우 유용합니다.
- 가상 DOM은 리액트가 관리하는 가상의 DOM으로, 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영합니다. 이를 통해 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한번 거치게 된다면 실제로는 여러 번 발생했을 랜더링 과정을 최소화할 수 있고 브라우저와 개발자의 부담을 덜 수 있습니다.
- 일반적인 DOM 관리 방식보다 속도적으로 우월한 것이 아니라 브라우저와 개발자에게 도움을 줄 수 있기에 가성 DOM 개념을 만들었고, 일반적인 애플리케이션을 개발할 수 있을 만큼 합리적으로 빠르게 때문에 채택했다고 볼 수 있습니다.

## 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

### 리액트 파이버란?

- 가상 DOM과 랜더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버(React Fiber)인데, 리액트에서 관리하는 평범한 자바스크립트 객체입니다. 파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며 둘 사이의 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 랜더링을 요청하는 역할을 합니다. 재조정(reconciliation)은 리액트에서 어떤 부분을 새롭게 랜더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)이라고 이해하면 됩니다.

## 참고자료

- 모던 리액트 Deep Dive(김용찬, 2023)
- https://web.dev/articles/critical-rendering-path/render-tree-construction?hl=ko
- [https://velog.io/@gonasooc/Virtual-DOM에-대해-설명해주세요](https://velog.io/@gonasooc/Virtual-DOM%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
