# 3.1 리액트의 모든 훅 파헤치기

## 3.1.1 useState

- `useState`는 함수형 컴포넌트 내부에서 상태를 정의하고 이 상태를 관리할 수 있게 해주는 훅입니다.

### useState 구현 살펴보기

- `useState` 훅의 반환 값은 배열로 첫 번째 원소로 `state` 값 자체를 사용, 두 번째 원소인 `setState` 함수를 통해 해당 `state`의 값을 변경할 수 있으며, 별도의 초깃값을 넘겨주지 않으면 `undefined`입니다.
- 클로저는 어떤 함수(`useState`) 내부에 선언된 함수(`setState`)의 함수의 실행이 종료된 이후에도(`useState`가 호출된 이후에도) 지역변수인 `state`를 계속 참조할 수 있다는 것을 의미하는데, 리액트의 `useState`는 클로저를 이용해서 구현한 것으로 볼 수 있습니다.

### 게으른 초기화

- 일반적으로 `useState`의 기본값으로 원시값을 넣는 경우가 대부분이지만, `useState`에 변수 대신 함수를 넘길 수 있는데 이걸 게으른 초기화(lazy initialization)라고 합니다.

```jsx
// 일반적인 useState 사용
const [count, setCount] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
);

// 게으른 초기화: 함수를 실행해 값을 반환
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

- 리액트 공식 문서에서 이런 게으른 초기화는 `useState`의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때의 사용을 권고합니다. 게으른 초기화 함수는 오로지 `state`가 처음 만들어질 때만 사용되고, 이후에 리렌더링이 발생한다고 해도 함수의 실행은 무시됩니다.
- 즉, 게으른 최적화는 `localStorage`나 `sesstionStorage`에 대한 접근, `map`, `filter`, `find` 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 사용하는 것이 좋습니다.

## 3.1.2 useEffect

- 첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, 두 번째 인수로는 의존성 배열을 전달합니다. `useEffect`는 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수라고도 볼 수 있습니다. 즉, `state`와 `props`의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있습니다.

### 클린업 함수의 목적

- `useEffect`는 그 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행하기 때문에 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가한다고 볼 수 있습니다. 이를 통해서 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지합니다.
- 클린업 함수는 언마운트라기보다는 함수형 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해 주는 개념으로 보는 것이 옳습니다.

### 의존성 배열

- 의존성 배열은 빈 배열이나 특정 값을 넘겨줄 수도, 아무런 값도 안 넘길 수도 있는데, 아무런 값도 넘겨주지 않을 땐 의존성 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행하게 됩니다.

```jsx
// 1
function Component() {
  console.log("렌더링됨");
}

// 2
function Component() {
  useEffect(() => {
    console.log("렌더링됨");
  });
}
```

- 두 코드의 차이점은 `useEffect`의 경우 서버 사이드 렌더링 관점에서 보면 클라이언트 사이드에서 실행되는 것을 보장해 준다는 점이고, `useEffect`는 컴포넌트의 렌더링이 완료된 이후에 실행됩니다. 반면, 직접 실행의 경우 렌더링되는 도중에 실행되기 때문에 컴포넌트의 반환을 지연시키는 행위가 될 수도 있어서 성능에 악영향을 미칠 수 있다는 점에서 차이가 있습니다.

### useEffect를 사용할 때 주의할 점

- `eslint-disable-line react-hooks/exhaustive-deps` 주석은 최대한 자제하는 것이 좋습니다.
  - 이 주석 관련 경고는 `useEffect` 인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 때 발생합니다. 컴포넌트를 마운트하는 시점에만 무언가를 하고 싶다는 의도는 주로 클래스형 컴포넌트의 생명주기 메서드인 `componentDidMount`에 기반한 접근법인데 가급적 사용하지 않는 편이 좋습니다. 컴포넌트의 `state`, `props`와 같은 어떤 값의 변경과 `useEffect`의 부수 효과가 별개로 작동하게 되기에 의도치 못한 버그를 만들 가능성이 높습니다. `useEffect`에 빈 배열을 넘기기 전에 정말로 `useEffect`의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 혹은 여기서 호출하는 게 최선인지 한번 더 검토해 볼 필요가 있습니다.
- 기명 함수를 사용할 필요도 있습니다.
  - `useEffect`의 콜백 함수는 주로 익명 함수를 사용하는 편이지만 코드의 복잡성이 커질 수록 익명 함수가 아닌 기명 함수로 바꾸는 것이 목적을 파악하기 쉬워집니다.
    ```jsx
    useEffect(() => {
      logging(user.id);
    }, [user.id]);
    ```
    ```jsx
    useEffect(
      function logActiveUser() {
        logging(user.id);
      },
      [user.id]
    );
    ```
- 거대한 `useEffect`를 만들지 않는 편이 좋습니다.
  - `useEffect`는 의존성 배열을 바탕으로 렌더링 시 의존성이 변경될 때마다 부수 효과를 실행합니다. 부수 효과가 커질 수록 성능에 악영향을 주기 때문에 가급적 가볍게 유지하는 편이 좋고, 만약 부득이하게 큰 `useEffect`를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 `useEffect`로 분리하는 편이 좋습니다.
- 불필요한 외부 함수를 만드는 것보다 `useEffect` 내에서 사용할 부수 효과라면 내부에서 만들어서 정의하는 편이 훨씬 도움이 됩니다.
- `useEffect`의 콜백 인수로 비동기 함수를 넣을 수 없는 이유는 비동기 함수의 응답 속도에 따라 이전 `state` 기반의 결과가 나올 수 있기 때문에 다르게 나타날 수 있기 때문입니다. 이러한 문제를 `useEffect`의 경쟁 상태(race condition)이라고 표현합니다. 즉, 비동기 `useEffect`는 `state`의 경쟁 상태를 야기할 수 있고, `cleanup` 함수의 실행 순서도 보장할 수 없기 때문에 개발자 편의를 위해 `useEffect`에서 비동기 함수를 인수로 받지 않는다고 볼 수 있습니다.

## 참고자료

- 모던 리액트 Deep Dive(김용찬, 2023)
