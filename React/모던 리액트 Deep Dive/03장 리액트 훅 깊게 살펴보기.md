# 3.1 리액트의 모든 훅 파헤치기

## 3.1.1 useState

- `useState`는 함수형 컴포넌트 내부에서 상태를 정의하고 이 상태를 관리할 수 있게 해주는 훅입니다.

### useState 구현 살펴보기

- `useState` 훅의 반환 값은 배열로 첫 번째 원소로 `state` 값 자체를 사용, 두 번째 원소인 `setState` 함수를 통해 해당 `state`의 값을 변경할 수 있으며, 별도의 초깃값을 넘겨주지 않으면 `undefined`입니다.
- 클로저는 어떤 함수(`useState`) 내부에 선언된 함수(`setState`)의 함수의 실행이 종료된 이후에도(`useState`가 호출된 이후에도) 지역변수인 `state`를 계속 참조할 수 있다는 것을 의미하는데, 리액트의 `useState`는 클로저를 이용해서 구현한 것으로 볼 수 있습니다.

### 게으른 초기화

- 일반적으로 `useState`의 기본값으로 원시값을 넣는 경우가 대부분이지만, `useState`에 변수 대신 함수를 넘길 수 있는데 이걸 게으른 초기화(lazy initialization)라고 합니다.

```jsx
// 일반적인 useState 사용
const [count, setCount] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
);

// 게으른 초기화: 함수를 실행해 값을 반환
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

- 리액트 공식 문서에서 이런 게으른 초기화는 `useState`의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때의 사용을 권고합니다. 게으른 초기화 함수는 오로지 `state`가 처음 만들어질 때만 사용되고, 이후에 리렌더링이 발생한다고 해도 함수의 실행은 무시됩니다.
- 즉, 게으른 최적화는 `localStorage`나 `sesstionStorage`에 대한 접근, `map`, `filter`, `find` 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 사용하는 것이 좋습니다.

## 3.1.2 useEffect

- 첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, 두 번째 인수로는 의존성 배열을 전달합니다. `useEffect`는 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수라고도 볼 수 있습니다. 즉, `state`와 `props`의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있습니다.

### 클린업 함수의 목적

- `useEffect`는 그 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행하기 때문에 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가한다고 볼 수 있습니다. 이를 통해서 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지합니다.
- 클린업 함수는 언마운트라기보다는 함수형 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해 주는 개념으로 보는 것이 옳습니다.

### 의존성 배열

- 의존성 배열은 빈 배열이나 특정 값을 넘겨줄 수도, 아무런 값도 안 넘길 수도 있는데, 아무런 값도 넘겨주지 않을 땐 의존성 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행하게 됩니다.

```jsx
// 1
function Component() {
  console.log("렌더링됨");
}

// 2
function Component() {
  useEffect(() => {
    console.log("렌더링됨");
  });
}
```

- 두 코드의 차이점은 `useEffect`의 경우 서버 사이드 렌더링 관점에서 보면 클라이언트 사이드에서 실행되는 것을 보장해 준다는 점이고, `useEffect`는 컴포넌트의 렌더링이 완료된 이후에 실행됩니다. 반면, 직접 실행의 경우 렌더링되는 도중에 실행되기 때문에 컴포넌트의 반환을 지연시키는 행위가 될 수도 있어서 성능에 악영향을 미칠 수 있다는 점에서 차이가 있습니다.

### useEffect를 사용할 때 주의할 점

- `eslint-disable-line react-hooks/exhaustive-deps` 주석은 최대한 자제하는 것이 좋습니다.
  - 이 주석 관련 경고는 `useEffect` 인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 때 발생합니다. 컴포넌트를 마운트하는 시점에만 무언가를 하고 싶다는 의도는 주로 클래스형 컴포넌트의 생명주기 메서드인 `componentDidMount`에 기반한 접근법인데 가급적 사용하지 않는 편이 좋습니다. 컴포넌트의 `state`, `props`와 같은 어떤 값의 변경과 `useEffect`의 부수 효과가 별개로 작동하게 되기에 의도치 못한 버그를 만들 가능성이 높습니다. `useEffect`에 빈 배열을 넘기기 전에 정말로 `useEffect`의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 혹은 여기서 호출하는 게 최선인지 한번 더 검토해 볼 필요가 있습니다.
- 기명 함수를 사용할 필요도 있습니다.
  - `useEffect`의 콜백 함수는 주로 익명 함수를 사용하는 편이지만 코드의 복잡성이 커질 수록 익명 함수가 아닌 기명 함수로 바꾸는 것이 목적을 파악하기 쉬워집니다.
    ```jsx
    useEffect(() => {
      logging(user.id);
    }, [user.id]);
    ```
    ```jsx
    useEffect(
      function logActiveUser() {
        logging(user.id);
      },
      [user.id]
    );
    ```
- 거대한 `useEffect`를 만들지 않는 편이 좋습니다.
  - `useEffect`는 의존성 배열을 바탕으로 렌더링 시 의존성이 변경될 때마다 부수 효과를 실행합니다. 부수 효과가 커질 수록 성능에 악영향을 주기 때문에 가급적 가볍게 유지하는 편이 좋고, 만약 부득이하게 큰 `useEffect`를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 `useEffect`로 분리하는 편이 좋습니다.
- 불필요한 외부 함수를 만드는 것보다 `useEffect` 내에서 사용할 부수 효과라면 내부에서 만들어서 정의하는 편이 훨씬 도움이 됩니다.
- `useEffect`의 콜백 인수로 비동기 함수를 넣을 수 없는 이유는 비동기 함수의 응답 속도에 따라 이전 `state` 기반의 결과가 나올 수 있기 때문에 다르게 나타날 수 있기 때문입니다. 이러한 문제를 `useEffect`의 경쟁 상태(race condition)이라고 표현합니다. 즉, 비동기 `useEffect`는 `state`의 경쟁 상태를 야기할 수 있고, `cleanup` 함수의 실행 순서도 보장할 수 없기 때문에 개발자 편의를 위해 `useEffect`에서 비동기 함수를 인수로 받지 않는다고 볼 수 있습니다.

## 3.1.3 useMemo

- useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅으로, 흔히 리액트에서 최적화를 떠올릴 때 가장 먼저 언급되는 훅입니다.

```jsx
import { useMemo } from "react";

const memoizedValue = useMemo(() => expensiveComputation(a, b), [a, b]);
```

- 첫 번째 인수는 어떤 값을 반환하는 생성 함수, 두 번째 인수로는 해당 함수가 의존하는 값의 배열을 전달합니다. useMemo는 의존성 배열의 값의 변경이 없다면 함수를 재실행하지 않고 이전 값을 반환하고, 의존성 배열의 값이 변경되면 첫 번째 인수의 함수를 재실행한 후에 그 값을 반환해서 다시 기억합니다. useMemo로 컴포넌트 자체를 인수로 전달하는 것도 가능합니다.

## 3.1.4 useCallback

- useMemo가 값을 기억했다면 useCallback은 인수로 넘겨받은 콜백 자체를 기억합니다. 쉽게 말해 useCallback은 특정 함수를 새로 만들지 않고 재사용한다는 의미인데, 값의 메모이제이션을 위해 useMemo를 사용했다면 함수의 메모이제이션을 위해 사용하는 것이 useCallback입니다. useCallback의 첫 번째 인수로 함수를, 두 번째 인수로 의존성 배열을 넣으면 useMemo와 마찬가지로 의존성 배열이 변경되지 않는 한 함수를 재생성하지 않습니다.
- memo를 사용해서 name, value, onChange의 값이 변하지 않더라도 상위 컴포넌트에서 status 자체가 바뀌면서 onChange로 넘기는 함수가 재생성되고 있기 때문에 리렌더링이 발생하게 됩니다. 이럴 때 함수의 메모이제이션을 위해 useCallback을 사용합니다. 일반적으로는 익명 함수를 넘겨주지만 예제처럼 디버깅을 위해 기명 함수를 넘겨주기도 합니다.

```
import { useCallback, useEffect, useState } from "react"

const ChildComponent = memo(({ name, value, onChange }) => {
  useEffect(() => {
    console.log('rendering!', name);
  })

  return (
    <>
      <h1>
        {name} {value ? '켜짐' : '꺼짐'}
      </h1>
      <button onClick={onChange}>toggle</button>
    </>
  )
})

function App() {
  const [status1, setStatus1] = useState(false);
  const [status2, setStatus2] = useState(false);

  const toggle1 = useCallback(
    function toogle1() {
      setStatus1(!status1);
    },
    [status1]
  )

  const toggle2 = useCallback(
    function toogle2() {
      setStatus2(!status2);
    },
    [status2]
  )

  return (
    <>
      <ChildComponent name="1" value={status1} onChange={toggle1} />
      <ChildComponent name="2" value={status2} onChange={toggle2} />
    </>
  )
}
```

## 3.1.5 useRef

- useRef는 useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있지만, 큰 차이점 두 가지가 있습니다.
  - useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있음
  - useRef는 그 값이 변하더라도 렌더링을 발생시키지 않음
- 비슷하게 사용하고자 함수 외부에 값을 선언하게 되면 컴포넌트가 실행되어 렌더링되지 않았음에도 해당 값이 기본적으로 존재하게 되어 메모리에 불필요한 값을 갖게 할 수도 있고, 컴포넌트가 여러 번 실행된다면 각각의 컴포넌트 인스턴스 하나당 하나의 값이 아니라 모두 하나의 값으로 동일하게 적용할 수밖에 없는 문제가 있습니다.
- useRef의 가장 일반적인 사용 예는 DOM에 접근하고 싶을 때입니다. 그리고 useRef의 최초 기본값은 return 문에 정의해놓은 DOM이 아니라 useRef()로 넘겨받은 인수라는 사실입니다.

```jsx
import { useEffect } from "react";

function RefComponent() {
  const inputRef = useRef();

  // 이때는 미처 렌더링이 실행되기 전(반환되기 전)이므로 undefined를 반환
  console.log(inputRef.current); // undefined

  useEffect(() => {
    console.log(inputRef.current); //
  }, [inputRef]);

  return <input ref={inputRef} type="text" />;
}
```

- useRef는 렌더링을 발생시키지 않고 원하는 상태값을 저장할 수 있다는 특징을 활용해서 이전 값을 저장하는 usePrevious() 같은 훅을 구현하는 것이 가능합니다.

## 참고자료

- 모던 리액트 Deep Dive(김용찬, 2023)
