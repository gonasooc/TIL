# 12.1 웹사이트와 성능

- 웹사이트의 성능은 사용자의 전자상거래 전환율이나 이탈율과 밀접하게 관련되어 있습니다. 현재 네트워크 속도나 모바일 기기의 성능은 발전하고 있지만 그와 동시에 여전히 대부분의 모바일 사이트는 너무 많은 요소 때문에 비대해지기도 했습니다. 많은 개발자들이 성능에 크게 관심을 기울이지 않는 것 또한 사실인데, 실무에서 일정을 넉넉히 잡고 성능을 개선하는 것이 쉽지 않을 뿐더러 작업 대비 눈에 띄는 성능 향상을 기대하기도 어렵기 때문입니다.
- 그럼에도 불구하고 앞서 전환율이나 이탈율을 고려해서 웹사이트의 성능에 주의를 기울여야 합니다. 과거에는 로딩 속도나 전환율 등으로 지엽적으로 판단했지만, 몇 년 전부터 구글은 핵심 웹 지표(Core Web Vital)이라고 하는, 사용자 경험에 대해 몇 가지 핵심 지표를 제시하고 있습니다.

# 12.2 핵심 웹 지표란?

- 핵심 웹 지표(Core Web Vital)은 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어입니다. 일관된 판단을 위해 구글은 핵심적인 웹 지표를 몇 가지로 요약하고, 이를 측정할 수 있는 방법, 좋은 웹사이트의 기준을 명확하게 제시해두었습니다.

# 12.3 최대 콘텐츠풀 페인트(LCP)

## 12.3.1 정의

- LCP(Largest Contentful Paint)란 ‘페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간’을 말합니다.
- 뷰포트는 사용자마다, 즉 기기마다 다른데 ‘큰 이미지와 텍스트’는 다음과 같이 정의되어 있습니다.
  - `<img>`
  - `<svg>` 내부의 `<image>`
  - `poster` 속성을 사용하는 `<video>`
  - `url()`을 통해 불러온 배경 이미지가 있는 요소
  - 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
    - 이 블록 레벨 요소에는 `<p>`, `<div>` 등 포함

## 12.3.2 의미

- `DOMContentLoaded` 이벤트는 스타일시트나 이미지 등의 로딩을 기다리지 않기 때문에 ‘웹페이지가 로딩이 완료되어 사용자에게 노출되기까지 걸리는 시간’이라고 보기는 어렵습니다. 또한 사용자 페이지 로딩을 체감하기 위해서 모든 페이지를 로딩될 필요가 없기 때문에 뷰포트를 기준으로 하는 LCP가 지표로 만들어졌다고 볼 수 있습니다.

## 12.3.3 예제

- 페이지에 따라서, 실제로 로딩에 필요한 시간에 따라서 LCP의 대상, 혹은 지표가 달라질 수 있습니다.

## 12.3.4 기준 점수

- LCP에서 좋은 점수는 2.5초 내로 응답이 오는 것이고, 4초 이내는 보통, 그 이상은 나쁨으로 판단됩니다.

## 12.3.5 개선 방안

### 텍스트는 언제나 옳다

- 조율을 통해 가능하다면 이미지보다 텍스트로 뷰포트 최대 영역을 채우는 것이 가장 좋기는 합니다.

### 이미지를 어떻게 불러올 것인가?

```html
<!-- 1) img -->
<img src="lcp.jpg" ... />

<!-- 2) svg -->
<svg xmlns="http://www.w3.org/1000/svg">
  <image href="lcp.jpg" />
</svg>

<!-- 3) (비디오의 경우) video.poster -->
<video poster="lcp.jpg"></video>

<!-- 4) background-image: url() -->
<div style="background-image: url(lcp.jpg)">...</div>
```

- `<img>`: 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어납니다. 프리로드 스캐너란 HTML 파싱 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 로딩하는 브라우저의 기능인데, `<img>` 내부의 리소스를 프리로드 스캐너가 병렬적으로 리소스를 다운로드하므로 LCP 요소를 불러오기에 적절합니다. `<picture>`도 동일합니다.
- `<svg>`: `<svg>` 내부의 `<img>`가 로딩이 완료되기 전에는 LCP가 완료되지 않고, `<img>`와 다르게 리소스를 모두 불러온 다음에 이미지를 불러온다는 것입니다. 즉, 프리로드 스캐너에 발견되지 않아 병렬 다운로드가 일어나지 않기 때문에 LCP 점수에 악영향을 주기에 이러한 방식은 삼가는 것이 좋습니다.
- `<video>`의 `poster`: 이 역시 프리로드 스캐너에 발견되어 `<img>`와 같은 성능을 나타내는데, `poster`가 없는 경우 `video`를 로딩해 첫 번째 프레임을 삽입해주기 때문에 `video`가 LCP에 영향을 줄 것 같다면 `poster`를 반드시 넣어주는 것이 좋습니다.
- `background-image: url()`: `background-image`를 비롯해서 CSS 리소스는 DOM을 그릴 준비가 될 때까지 리소스 요청을 미루기 때문에 LCP에 좋은 영향을 미치지 않습니다.

### 그 밖에 조심해야 할 사항

- 이미지 무손실 압축: 당연한 얘기지만 가능한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋습니다.
- `loading=lazy` 주의: `loading=lazy`는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략으로, `<img>`, `<iframe>` 등에 적용할 수 있지만 문제는 LCP의 이미지는 중요하지 않은 리소스로 분류해서는 안될 뿐더러, 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않습니다. 상대적으로 중요하지 않은 이미지에는 사용해도 좋지만 LCP 이미지에는 사용하지 않는 것이 좋습니다.
- `fadein` 같은 각종 애니메이션: 단순 이미지보다 당연히 LCP도 그만큼 늦어집니다.
- 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 LCP로 빠르게 가져가기 때문에 SSR이 유리합니다.
- LCP 관련 리소스는 직접 호스팅: 가능하다면 같은 도메인에서 직접 호스팅하는 편이 좋습니다. 다른 출처(origin)에서 정제한 이미지를 가져오는 것은 이미 연결이 맺어진 현재 출처와는 다르게 완전히 새로운 출처의 경우 네트워크 커넥션부터 다시 수행해야 하기 때문에 최적화에 좋은 영향을 주진 않습니다.

# 12.4 최초 입력 지연(FID)

## 12.4.1 정의

- 웹페이지의 로딩 속도만큼 중요한 것이 웹사이트의 반응 속도인데, 이런 웹사이트의 반응성을 측정하는 지표가 바로 최초 입력 지연(FID)입니다. 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지 시간을 측정합니다.

## 12.4.2 의미

- 웹사이트 내에 이벤트 반응이 늦어지는 이유는 대규모 렌더링이 일어나거나 자바스크립트 분석 등을 이유로 메인 스레드가 작업을 처리하는 데에 리소스를 할애하고 있기 때문입니다. 자바스크립트 실행 환경은 ‘싱글 스레드’이기 때문에 그 외의 이벤트 리스너 같은 작업을 실행할 수 없어 지연이 발생하게 됩니다.
- 클릭, 터치, 타이핑 등 사용자의 개별 입력 작업에 초점을 맞추고 측정되고, 스크롤이나 핀치 투 줌 등은 애니메이션으로 분류해 측정 대상에서 제외됩니다.
- 구글은 사용자 경험을 크게 4가지로 분류해 정의하는데, 이를 RAIL이라고 합니다.
  - Response: 사용자 입력에 대한 반응 속도, 50ms 미만으로 이벤트를 처리할 것
  - Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
  - Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
  - Load: 5초 이내에 콘텐츠를 전달하고 인터렉션을 준비할 것
- FID는 R에 해당하는 응답에 초점을 맞추고 있습니다.

## 12.4.3 예제

- 클릭은 2000ms 경에 일어났지만 실제 클릭에 따른 이벤트가 2600ms에 일어났다면 클릭 이벤트가 발생한 시점부터 실제 함수 호출까지 500ms나 걸렸다는 뜻입니다. 즉, 클릭 이벤트가 발생한 시점부터 메인 스레드가 무언가 다른 작업을 하고 있다는 것으로 볼 수 있는데, 결국 사용자는 클릭 이벤트로부터 0.5초 정도 멈춰 있는 것처럼 느껴지기 때문에 좋지 못한 수준의 FID라고 볼 수 있습니다.

## 12.4.4 기준 점수

- FID의 좋은 점수를 얻기 위해선 100ms 이내로 응답이 와야 하고, 300ms 이내는 보통, 그 이후의 경우 나쁨으로 처리됩니다.

## 12.4.5 개선 방안

### 실행에 오래 걸리는 긴 작업을 분리

- 긴 작업(long task) 때문에 메인 스레드가 오래 점유되는 건 FID 뿐만 아니라 서비스 전체에 악영향을 끼치게 됩니다.
  - 꼭 클라이언트에서 처리해야 되는지 생각해보고, 서버에서 처리하면 상대적으로 빠르고 쾌적하게 처리하면서 메인 스레드를 오래 점유하지 않아도 됩니다.
  - 긴 작업을 여러 개로 분리하기: 반드시 클라이언트에서 처리해야 하는 작업이라면 여러 개로 분리하는 것이 좋습니다.

### 자바스크립트 코드 최소화

- 크롬 개발자도구 커버리지를 통해서 사용되지 않는 코드를 확인할 수 있는데, 당장 급하지 않은 코드들은 지연 로딩이나 우선순위를 낮춰서 불러오는 것이 좋습니다.
- 폴리필(polyfill)을 체크해보고 폴리필이 필요한 환경인지, 폴리필이 아닌 저수준의 자바스크립트 코드로 대체 가능한지 체크해보는 것도 도움이 될 수 있습니다.

### 타사 자바스크립트 코드 실행의 자연

- Google Analytics나 Firebase와 같이 웹페이지의 통계 집계를 위해 제3자가 만든 타사 스크립트를 넣는 경우도 많은데, 이런 코드로 인해 메인 스레드가 잠시 점유되고 안 좋은 사용성을 제공한다면 주객전도되는 상황을 맞이할 수 있습니다. 주요 자원이 아닌 스크립트는 `<script>`의 `async`와 `defer`를 이용해 지연 불러오기를 하는 것이 좋습니다.
  - `defer`: `script`에 `defer` 속성이 있다면 해당 스크립트를 병렬로 다운로드하고, 다운로드 중에도 HTML 파싱 등 메인 스레드 작업은 멈추지 않습니다. 다운로드가 완료됐다 하더라도 이 스크립트의 실행은 페이지가 완전히 로딩된 이후 맨 마지막에 실행됩니다.
  - `async`: `script`에 `async` 속성이 있다면 마찬가지로 해당 스크립트를 병렬로 다운로드하지만, 다운로드가 완료되면 다른 리소스의 다운로드를 기다리지 않고 바로 실행합니다. 따라서 `async` 리소스의 실행 순서는 다운로드가 완료된 순서대로 실행됩니다.
  - 둘 다 없는 경우: `script`를 만나는 순간 다운로드가 우선되며, 다운로드가 완료되면 코드 실행이 우선됩니다. 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄집니다.
- 스크립트는 `async`, `defer`로 갈수록 실행은 뒤로 미뤄지지만 성능은 좋아집니다. 따라서 타사 스크립트는 가능하면 `async`, 더 가능하다면 `defer`로 지연하는 것이 좋습니다. 광고처럼 특정 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 `Intersection Observer`를 이용해 뷰포트에 들어오는 시점에 불어오는 것이 좋습니다.

# 12.5 누적 레이아웃 이동(CLS)

## 12.5.1 정의

- 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것이 누적 레이아웃 이동(CLS)입니다.

## 12.5.2 의미

- CLS는 뷰포트 내부 요소에 대해서만 측정하고, 최초 렌더링이 시작된 위치에서 만약 레이아웃의 이동이 발생한다면 CLS 점수로 기록되게 됩니다. 단순히 요소 추가는 문제 없지만, 그 요소가 다른 요소의 시작 위치에 영향을 미친다면 CLS로 간주됩니다. 사용자 액션으로 인한 CLS는 점수에 포함되지 않습니다. 영향분율과 거리분율의 점수를 곱해서 최종 점수를 계산하게 됩니다.

## **12.5.3 예제**

- 스켈레톤 UI를 통해 개선된 유튜브의 사례

## **12.5.4 기준 점수**

- CLS는 0.1 이하의 경우 좋음, 0.25 이하의 경우 보통, 그 외에는 개선이 필요한 나쁜 점수로 보고됩니다.

## **12.5.5 개선 방안**

### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

- 이런 영향을 미연에 방지하기 위해 `useEffect` 안에서 뷰포트 내에 노출될 확률이 높은 작업을 최소화하는 것이 좋고, 만약 사용이 불가피하다면 `useLayoutEffect`를 검토해볼 수도 있습니다.
- 스켈레톤 UI의 사례처럼, 동적으로 뜰 것으로 예상되는 지점에 공간을 미리 확보해두는 것도 좋은 방법입니다.
- 가장 좋은 방법은 서버 사이드 렌더링입니다. 서버에서 동적 요소를 미리 처리해서 클라이언트에 HTML를 제공해준다면 별도의 고민 없이 처리될 수 있습니다.

### 폰트 로딩 최적화

- 폰트는 각각 고유의 높이와 너비를 갖고 있어서 폰트로 인해 발생할 수 있는 문제는 크게 두 가지입니다.
  - FOUT(flash of unstyled text): HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 있다가 뒤늦게 폰트가 적용되는 현상
  - FOIT(flash of invisible text): HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트가 없거나 별도의 설정으로 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상
- 다음과 같은 옵션을 유념해서 고려해볼 수 있습니다.
  - `<link>`의 `preload` 사용: `<link>` 요소의 `rel=preload`는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능입니다. `preload`로 지정된 요소는 웹페이지 생명주기에서 초기에 불러와야 하는 주요 리소스로 간주되어서 더 빠르게 사용할 수 있도록 준비해 줍니다. 따라서 `rel=preload`로 스타일이나 폰트를 지정하면 페이지의 렌더링을 가로막거나 레이아웃을 방해할 가능성이 줄어듭니다.
  - `font-family: optional`: 폰트를 불러올 수 있는 방법은 크게 다섯 가지로 나뉩니다.
    - `auto`(기본값): 브라우저가 폰트를 불러오는 방법을 결정, 브라우저마다 차이가 있음
    - `block`: 폰트가 로딩되기 전까지 렌더링 중단(최대 3초), 웹 폰트의 로딩이 완료되면 비로스 폰트 적용
    - `swap`: 앞서 언급한 FOUT 방식, 폴백 폰트로 렌더링한 다음, 웹 폰트의 로딩이 완료되면 웹 폰트 적용
    - `fallback`: 100ms간 텍스트가 보이지 않고 그 이후에 폴백 폰트로 렌더링, 3초 안에 폰트가 로딩되면 해당 웹 폰트로 전환하고, 그렇지 않으면 폴백 폰트 유지
    - `optional`: `fallback`과 유사, 100ms 동안 보이지 않고 폴백 폰트로 렌더링한다는 점은 동일하나 네트워크 상태를 파악해 0.1초 이내로 폰트가 다운로드되지 않으면 해당 폰트를 보여주지 않음

### 적절한 이미지 크기 설정

- 모바일에서 `img`의 크기를 `width: 100%; height: auto`로 잡는 건 반응형 작업의 일반적인 작업이고 최적의 이미지를 보여줄 수 있다는 장점이 있지만, 이미지의 높이를 명확히 알지 못하기 때문에 CLS가 크게 발생한다는 단점이 있습니다. 별도의 `width`, `height`를 명시하는 것으로 해결할 수 있습니다.
  - `width`, `height` 지정: `width`와 `height`를 지정하는 것이 가장 좋은 방법인데, css property의 `width: 100%; height: auto;`와 함께 `img`의 `width`, `height` 속성으로 원하는 비율의 값으로 지정하면 이미지를 로딩하기 전에 가로세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둡니다. 이는 브라우저의 유저 에이전트 스타일시트(브라우저가 제공하는 스타일)에서 제공하는 `aspect-ratio` 속성이 가로세로 비율을 자동으로 맞춰주는 역할을 합니다.
  - 만약 뷰포트 너비에 맞춰서 다른 이미지를 제공하고 싶은 경우 `srcset` 속성을 사용하는 것이 좋습니다.
    ```html
    <img
      width="1000"
      height="1000"
      src="image-1000.jpg"
      srcset="image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
      alt="이미지"
    />
    ```

## **12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들**

### 최초 바이트까지의 시간(Time to First Byte, TTFB)

- TTFB는 브라우저가 웹페이지의 첫 번째 바이트를 수신하는 데 걸리는 시간을 의미합니다. 완전히 완료되는 데 걸리는 시간이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지 측정하는 지표로, 600ms 이상 걸릴 경우 개선이 필요한 것으로 간주합니다.
- 이는 SSR에서 주의 깊게 봐야 할 지표인데, 대체로 정적인 자원을 지속적으로 제공해 페이지를 렌더링하는 일반적인 SPA와는 달리 SSR은 최초 페이지를 만들기 위해 서버에서 어느 정도 작업을 수행해야 하기 때문입니다.
- 로직을 최적화해 최대한 빨리 준비시키거나, 웹페이지의 주된 방문객의 국적을 파악해 최대한 해당 국적과 가깝게 서버를 위치시키는 것이 좋습니다. ex) AWS라면, 한국 사용자에게는 `use-east-*`보다 `ap-*`(아시아), 그리고 한국에서 가장 가까운 `ap-northeast-2`(서울)

### 최초 콘텐츠풀 페인트(First Contentful Paint, FCP)

- FCP는 웹사이트에 접속한 순간부터 페이지에 뭐라고 뜨기 시작한 시점까지의 시간을 의미하는데, 여기서 의미하는 ‘뭐라도 뜨기 시작한’에 해당하는 요소는 텍스트, 이미지, svg 등을 의미합니다.
- 일반적으로 FCP는 1.8초 이내에 이뤄지면 좋음, 3.0초 이내는 보통, 그 이후는 개선이 필요한 것으로 보고됩니다.
- 렌더링을 가로막는 리소스를 최소화하거나 비동기로 로드해서 렌더링이 일단 최대한 빨리 이뤄지도록 하는 것이 좋고, 게으른 로딩이나 스크립트에 의존해서 렌더링되는 것을 피해야 합니다. 리다이렉트는 없거나 최소한으로 유지해야 하고, DOM 크기를 최소화하는 것도 개선의 방법이 될 수 있습니다.
