# 1.1 자바스크립트의 동등 비교

- 리액트 함수형 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열(dependencies)에 대해 고민하게 되되고, `eslint-react-config`에 선언되어 있는 `react-hooks/exhaustive-deps`의 도움을 받아 배열을 채우게 되는데, 실제로 이게 어떻게 작동되는지 혹은 어떤 변수들을 넣어야 하는지 이해 못하는 경우가 많습니다.
- 렌더링 관점에서 살펴 보면 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 `props`의 동등 비교에 따른 결과입니다. 그리고 이 `props`의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄지는데, 이 얕은 비교가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪게 됩니다.
- 리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 합니다.

## 1.1.1 자바스크립트의 데이터 타입

- 원시 타입(primitive type) - `boolean`, `null`, `undefined`, `number`, `string`, `symbol`, `bigint`
  - 객체가 아닌 다른 모든 타입, 객체가 아니기 때문에 메서드를 갖지 않습니다.
  - `undefined` - 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값
    ```
    let foo;

    typeof foo === 'undefined'; // true

    function bar(hello) {
      return hello;
    }

    typeof bar() === 'undefined'; // true
    ```
  - `null` - 아직 값이 없거나 비어 있는 값을 표현할 때 사용
    - `null`이 가지고 있는 특징 중 하나는 다른 원시값과 다르게 `typeof`로 `null`을 확인했을 때 ‘object’로 반환된다는 점인데, 이는 초창기 자바스크립트 상의 버그로 바로 잡고자 하는 시도가 있었으나 이전 코드에서 작동할 수 없는 이슈 때문에 반영될 수 없었습니다.
    - `undefined`는 ‘선언됐지만 할당되지 않은 값’, `null`은 ‘명시적으로 비어 있음을 나타내는 값’으로 사용하는 것이 일반적입니다.
  - `boolean` - `true`와 `false`만을 가질 수 있는 데이터 타입으로, 한 가지 주목할 점은 `boolean` 형의 값 외에도 조건문에서 마치 `true`와 `false`처럼 취급되는 truthy, falsy 값이 존재한다는 점입니다.
    - falsy가 가능한 값의 실제 타입
      - `false` - `false`는 대표적인 falsy한 값
      - `0`, `-0`, `0n`, `0x0n` - `0`은 부호나 소수점 유무에 상관없이 falsy한 값
      - `NaN` - `Number`가 아니라는 것을 뜻하는 NaN(Not a Number)는 falsy한 값
      - `‘’`, `“”`, `` - 문자열이 falsy하기 위해서는 반드시 공백이 없는 빈 문자열이어야 함
      - `null` - `null`은 falsy한 값
      - `undefined` - `undefined`는 falsy한 값
    - truthy - falsy를 제외하고 모두 true로 취급되는데, 한 가지 유의할 점은 객체나 배열은 내부 값의 존재 유무와 무관하게(빈 객체나 빈 배열이든) truthy로 취급됩니다.
  - `Number` - 정수와 실수를 구분해 저장하는 다른 언어와 다르게 자바스크립트는 모든 숫자를 하나의 타입에 저장합니다.
  - `BigInt` - number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 등장
  - `String` - 한 쌍의 작은따옴표(’)나 큰 따옴표(”), 혹은 백틱(`)으로도 표현 가능한데, 백틱을 사용해서 표현한 문자열을 템플릿 리터럴(template literal)이라고 하고 줄바꿈이나 문자열 내부에 표현식을 사용할 수 있습니다.
    - `Symbol` - ES6에서 추가된 7번째 타입으로, 중복되지 않는 어떤 고유한 값을 나타내기 위해 만들어졌고, 심벌은 심벌 함수를 통해서만 생성할 수 있습니다.
- 객체 타입(object/reference type) - `object`
  - 7가지 원시 타입 이외의 모든 것, 즉 자바스크립트를 이루고 있는 대부분의 타입이 바로 객체 타입이며, 여기에는 배열, 함수, 정규식, 클래스 등이 포함됩니다.
  - 객체 타입은 참조를 전달한다고 해서 참조 타입(reference type)으로도 불립니다.

## 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 가장 큰 차이라면, 값을 저장하는 방식의 차이입니다.
- 원시 타입은 불변 형태의 값으로 저장됩니다.
  ```jsx
  let hello = "hello world";
  let hi = hello;

  console.log(hello === hi); // true
  ```
- 반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 됩니다.
- 객체는 값이 아니라 참조 주소를 저장하기 때문에 동일하게 선언했던 객체라고 하더라도 저장하는 순간 다른 참조값을 바라보기 때문에 `false`를 반환하게 됩니다.
  ```jsx
  var hello = {
    greet: "hello, world",
  };

  var hi = {
    greet: "hello, world",
  };

  console.log(hello === hi); // false

  console.log(hello.greet === hi.greet); // true
  ```
- 반면 참조를 전달하는 경우 원시값과 같은 결과를 기대할 수 있습니다.
  ```jsx
  var hello = {
    greet: "hello, world",
  };

  var hi = hello;

  console.log(hello === hi); // true
  ```

## 1.1.3 자바스크립트의 또 다른 공식, Object.is

- 자바스크립트에서는 비교를 위한 또 한 가지 방법을 제공하는데, `Object.is`는 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드입니다.
  - `==` vs. `Object.is` → `==` 비교는 양쪽이 같은 타입이 아니라면 강제로 형변환(type casting)을 한 후에 변경합니다. `Object.is`는 `===`와 동일하게 타입이 다르면 `false`입니다.
  - `===` vs `Object.is` → 다음 코드와 같이 `Object.is`가 좀 더 개발자가 기대하는 방식으로 정확하게 비교합니다.
    ```jsx
    -0 === +0; // true
    Object.is(-0, +0); // false;

    Number.NaN === NaN; // false
    Object.is(Number.NaN, NaN); // true

    NaN === 0 / 0; // false
    Object.is(NaN, 0 / 0); // true
    ```
- `Object.is`는 ES6(ECMAScript 2015)에서 새롭게 도입된 비교 문법으로, 동등 비교 `===`가 가지는 한계를 극복하기 위해 만들어졌습니다. 하지만 객체 간 비교에 있어서는 기존의 동등 비교와 동일하게 동작합니다.

## 1.1.4 리액트에서의 동등 비교

- 리액트에서의 동등 비교는 `===`가 아닌 `Object.is`를 이용하고, ES6에서 제공되는 기능이기 때문에 별도의 폴리필(Polyfill)을 함께 사용합니다.
  - 리액트에서 값을 비교하는 함수인 `objectIs`를 발췌
    - https://github.com/facebook/react/blob/main/packages/shared/objectIs.js
      ```jsx
      // flow로 구현돼 있어 any가 추가돼 있음.
      // any는 타입스크립트와 동일하게 어떠한 값도 받을 수 있는 타입을 의미함.

      function is(x: any, y: any) {
        return (
          (x === y && x !== 0) || 1 / x === 1 / y || (x !== x && y !== y) // eslint-disable-line no-self-compare
        );
      }

      // 런타임에 Object.is가 있다면 그걸 사용, 아니라면 위 함수 사용
      // Object.is는 구버전 브라우저 등에 존재하지 않기 때문에 폴리필로 대체하는 것으로 생각됨
      const objectIs: (x: any, y: any) => boolean =
        typeof Object.is === "function" ? Object.is : is;

      export default objectIs;
      ```
- 이 `objectIs`를 기반으로 동등 비교를 하는 `shallowEqual`이라는 함수를 만들어서 사용합니다. `shallowEqual`은 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용됩니다.
  - 리액트에서 값을 비교 - `shallowEqual`
    - https://github.com/facebook/react/blob/main/packages/shared/shallowEqual.js
      ```jsx
      import is from "./objectIs";
      // 다음 코드는 Object.prototype.hasOwnProperty
      // 객체에 특정 프로퍼티가 있는지 확인하는 메서드
      import hasOwnProperty from "./hasOwnProperty";

      // 객체의 키를 순회하면서 두 값의 엄격한 동등성을 체크하고,
      // 다른 값이 있다면 false, 모든 키의 값이 동일하다면 true

      // 단순히 Object.is를 수행하는 것뿐만 아니라 객체 간의 비교도 추가돼 있음
      function shallowEqual(objA: mixed, objB: mixed): boolean {
        if (is(objA, objB)) {
          return true;
        }

        if (
          typeof objA !== "object" ||
          objA === null ||
          typeof objB !== "object" ||
          objB === null
        ) {
          return false;
        }

        // 각 키 배열을 꺼냄
        const keysA = Object.keys(objA);
        const keysB = Object.keys(objB);

        // 배열 길이를 통한 비교
        if (keysA.length !== keysB.length) {
          return false;
        }

        // A의 키를 기준으로, B에 같은 키가 있는지, 그리고 그 값이 같은지 체크
        for (let i = 0; i < keysA.length; i++) {
          const currentKey = keysA[i];
          if (
            !hasOwnProperty.call(objB, currentKey) ||
            // $FlowFixMe[incompatible-use] lost refinement of `objB`
            !is(objA[currentKey], objB[currentKey])
          ) {
            return false;
          }
        }

        return true;
      }

      export default shallowEqual;
      ```
- 리액트에서의 비교를 요약하자면, `Object.is`로 먼저 비교를 수행한 다음에 `Object.is`로 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한번 더 수행하는 것을 알 수 있습니다. 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미합니다.

# 1.2 함수

- 리액트에서는 `Component`라고 하는 함수를 선언하고 매개변수로는 일반적으로 `props`라고 부르는 단일 객체를 받으며 `return` 문으로 JSX를 반환합니다. 일반적인 함수와의 차이점이라고 한다면, 자바스크립트에서는 `Component(props)` 형태로 호출하지만, 리액트에서의 함수형 컴포넌트는 `<Component hello={props.hello} … />`와 같이 JSX 문법으로 단일 `props`별로 받거나, `<Component {…props} />` 같은 형태로 모든 `props`를 전개 연산자로 받는다는 것입니다.

## 1.2.2 함수를 정의하는 4가지 방법

### 함수 선언문

```jsx
function add(a, b) {
  return a + b;
}
```

- 함수 선언문은 표현식이 아닌 일반 문(statement)으로 분류됩니다. 표현식이란 값을 산출하는 구문을 의미합니다.

```jsx
const sum = function add(a, b) {
  return a + b;
};

sum(10, 24);
```

- 자바스크립트 엔진은 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문에, 함수 리티럴은 코드 문맥에 따라 전자와 같은 선언문으로도, 후자와 같은 표현식으로도 사용될 수 있습니다.

### 함수 표현식

- 프로그래밍 세계에서 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미하는데, 함수는 다른 함수의 매개변수가 되거나 반환값이 될 수도, 할당도 가능하므로 일급 객체의 조건을 갖추고 있습니다.

```jsx
// 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 게 일반적
// 혼란을 방지하기 위해 실제 프로덕션 코드에서는 사용하지 않음
const sum = function add(a, b) {
  console.log(arguments.callee.name);
  return a + b;
};

sum(10, 24);
// add
add(10, 24); // add is not defined
```

- 여기서 `add`는 함수를 외부로 호출하는 데에 사용할 수 없는 식별자로 도리어 코드를 읽는 데 방해 요소입니다.

**함수 표현식과 선언식의 차이**

```jsx
console.log(typeof hello === "undefined"); // true

hello(); // Uncaught TypeError: hello is not a function

var hello = function () {
  console.log("hello");
};

hello();
```

- 함수 표현식은 함수를 변수에 할당하고, 변수도 선언식처럼 호이스팅 되지만, 함수의 호이스팅과는 다르게 호이스팅 되는 시점에서 `var`의 경우 `undefined`로 초기화한다는 차이가 있습니다. 함수와 다르게 변수는 런타임 이전에 `undefined`로 초기화하고, 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동된다는 것을 알 수 있습니다.

### Function 생성자

```jsx
const add = new Function("a", "b", "return a + b");

add(10, 24);
```

- 가독성과 코드 작성 관점에서 좋지 않고, 함수의 클로저 또한 생성되지 않아서 거의 사용되지 않습니다.

### 화살표 함수

```jsx
const add = (a, b) => {
  return a + b;
};

const add2 = (a, b) => a + b;
```

- 화살표 함수는 `prototype` 프로퍼티를 갖고 있지 않아 `constructor`, 즉 생성자 함수를 사용할 수 없습니다.
  ```jsx
  const Car = (name) => {
    thi.name = name;
  };

  // Car is not a constructor
  const myCar = new Car("하이");
  ```
- `arguments`라는 유사배열이 존재하지 않습니다.
  ```jsx
  function hello() {
    console.log(arguments);
  }

  hello(1, 2, 3);

  const hi = () => {
    console.log(arguments);
  };

  hi(1, 2, 3);
  ```
- 가장 큰 차이점은 `this` 바인딩입니다. `this`는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값입니다. 이 `this`는 화살표 함수 이전까지는 함수를 정의할 때 결정되는 것이 아니라, 함수가 어떻게 호출되느냐에 따라 동적으로 결정됩니다.
- 객체 내 메소드가 호출되는 경우 그 안에 있는 `this`는 해당 객체를 가리키지만, 해당 메소드를 별도의 변수에 담아서 전역에서 호출하는 경우에는 다시 `window`를 가리키게 됩니다. `new`를 붙여서 생성자 함수를 호출하게 되면 `this`는 생성자를 통해 생성된 인스턴스, 그 자신이 됩니다. 다만 이벤트 리스너를 사용하는 경우 `window`가 아닌 이벤트가 발생하는 해당 객체를 가리키게 됩니다. 때문에 이벤트 리스너를 사용하는 경우엔 내부의 `this`가 바꼈음을 명시적으로 알리거나 ES6의 arrow function을 사용하는 편이 좋습니다. arrow function 사용 시 해당 함수 안에 `this`는 `window`가 아닌 상위 함수의 this를 가리키게 됩니다.
- 화살표 함수는 함수 자체의 바인딩을 갖지 않아서 화살표 함수 내부에서 `this`를 참조하면 상위 스코프의 `this`를 그대로 따르게 됩니다.
- 바벨에서의 트랜스파일링
  ```jsx
  // before:
  const hello = () => {
    console.log(this);
  };

  function hi() {
    console.log(this);
  }

  // after: 바벨에서의 변환
  var _this = void 0;

  var hello = function hello() {
    // 바벨에서 화살표 함수 내부의 _this 자체를 undefined로 바뀌버림
    console.log(_this);
  };

  function hi() {
    console.log(this);
  }
  ```

## 1.2.3 다양한 함수 살펴보기

### 즉시 실행 함수

- 한번만 호출하고 재호출이 불가능한 함수로, 일반적으로 이름을 붙이지 않습니다. 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있고, 일단 선언되어 있으면 어디든 사용되는 일반 함수와는 다르게 명시적으로 거기서 끝난다는 걸 각인시킬 수 있어서 리팩토링이나 가독성에도 도움이 됩니다.
  ```jsx
  (function (a, b) {
    return a + b;
  })(10, 24);

  ((a, b) => {
    return a + b;
  })(10, 24);
  ```

### 고차 함수

- 자바스크립트의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과로 새로운 함수를 반환할 수 있는데, 이런 역할을 하는 함수를 고차 함수(Higher Order function)라고 합니다.
  ```jsx
  // 함수를 반환하는 고차 함수의 예
  const add = function (a) {
    // a가 존재하는 클로저를 생성
    return function (b) {
      // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
      return a + b;
    };
  };

  add(1)(3); // 4
  ```

## 1.2.4 함수를 만들 때 주의해야 할 사항

### 함수의 부수 효과를 최대한 억제하라

- 함수의 부수 효과(side-effect)란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미하는데, 이런 부수 효과가 엇는 함수를 순수 함수라고 하고, 부수 효과가 존재하는 함수를 비순수 함수라고 합니다. 즉, 순수 함수는 부수 효과가 없고, 언제 어디서든 동일한 인수를 받으면 동일한 결과를 반환해야 합니다.
  ```jsx
  function PureComponent(props) {
    const { a, b } = props;
    return <div>{a + b}</div>;
  }
  ```
- 하지만 우리가 개발하면서 컴포넌트 내부에서 API를 호출한다거나 `console.log` 를 남기는 것들 또한 외부에 효과를 미치는 것이기 때문에 비순수 함수의 요소는 개발에 있어서 피할 수 없기도 합니다. 다만 최대한 억제하는 방향으로 생각해야 하는데, `useEffect`의 작동을 최소화하는 것이 그 일환이라고 볼 수 있는데, 해당 함수의 역할을 줄이고 버그를 줄여서 안정성을 높일 수 있습니다.

### 가능한 한 함수를 작게 만들어라

- 하나의 함수에서 너무 많은 일을 하지 않게 하고, 하나의 일을 잘하게 만드는 것이 함수의 재사용성을 높일 수 있는 방법입니다. 최적의 함수 크기를 단언할 순 없지만 프로젝트에 따라 유동적으로 적용하는 것이 중요합니다.

### 누구나 이해할 수 있는 이름을 붙여라

- 가능한 함수 이름은 간결하고 쉽게 붙이는 것이 추후 유지보수에도 용이합니다.

# 1.4 클로저

- 리액트의 클래스형 컴포넌트에 대한 이해가 클래스, 프로토타입, this에 달려 있다면, 함수형 컴포넌트에 대한 이해는 클로저에 달려 있습니다. 함수형 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수형 컴포넌트 대부분의 기술이 모두 클로저에 의존합니다.

## 1.4.1 클로저의 정의

## 참고자료

- 모던 리액트 Deep Dive(김용찬, 2023)
- https://poiemaweb.com/es6-arrow-function
- https://www.zerocho.com/category/JavaScript/post/5b0645cc7e3e36001bf676eb
- [https://velog.io/@gonasooc/this에-대해-설명해주세요](https://velog.io/@gonasooc/this%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [https://velog.io/@gonasooc/클로저Closure](https://velog.io/@gonasooc/%ED%81%B4%EB%A1%9C%EC%A0%80Closure)
