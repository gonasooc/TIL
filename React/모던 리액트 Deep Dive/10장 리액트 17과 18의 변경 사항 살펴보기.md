# 10.1 리액트 17 버전 살펴보기

- 리액트 17 버전은 새롭게 추가된 기능 없이 호환성이 깨지는 변경 사항, 즉 기존 코드 수정을 필요로 하는 변경사항을 최소화했다는 점을 갖방 큰 특징으로 꼽습니다.

## 10.1.1 리액트의 점진적인 업그레이드

- 16에서 17로의 업데이트는 더 이상 호환되지 않는 API가 있거나 새로운 리액트 17을 사용하는 데 있어 이전과 작동 방식이 달라질 수 있기 때문에 사실상 새로운 업그레이드를 요구하고 있었습니다.
- 리액트 17부터는 점진적인 업그레이드가 가능해지는데, 일부 기능에 대해서는 리액트 17에 머물러 있는 것이 가능해졌습니다. 물론 서로 다른 두 개의 리액트를 관리해야 하기 때문에 이상적인 방법이 아닐 수도 있으나, 한번에 버전을 올리기엔 부담이 되는 큰 애플리케이션의 경우 고려해볼 만합니다.

## 10.1.2 이벤트 위임 방식의 변경

- 직접 DOM에 접근해 이벤트를 추가하는 것과(`useRef` 사용) 리액트 문법에서 직접 이벤트를 추가하는 것에서는 차이가 있는데, 직접 DOM에 접근해서 이벤트를 추가하면 실제로 그 이벤트 핸들러가 추가되어 있지만, 리액트 문법으로 이벤트를 추가하면 이벤트 타입당 하나의 핸들러를 루트에 부착합니다. 즉 이벤트 위임을 통해 작동하게 됩니다.
- 이벤트는 아래와 같이 구성되어 있습니다.
  - 캡처(capture): 이벤트 핸들러가 트리 최상단 요소부터 시작해서 실제 이벤트가 발생한 티깃 요소까지 내려가는 것을 의미
  - 타깃(target): 이벤트 핸들러가 타깃 노드에 도달하는 단계, 이 단계에서 이벤트 호출
  - 버블링(bubbling): 이벤트가 발생한 요소에서부터 시작해 최상위 요소로 올라감
- 리액트는 최초 릴리스부터 이런 이벤트 위임을 적극 활용했고, 리액트 16 버전까지는 모두 `document`에서 수행되고 있었습니다. 리액트 17부터는 이런 이벤트 위임이 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었습니다.
- 한 애플리케이션 내에 다른 리액트 버전이 존재하거나 jQuery 등 다른 라이브러리와 혼재되어 있는 경우 리액트 버블링으로 인한 혼선이 생길 수 있었는데, 각 이벤트가 해당 리액트 컴포넌트 트리 수준으로 격리되게 되면 이런 부분에 해소될 수 있습니다.

## 10.1.3 import React from ‘react’가 더 이상 필요 없다: 새로운 JSX transform

- 16 버전까지는 코드 내에 React를 사용하는 구문이 없더라도 `import React from ‘react’`가 필요했는데, 17 버전부터는 바벨과 협력해 이런 `import` 구문 없이도 JSX를 변환할 수 있게 변경되었습니다.

## 10.1.4 그 밖의 주요 변경 사항

### 이벤트 풀링 제거

- 리액트 16에 존재하던 이벤트 풀링 기능이 제거되었습니다.

### useEffect 클린업 함수의 비동기 실행

- 리액트 16에서는 클린업 함수가 동기적으로 처리됐는데, 동기적으로 실행되다 보니 다른 작업을 방해하기 때문에 불필요한 성능 저하로 이어지는 문제가 있었습니다. 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행되는데, 즉 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 자연됩니다. 화면의 업데이트가 완료된 후에 실행되기 때문에 성능적인 이점을 볼 수 있게 됐습니다.

### 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 리액트 16에서 `forwardRef`나 `memo`에서 `undefined`를 반환하는 경우 별 다른 에러가 발생하지 않는 문제가 있었는데, 17 버전에서는 일관적으로 처리되도록 변경되었습니다. 참고로 18부터는 `undefined`를 반환해도 에러가 발생하지 않습니다.

# 10.2 리액트 18 버전 살펴보기

## 10.2.1 새로 추가된 훅 살펴보기

### useId

- `useId`는 컴포넌트별로 유니크한 값을 생성하는 새로운 훅인데, 어떤 요소의 독립적인 `id`가 필요한 경우나 해당 컴포넌트의 공통적인 접두사 혹은 접미사가 필요할 때 사용 가능합니다.

### useTransition

- `useTransition`은 리액트 18의 변경 사항의 핵심 중 하나인 ‘동시성(concurrency)’을 다룰 수 있는 새로운 훅입니다. 과거 리액트의 모든 렌더링은 동기적으로 작동해 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만 `useTransition`과 같은 동시성을 지원하는 기능을 사용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 혹은 지금 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 합니다. 즉, 렌더링 블로킹을 하지 않는데,. 이건 마치 `async`와 `await`처럼 비동기로 렌더링하기 때문입니다.
- `useTransition`을 사용할 때 주의할 점이 몇 가지 있습니다.
  - `startTransition` 내부에 반드시 `setState` 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있음, 만약 `props`나 사용자 정의 훅에서 반환하는 값을 사용하고 싶다면 뒤이어 설명할 `useDefferedValue` 사용 가능
  - `startTransition`으로 넘겨주는 다른 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있음, 타이핑으로 인해 `setState`가 일어나는 경우 타이핑이 끝날 때까지 `useTransition`으로 지연시킨 상태 업데이트는 일어나지 않음
  - `startTransition`으로 넘겨주는 함수는 반드시 동기 함수여야 함, 비동기 함수는 함수가 실행되는 작업 사이에 불일치가 일어남

### useDeferredValue

- `useDeferredValue`는 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅으로, 일반적으로 디바인스와 비슷하지만 디바운스 대비 몇 가지 장점이 있습니다.
- 디바운스는 고정된 지연 시간을 필요로 하지만 `useDeferredValue`는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 이 `useDeferredValue`로 지연된 렌더링을 수행합니다.
- `useTransition`은 `state` 값을 업데이트하는 함수를 감싸서 사용하지만, `useDeferredValue`는 `state` 자체만을 감싸서 사용하는 것을 볼 수 있습니다. 방식에 차이가 있지만 동일할 역할을 수행합니다.

### useSyncExternalStore

- `useSyncExternalStore`는 일반적인 애플리케이션 코드를 작성할 땐 사용할 일이 별로 없는 훅인데, 18 버전에서 `useTransition`, `useDefferedValue`를 사용해 동시성 이슈가 발생할 수 있습니다. 그리고 외부 데이터 소스에 리액트에서 추구하는 동시성 처리가 추가돼 있지 않다면 테어링(tearing) 현상이 발생할 수 있어서 이 문제를 해결하기 위한 훅이 `userSyncExternalStore`입니다.

### useInsertionEffect

- `useSyncExternalStore`가 상태 관리 라이브러리를 위한 훅이라면 `useInsertionEffect`는 CSS-in-js 라이브러리를 위한 훅입니다.
