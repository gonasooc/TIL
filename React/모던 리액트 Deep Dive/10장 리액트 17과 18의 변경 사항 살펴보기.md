# 10.1 리액트 17 버전 살펴보기

- 리액트 17 버전은 새롭게 추가된 기능 없이 호환성이 깨지는 변경 사항, 즉 기존 코드 수정을 필요로 하는 변경사항을 최소화했다는 점을 가장 큰 특징으로 꼽습니다.

## 10.1.1 리액트의 점진적인 업그레이드

- 16에서 17로의 업데이트는 더 이상 호환되지 않는 API가 있거나 새로운 리액트 17을 사용하는 데 있어 이전과 작동 방식이 달라질 수 있기 때문에 사실상 새로운 업그레이드를 요구하고 있었습니다.
- 리액트 17부터는 점진적인 업그레이드가 가능해지는데, 일부 기능에 대해서는 리액트 17에 머물러 있는 것이 가능해졌습니다. 물론 서로 다른 두 개의 리액트를 관리해야 하기 때문에 이상적인 방법이 아닐 수도 있으나, 한번에 버전을 올리기엔 부담이 되는 큰 애플리케이션의 경우 고려해볼 만합니다.

## 10.1.2 이벤트 위임 방식의 변경

- 직접 DOM에 접근해 이벤트를 추가하는 것과(`useRef` 사용) 리액트 문법에서 직접 이벤트를 추가하는 것에서는 차이가 있는데, 직접 DOM에 접근해서 이벤트를 추가하면 실제로 그 이벤트 핸들러가 추가되어 있지만, 리액트 문법으로 이벤트를 추가하면 이벤트 타입당 하나의 핸들러를 루트에 부착합니다. 즉 이벤트 위임을 통해 작동하게 됩니다.
- 이벤트는 아래와 같이 구성되어 있습니다.
  - 캡처(capture): 이벤트 핸들러가 트리 최상단 요소부터 시작해서 실제 이벤트가 발생한 티깃 요소까지 내려가는 것을 의미
  - 타깃(target): 이벤트 핸들러가 타깃 노드에 도달하는 단계, 이 단계에서 이벤트 호출
  - 버블링(bubbling): 이벤트가 발생한 요소에서부터 시작해 최상위 요소로 올라감
- 리액트는 최초 릴리스부터 이런 이벤트 위임을 적극 활용했고, 리액트 16 버전까지는 모두 `document`에서 수행되고 있었습니다. 리액트 17부터는 이런 이벤트 위임이 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었습니다.
- 한 애플리케이션 내에 다른 리액트 버전이 존재하거나 jQuery 등 다른 라이브러리와 혼재되어 있는 경우 리액트 버블링으로 인한 혼선이 생길 수 있었는데, 각 이벤트가 해당 리액트 컴포넌트 트리 수준으로 격리되게 되면 이런 부분에 해소될 수 있습니다.

## 10.1.3 import React from ‘react’가 더 이상 필요 없다: 새로운 JSX transform

- 16 버전까지는 코드 내에 React를 사용하는 구문이 없더라도 `import React from ‘react’`가 필요했는데, 17 버전부터는 바벨과 협력해 이런 `import` 구문 없이도 JSX를 변환할 수 있게 변경되었습니다.

## 10.1.4 그 밖의 주요 변경 사항

### 이벤트 풀링 제거

- 리액트 16에 존재하던 이벤트 풀링 기능이 제거되었습니다.

### useEffect 클린업 함수의 비동기 실행

- 리액트 16에서는 클린업 함수가 동기적으로 처리됐는데, 동기적으로 실행되다 보니 다른 작업을 방해하기 때문에 불필요한 성능 저하로 이어지는 문제가 있었습니다. 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행되는데, 즉 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연됩니다. 화면의 업데이트가 완료된 후에 실행되기 때문에 성능적인 이점을 볼 수 있게 됐습니다.

### 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 리액트 16에서 `forwardRef`나 `memo`에서 `undefined`를 반환하는 경우 별 다른 에러가 발생하지 않는 문제가 있었는데, 17 버전에서는 일관적으로 처리되도록 변경되었습니다. 참고로 18부터는 `undefined`를 반환해도 에러가 발생하지 않습니다.

# 10.2 리액트 18 버전 살펴보기

## 10.2.1 새로 추가된 훅 살펴보기

### useId

- `useId`는 컴포넌트별로 유니크한 값을 생성하는 새로운 훅인데, 어떤 요소의 독립적인 `id`가 필요한 경우나 해당 컴포넌트의 공통적인 접두사 혹은 접미사가 필요할 때 사용 가능합니다.

### useTransition

- `useTransition`은 리액트 18의 변경 사항의 핵심 중 하나인 ‘동시성(concurrency)’을 다룰 수 있는 새로운 훅입니다. 과거 리액트의 모든 렌더링은 동기적으로 작동해 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만 `useTransition`과 같은 동시성을 지원하는 기능을 사용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 혹은 지금 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 합니다. 즉, 렌더링 블로킹을 하지 않는데, 이건 마치 `async`와 `await`처럼 비동기로 렌더링하기 때문입니다.
- `useTransition`을 사용할 때 주의할 점이 몇 가지 있습니다.
  - `startTransition` 내부에 반드시 `setState` 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있음, 만약 `props`나 사용자 정의 훅에서 반환하는 값을 사용하고 싶다면 뒤이어 설명할 `useDefferedValue` 사용 가능
  - `startTransition`으로 넘겨주는 다른 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있음, 타이핑으로 인해 `setState`가 일어나는 경우 타이핑이 끝날 때까지 `useTransition`으로 지연시킨 상태 업데이트는 일어나지 않음
  - `startTransition`으로 넘겨주는 함수는 반드시 동기 함수여야 함, 비동기 함수는 함수가 실행되는 작업 사이에 불일치가 일어남

### useDeferredValue

- `useDeferredValue`는 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅으로, 일반적으로 디바운스와 비슷하지만 디바운스 대비 몇 가지 장점이 있습니다.
- 디바운스는 고정된 지연 시간을 필요로 하지만 `useDeferredValue`는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 이 `useDeferredValue`로 지연된 렌더링을 수행합니다.
- `useTransition`은 `state` 값을 업데이트하는 함수를 감싸서 사용하지만, `useDeferredValue`는 `state` 자체만을 감싸서 사용하는 것을 볼 수 있습니다. 방식에 차이가 있지만 동일할 역할을 수행합니다.

### useSyncExternalStore

- `useSyncExternalStore`는 일반적인 애플리케이션 코드를 작성할 땐 사용할 일이 별로 없는 훅인데, 18 버전에서 `useTransition`, `useDefferedValue`를 사용해 동시성 이슈가 발생할 수 있습니다. 그리고 외부 데이터 소스에 리액트에서 추구하는 동시성 처리가 추가돼 있지 않다면 테어링(tearing) 현상이 발생할 수 있어서 이 문제를 해결하기 위한 훅이 `userSyncExternalStore`입니다.

### useInsertionEffect

- `useSyncExternalStore`가 상태 관리 라이브러리를 위한 훅이라면 `useInsertionEffect`는 CSS-in-js 라이브러리를 위한 훅입니다.

## 10.2.2 react-dom/client

- 클라이언트에서 리액트 트리를 만들 때 사용되는 API가 변경돼서 18 이하 버전에서 만든 create-react-app으로 유지보수 중이라면 18로 업그레이드할 때 반드시 index.t{t|j}.jsx에 있는 내용을 변경해야 합니다.

### createRoot

- 기존의 react-dom에 있던 `render` 메서드를 대체할 새로운 메서드입니다.

### hydrateRoot

- SSR에서 하이드레이션을 하기 위한 새로운 메서드로 React DOM 서버 API와 함께 사용합니다.

## 10.2.3 react-dom/server

### reactToPipeableStream

- 리액트 컴포넌트를 HTML로 렌더링하는 메서드입니다. 스트림을 지원하는 메서드로, HTML를 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있습니다. 이를 통해 서버에서는 Suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링되게끔 할 수 있습니다.

### reactToReadableStream

- `renderToPipeableStream`이 Node.js 환경에서의 렌더링을 위해 사용된다면, `reactToReadableStream`은 웹 스트림(web stream)을 기반으로 작동한다는 차이가 있습니다.

## 10.2.4 자동 배치(Automatic Batching)

- 자동 배치, 이른바 Automatic Batching은 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미합니다. 예컨대, 버튼 클릭 한 번에 두 개 이상의 `state`를 동시에 업데이트한다고 가정했을 때, 자동 배치에서는 이를 하나의 리렌더링으로 묶어서 수행할 수 있습니다.

## 10.2.5 더욱 엄격해진 엄격 모드

### 리액트의 엄격 모드

- 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고로 별도의 로그를 확인할 수 있습니다.
- 과거에는 `createRef` 없이 컴포넌트 내부에서 문자열로 `ref`를 생성하고 이를 사용해 DOM에 접근할 수 있었는데, 몇 가지 문제가 있어 사용이 금지됐고 따라서 엄격 모드에서는 경고 문구가 출력됩니다.
- `findDOMNode`는 클래스 컴포넌트에서 실제 DOM 요소에 대한 참조를 가져올 수 있는 메서드로 현재는 권장되지 않기 때문에 경고 문구가 출력됩니다.
- 구 `Context API` 사용 시 발생하는 경고가 존재합니다.
- 예상치 못한 부작용(side-effects) 검사로, 리액트 엄격 모드 내부에서는 다음을 의도적으로 이중으로 호출합니다.
  - 클래스형 컴포넌트의 `constructor`, `render`, `shouldComponentUpdate`, `getDerivedStateFromProps`
  - 클래스형 컴포넌트의 `setState`의 첫 번째 인수
  - 함수형 컴포넌트의 `body`
  - `useState`, `useMemo`, `useReducer`에 전달되는 함수

### 리액트 18에서 추가된 엄격 모드

- 향후 리액트에서는 컴포넌트가 마운트 해제된 상태에서도 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정이라고 밝혔습니다. 이런 기능을 향후에 지원하기 위해 엄격 모드의 개발 모드에 컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두 번째 마운트에서 이전 상태를 복원하게 됩니다. 이 기능은 오직 개발 모드에서만 적용됩니다.

## 10.2.6 Suspense 기능 강화

- Suspense는 두 개의 인수를 받는데, 하나는 `fallback` props로, 지연시켜 불러온 컴포넌트를 미처 불러오지 못했을 때 보여주는 `fallback`을 나타냅니다. 그리고 `children`으로는 `React.lazy`로 선언한 지연 컴포넌트를 받습니다. 지연 컴포넌트를 로딩하기 전에는 `fallback`을 보여주고, 지연 로딩이 완료되면 해당 컴포넌트를 보여주게 됩니다.
- 그러나 18 이전의 Suspense는 몇 가지 문제점이 있었습니다. 컴포넌트가 아직 보이기도 전에 `useEffect`가 실행되는 문제가 존재했고, Suspense는 서버에서 사용할 수 없기도 했습니다.
- 18에서는 앞서 문제들이 수정됐고, 추가로 Suspense 내에 스로틀링이 추가됐는데, 중첩된 Suspense의 `fallback`이 있다면 자동으로 스로틀되어 최대한 자연스럽게 보여주기 위해 노력합니다.

## 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- 리액트 18에서는 리액트를 사용하는 코드에서 `Promise`, `Symbol`, `Object.assign` 이 세 가지 최신 자바스크립트 기능을 사용할 수 있다는 가정하에 배포됩니다. 만약 이 기능을 지원하지 않는 브라우저에서 서비스해야 한다면 폴리필을 반드시 추가해야 합니다.

## 10.2.8 그 밖에 알아두면 좋은 변경사항

- 이제 컴포넌트에서 `undefined`를 반환해도 에러가 발생하지 않습니다. `undefined` 반환은 `null` 반환도 동일하게 처리됩니다.
- 이와 마찬가지로 `<Suspense fallback={undefined>`도 `null`과 동일하게 처리됩니다.
- `renderToNodeStream`이 지원 중단돼서 `renderToPipeableStream` 사용을 권장합니다.
