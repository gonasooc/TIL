# 1장 블로그 서비스 최적화

### 최적화 기법

- 이미지 사이즈 최적화
- 코드 분할 - 코드를 분할하는 기법, SPA 특성상 하나의 자바스크립트 파일로 번들링되어 로드되기 때문에, 코드 분할을 통해 당장은 필요 없는 코드를 떼어 내고, 해당 코드를 필요한 시점에 따로 로드
- 텍스트 압축 - HTML, CSS, 자바스크립트 등을 다운로드 하기 전에 서버에서 미리 압축하여 빠르게 로드
- 병목 코드 최적화 - 서비스를 느리게 만드는 병목 코드를 찾아내고 최적화

### Lighthouse 툴을 이용한 페이지 검사

- Mode와 Categories 항목 값 소개
  - Mode
    - Navigation: Lighthouse의 기본 값으로, 초기 페이지 로딩 시 발생하는 성능 문제 분석
    - Timespan: 사용자가 정의한 시간 동안 발생한 성능 문제 분석
    - Snapshot: 현재 상태의 성능 문제 분석
  - Categories
    - Performance: 웹 페이지 로딩 과정에서 발생하는 성능 문제 분석
    - Accessibility: 서비스의 사용자 접근성 문제 분석
    - Best practices: 웹사이트 보안 측면과 웹 개발의 최신 표준에 중점을 두고 분석
    - SEO: 검색 엔진에서 얼마나 잘 크롤링되고 검색 결과에 표시되는지 분석
    - Progressive Web App: 서비스 워커와 오프라인 동작 등, PWA와 관련된 문제 분석

### Lighthouse 검사 결과

- First Contentful Paint(FCP) - 브라우저가 DOM 콘텐츠의 첫 번째 부분을 렌더링하는 데 걸리는 시간 지표, 총점 계산 시 10%의 가중치를 가짐
- Speed Index(SI) - 페이지 로드 중에 콘텐츠가 시각적으로 표시되는 속도를 나타내는 지표, 일부 콘텐츠가 순차적으로 표시되면 더 높은 점수를 받음, 총점 계산 시 10%의 가중치를 가짐
- Largest Contentful Paint(LCP) - 화면 내에 가장 큰 이미지나 텍스트 요소가 렌더링되기까지 걸리는 시간을 나타내는 지표, 총점 계산 시 25%의 가중치를 가짐
- Time to Interactive(TTI) - 사용자와 상호 작용이 가능한 시점까지 걸리는 시간을 측정한 지표, 총점 계산 시 10%의 가중치를 가짐
- Total Blocking Time(TBT) - 클릭, 키보드 입력 등의 사용자 입력에 응답하지 않도록 차단된 시간을 총합한 지표, FCP와 TTI 사이의 시간 동안 일어나며 메인 스레드를 독점하여 다른 동작을 방해하는 작업에 걸린 시간을 총합, 총점 계산 시 30%의 가중치를 가짐
- Cumulative Layout Shift(CLS) - 레이아웃 이동을 측정한 지표, 총점 계산 시 15%의 가중치를 가짐

### 이미지 사이즈 최적화

- ‘Properly size images’ - 이미지 CDN을 통해서 레이아웃에 맞는 적절한 사이즈의 이미지를 배치

### 병목 코드 최적화

- ‘Reduce JavaScript execution time’ - Lighthouse에서는 어떤 특정 자바스크립트 코드 때문에 느려졌다는 건 알 수 있지만 정확히 파악하려면 Performance를 이용해야 함
- CPU 차트, Network 차트, 스크린샷
  - CPU 차트는 시간에 따라 CPU가 어떤 작업에 리소스를 사용하고 있는지 비율로 보여줌, 자바스크립트 실행 작업은 노란색, 렌더링/레이아웃 작업은 보라색, 페인팅 작업은 초록색, 기타 시스템 작업은 회색, 빨간색 선은 병목이 발생하는 지점인데, 특정 작업이 메인 스레드를 오랫동안 잡아두고 있다는 의미
  - Network 차트는 CPU 차트 밑에 막대 형태로 표시, 상단 진한 막대는 우선순위가 높은 네트워크 리소스, 하단 옅은 막대는 우선순위가 낮은 네트워크 리소스
  - 그 아래 스크린샷을 통해 서비스가 로드되는 과정을 보여줌
- Network 타임라인
  - 왼쪽 회색 실선: 초기 연결 시간
  - 막대의 옅은 색 영역: 요청을 보낸 시점부터 응답을 기다리는 시점까지 시간(TTFB, Time to First Byte)
  - 막대의 짙은 색 영역: 콘텐츠 다운로드 시간
  - 오른쪽 회색 실선: 해당 요청에 대한 메인 스레드의 작업 시간
- Frames, Timings, Main
  - Frames: 화면상 변화가 있을 때마다 스크린샷
  - Timings: User Timing API를 통해 기록된 정보 기록, 리액트 17 이후로 정확성 및 유지 보수 문제로 지원 종료
  - Main: 브라우저의 메인 스레드에서 실행되는 작업을 플레임 차트로 보여줌, 어떤 작업이 오래 걸리는지 파악 가능
- 하단 탭
  - Summary: 선택 영역의 작업 시간의 총합, 각 작업이 차지하는 비중
  - Bottom-Up: 최하위 작업부터 상위 작업까지 역순으로 보여줌
  - Call Tree: 상위 작업부터 하위 작업 순으로 작업 내용을 트리뷰로 보여줌
  - Event Log: 발생 이벤트 출력

### 코드 분할 & 지연 로딩

- 다운로드가 오래 걸리는 자바스크립트 파일(ex) 0.chunk.js)이 어떤 코드로 이루어져 있는지 보기 위해 webpack-bundle-analyzer라는 패키지를 통해 확인 가능, 트리맵으로 시각화해서 보여줌
- 단, webpack 설정을 직접 수정해줘야 하기 때문에 CRA로 생성한 프로젝트의 경우 cra-bundle-analyzer 사용
- 코드 분할 - 페이지에서 필요한 코드만 따로 로드하면 불필요한 코드를 로드하지 않아 더욱 빨라질 수 있음, 코드 분할(Code Splitting) 기법을 이용해서 페이지별로 코드를 분리, 말 그대로 코드를 분할하는 기법으로 하나의 번들 파일을 여러 개의 파일로 쪼개는 방법
- 지연 로딩 - 분할된 코드를 사용자가 서비스를 이용하는 중 해당 코드가 필요한 시점에 로드되어 실행
- JavaScript 내에선 동적 import를 사용할 수 있지만, 리액트에선 lazy와 Suspense를 활용해서 간편하게 동적 import 가능
