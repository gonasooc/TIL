# 2곳 중 1곳은 무조건 합격하는 개발자 이력서 만들기 - 지소라

## 피드백 그 무한굴레 - 피드백 그 끝은 어디인가

- “네 이력서는 너무 말랑말랑해” → 이력서 = 가장 dry한 문서 → T의 문서
  - ex) 애플리케이션 UX개선(Why)을 위해 Vue.js를 이용한(How) 유료회원 전용 웹 애플리케이션 기획, UI 디자인 설계 및 테크 리드(What)
- “길다” → “컴팩트하게 만드는 것도 능력” → 메인 내용은 1장 내 권유
- “그래서 뭘 할 줄 안다는 거에요?” → “이런 것도 해봤어요”식의 뱃지 모으기보다는 “이렇게 해본 것으로 이런 것까지 만들어 봤어요”가 중요
- “내용이 개발에 초점이 맞춰져 있지 않다” → 기획 능력(X) → 개발자 = 기술적으로 문제를 해결하는 사람 → 어떤 문제가 있었고, 어떤 식으로 구체화했고, 기술적으로 어떻게 해결했는지

## NOT ENOUGH, I NEED A KICK - 포트폴리오를 킥으로 사용하자

- “여태까지의 작업물을 모아볼 수 있는 모음집 부재”
- “얼마만큼의, 어떤 고민을 가지고 기술적으로 풀어냈는지 알 수 없음”
- “Problem Solving의 스토리를 작성” → “서사(=스토리)를 작성”
- “주인공인 **우리**가 어떠한 **외적 문제**를 마주한 뒤 **무엇을** 위해서 **어떻게** 문제 해결을 했는지”
- 포트폴리오 작성 순서
  - AS-IS
    - 문제 상황 인지
    - 해결하려고 하는 문제
    - 만들고 싶은 기능
  - Challenge
    - 문제해결을 위해 고민한 내용
    - 어떻게 기술적으로 해결했는지
  - TO-BE
    - 아웃풋(결과)

# 타입스크립트는 왜 그럴까?: 집합으로 이해하는 타입스크립트 - 이정환

## 타입을 집합으로 이해하기

- String 타입, Number 타입 …
- Number 타입 > Number 리터럴 타입 → 슈퍼 타입(부모)인 Number 타입 > 서브 타입(자식)인 Number 리터럴 타입
- 타입 계층도로 이해하는 슈퍼 타입과 서브 타입

## 타입 호환성 이해하기

- 특정 타입의 값을 다른 타입으로 취급해도 괜찮은지 판단하는 것
- 슈퍼 타입과 서브 타입의 관계 속에서 업 캐스팅과 다운 캐스팅 체크

## 타입 계층도와 함께 특수한 타입들 이해하기

- Unknown → 모든 타입의 슈퍼 타입 → 전체 집합
  - 모든 타입의 값을 저장할 수 있음 → 업 캐스팅에 해당하는 연산이기 때문
  - 어떤 타입의 변수에도 저장할 수 없음 → 다운 캐스팅에 해당하는 연산이기 때문
  - 현재 정확한 타입을 알기 어려울 때 사용 → 타입 좁하기(narrowing)와 함께 값을 유연하게 사용 가능
- Never → 모든 타입의 서브 타입 → 공집합
  - 모든 타입의 변수에 저장 가능 → 업 캐스팅에 해당하는 연산이기 때문
  - 어떤 타입의 값도 저장할 수 없음 → 다운 캐스팅에 해당하는 연산이기 때문
  - 호출되지 않아야 하는 함수를 만들 때, 정상적으로는 도달할 수 없는 함수를 만들 때(ex) error 함수), switch문의 완전성을 보장하기 위해 활용 가능
- Any → 타입 계층도를 무시 → 치트키

  - 타입 검사를 받지 않음
  - 예외적으로 Never 타입의 변수에는 저장 불가
  - 불가능한 타입 단언을 가능케 할 수 있음

    ```tsx
    // Not Works
    let str1: string = 10 as string;

    // Works
    let str2: string = 10 as any as string;
    let str3: string = 10 as unknown as string;
    ```

## 객체 타입을 집합으로 바라보기

- 구조적 타입 시스템

  - 프로퍼티를 기준으로 타입을 정의함

    ```tsx
    let person: Person = {
      name: "이정환",
    };

    let student: Student = {
      name: "이정환",
      school: "가톨릭대",
    };

    // Works - 업 캐스팅
    person = student;

    // Not Works - 다운 캐스팅
    student = person;
    ```

## 대수 타입을 집합으로 바라보기

- 대수 타입이란? → 둘 이상의 타입을 합쳐 만든 타입 → Union, Intersection

# Turborepo, Next.js, TypeScript를 이용한 프론트엔드 모노레포 적용기 - 김우현

## 모노레포란?

- 하나의 레포지토리에서 독립적인 여러 프로젝트를 관리하는 방법
- 기존에 많이 쓰던 Multi Repo
  - ex) App, Design System, Lib_A, Lib_B 등의 개별 프로젝트 단위가 각각의 레포에서 관리 → 이걸 하나의 단일 레포에서 관리하는 걸 모노 레포
- 장점
  - 빠른 코드 수정
  - 각 레포마다 사용했던 같은 코드들의 중복 제거
  - 수월한 코드 리팩토링
  - 코드 컨벤션 통일
  - 통합 CI, test 관리
- 단점
  - 의존성 관리 복잡 - 과도한 의존 관계가 생길 수 있음
  - 무거운 프로젝트 (CI 속도 저하)
  - Code ownership 위배

## 모노레포를 선택하게 된 계기?

- 개발자 시점 / 라이브러리 사용하는 개발자 시점 / 운영팀 시점 등.. 여러 시점이 존재하는 경우

## 왜 Turborepo 인가?

- https://d2.naver.com/helloworld/7553804

## Turborepo 적용하기

- Next.js / TypeScript / Yarn 사용 (공식에서는 pnpm 추천)

## 적용 후 장/단점

- 장점
  - 패키지 분리로 인해 공통 로직 관리가 쉬워졌다
  - 코드 구조가 한눈에 잘 보인다
  - Next, TypeScript와 찰떡콩떡
- 단점
  - 의존성 관리가 힘들다
  - 패키지 간의 의존 관계 설계 복잡
  - 모든 패키지를 테스트 하기 때문에 CI는 역시 오래 걸린다

## 결론

- 모노레포는 하나의 제품에 필요한 패키지를 여러 개 만들어야 할 때 적절한 대안

# 실시간 추천 시스템 구축하기 - 정지용

## Session-based Recommender

- Session-based Recommender
- 가장 중요한 User Feature?
  - 유저가 콘텐츠를 소비한 ‘체류시간’
- ex) 예시 데이터
  ```tsx
  {
  	...
  	'action_type': 'view',
  	'user_id': 4040441,
  	'resource_type': 'article',
  	'resource_id': 23411230,
  	'timestamp': 1684821964,
  	...
  }
  ```
- 이런 식으로 발생된 유저 로그 → Apache Beam을 통해 Data Processing → BigTable에 저장
- BIgTable에 유저 로그는 user_id를 key값으로 해서 resource_id, session_id, timestamp 등이 value로 담기게 됨
- timestamp 기반으로 체류 시간을 계산
