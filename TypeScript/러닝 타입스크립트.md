# PART 1. 개념

## CHAPTER 1. 자바스크립트에서 타입스크립트로

### 자바스크립트의 역사

- 1995년 넷스케이프의 브렌던 아이크는 웹사이트에 쉽게 접근하고 사용 가능한 자바스크립트를 10일 만에 설계했습니다. 별난 특성과 결점 덕분에 조롱 받기도 했지만 그 이후 브라우저, 임베디드 애플리케이션, 서버 런타임 환경 등 엄청나게 발전했습니다.

### 바닐라 자바스크립트의 함정

- 순수한 자바스크립트 자체를 바닐라라고 부릅니다.
- 값 비싼 자유 - 코드 구성의 제한이 없고 이런 자유 덕분에 초기엔 재밌지만, 규모가 커질 수록 그 자유가 얼마나 훼손될 수 있는지 명확해집니다.
- 다른 언어는 컴파일러가 충돌할 수 있다 판단되면 코드 실행을 거부할 수 있지만, 충돌 가능성을 먼저 확인하지 않고 코드를 실행하는 동적 타입(Dynamic type) 언어인 자바스크립트는 그렇지 않습니다.
- 부족한 문서 - 블록 주석으로 함수와 변수를 설명하는 JSDoc 표준을 채택했지만, 규모가 있는 코드베이스에서 사용하기 불편합니다.
  - JSDoc 설명이 코드가 잘못되는 것을 막을 수 없고, 이전에는 정확했더라도 코드 리팩토링 중에 생긴 변경 사항과 관련된 현재 유효하지 않은 JSDoc 주석을 모두 찾기는 어려우며, 복잡한 객체를 설명할 때는 다루기 어렵고 장황해서 타입과 그 관계를 정의하려면 다수의 독립형 주석이 필요합니다.

### 타입스크립트

- 타입스크립트는 2010년대 초 마이크로소프트 내부에서 만들어진 후 2012년 출시 및 오픈 소스화되었습니다.
  - 프로그래밍 언어, 타입 검사기, 컴파일러, 언어 서비스
- 타입스크립트는 매개변수와 변수에 제공되는 값의 타입을 지정 가능하고, 명시적으로 작성해야 합니다.
- 잘못된 인수를 사용해서 함수를 호출하는 건 타입스크립트가 제한하는 자바스크립트가 가진 근시안적인 자유입니다.

    ```tsx
    function sayMyName(fullName) {
    	console.log(`You acting kind of shady, ain't callin' me ${fullName}`)
    }
    
    sayMyName("Beyonce", "Knowles");
    ```


## CHAPTER 2. 타입 시스템

### 타입의 종류

- ‘타입’은 자바스크립트에서 다루는 값의 형태, 즉 `typeof` 연산자가 설명하는 것, 그것을 의미합니다.
- 자바스크립트의 일곱 가지 기본 원시 타입(primitive type)이 타입스크립트의 기본적인 타입입니다.
  - `null`
  - `undefined`
  - `boolean` // ture 혹은 false
  - `string` // “”, “Hi!”, “abc123”, …
  - `number` // 0, 2.1, -4, …
  - `bigint` // 0n, 2n, -4n, …
  - `symbol` // Symbol(), Symbol(”hi”), …
- 타입스크립트의 순서

    ```tsx
    let firstName = "Whitney";
    firstName.length();
    
    // This expression is not callable.
    // Type 'Number' has no call signatures.
    ```

  - 코드를 읽고 `firstName`이라는 변수를 이해 → 초깃값이 “Whitney”이므로 `firstName`이 `string`이라고 결론 지음 → `firstName`의 .length 멤버를 함수처럼 호출하는 코드 확인 → `string`의 .length 멤버는 함수가 아닌 숫자라는 오류를 표시, 즉 함수처럼 호출할 수 없음
- 오류 종류
  - 구문 오류: 타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
  - 타입 오류: 타입 검사기에 따라 일치하지 않는 것이 감지된 경우

### 할당 가능성

- 변수의 초깃값을 기준으로 새롭게 할당된 값읠 타입이 변수의 타입과 동일하지 확인합니다. 타입 스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 **할당 가능성(assignability)**이라고 합니다. 즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인합니다.
- ‘Type…is not assignable to type…’

    ```tsx
    let firstName: string = 'Choi';
    firstName = 123;
    
    // Type 'number' is not assignable to type 'string'.
    ```

  - 첫 번째 type은 할당하려 시도한 값, 두 번째 type은 이미 할당된 값

### 타입 에너테이션

- 변수에 초깃값이 없는 경우, 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않고, 기본적으로 변수의 암묵적인 `any` 타입으로 간주합니다. 초기 타입을 유추할 수 없는 변수는 **진화하는 any**라고 부릅니다. 특정 타입을 강제하는 대신 새로운 값이 할당될 때마다 변수 타입에 대한 이해를 발전(진화)시킵니다.
- 일반적으로 `any` 타입으로 진화하는 것을 허용하게 되면 타입 검사 목적을 부분적으로 쓸모없게 만듭니다. (단, 해당 타입에 걸맞는 내장 함수 등은 체크 가능)
- 타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 **타입 에너테이션(type annotation)**을 제공합니다.

    ```tsx
    let rocker: string;
    rocker = "Joan Jett";
    ```

- 자바스크립트로 컴파일하면 해당 타입 애너테이션 코드는 삭제되고, 런타임 코드에도 영향을 주지 않습니다.

### 타입 형태

- 타입스크립트는 해당 자료형의 내장 함수의 존재 유무를 체크하거나, 해당 객체의 key값의 존재 유무를 체크하는 등 원래 타입과 일치하는지 확인하는 것 이상을 수행합니다.
- 스크립트 파일과는 다른 ECMA스크립트 모듈 파일의 선언 스코프

## CHAPTER 3. 유니언과 리터럴

- 타입스크립트가 해당 값을 바탕으로 추론을 수행하는 두 가지 핵심 개념
  - 유니언(union): 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것
  - 내로잉(narrowing): 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것

### 유니언 타입

- 변수의 초깃값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 유니언 타입을 사용합니다.

    ```tsx
    let thinker: string | null = null; // 초깃값은 null이지만,
    
    if(Math.random() > 0.5) {
    	thinker = "Susanne Langer"; // null 대신 string이 될 수 있음
    }
    ```

- 유니언 타입 선언의 순서는 중요하지 않습니다. 타입스크립트에서는 `boolean | number`나 `number | boolean` 모두 똑같이 취급합니다.
- 유니언 타입일 때 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있습니다. 이건 일종의 안전 조치에 해당합니다.

    ```tsx
    let physicist = Math.random() > 0.5 ? "Marie Curie" : 84;
    
    physicist.toString();
    physicist.toUpperCase(); // physicist.toUpperCase is not a function 
    physicist.toFixed(); // physicist.toUpperCase is not a function
    ```


### 내로잉

- 유니언 타입에서 하나의 타입으로 된 값의 속성을 사용하려면 구체적인 타입(specific type)을 선언해줘야 하는데, 이때 사용하는 것이 **내로잉**입니다.
- 변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 **값 할당 내로잉**이 작동합니다. 타입스크립트는 유니언 타입 중 하나의 값을 받을 수 있지만,초깃값의 타입으로 시작합니다.

    ```tsx
    let admiral: number | string;
    
    admiral = "Grace Hopper";
    
    admiral.toUpperCase(); // Ok: string
    admiral.toFixed(); // admiral.toFixed is not a function
    ```

- 단, 일반적으로 if문을 통한 내로잉을 주로 사용합니다.

    ```tsx
    let scientist = Math.random() > 0.5 ? "Rosalind Franklin" : 51;
    
    if (scientist === "Rosalind Franklin") {
      scientist.toUpperCase(); // OK
    }
    
    scientist.toUpperCase(); // [ERR]: scientist.toUpperCase is not a function
    ```

- `typeof` 검사를 통한 내로잉도 가능합니다. `typeof` 검사는 타입을 좁히기 위해 **자주 사용하는 실용적인 방법**입니다.

    ```tsx
    let researcher = Math.random() > 0.5 ? "Rosalind Franklin" : 51;
    
    if(typeof researcher === 'string') {
      researcher.toUpperCase(); // Ok: string
    }
    ```


### 리터럴 타입

- 리터럴 타입은 좀 더 구체적인 버전의 원시타입입니다. 원시 타입 값 중 어떤 것이 아닌 **특정 원싯값**으로 알려진 타입이 리터럴 타입입니다.

## 참고자료

- 러닝 타입스크립트(조시 골드버그, 2023)