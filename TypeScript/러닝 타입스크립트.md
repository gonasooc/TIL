# PART 1. 개념

## CHAPTER 1. 자바스크립트에서 타입스크립트로

### 자바스크립트의 역사

- 1995년 넷스케이프의 브렌던 아이크는 웹사이트에 쉽게 접근하고 사용 가능한 자바스크립트를 10일 만에 설계했습니다. 별난 특성과 결점 덕분에 조롱 받기도 했지만 그 이후 브라우저, 임베디드 애플리케이션, 서버 런타임 환경 등 엄청나게 발전했습니다.

### 바닐라 자바스크립트의 함정

- 순수한 자바스크립트 자체를 바닐라라고 부릅니다.
- 값 비싼 자유 - 코드 구성의 제한이 없고 이런 자유 덕분에 초기엔 재밌지만, 규모가 커질 수록 그 자유가 얼마나 훼손될 수 있는지 명확해집니다.
- 다른 언어는 컴파일러가 충돌할 수 있다 판단되면 코드 실행을 거부할 수 있지만, 충돌 가능성을 먼저 확인하지 않고 코드를 실행하는 동적 타입(Dynamic type) 언어인 자바스크립트는 그렇지 않습니다.
- 부족한 문서 - 블록 주석으로 함수와 변수를 설명하는 JSDoc 표준을 채택했지만, 규모가 있는 코드베이스에서 사용하기 불편합니다.
  - JSDoc 설명이 코드가 잘못되는 것을 막을 수 없고, 이전에는 정확했더라도 코드 리팩토링 중에 생긴 변경 사항과 관련된 현재 유효하지 않은 JSDoc 주석을 모두 찾기는 어려우며, 복잡한 객체를 설명할 때는 다루기 어렵고 장황해서 타입과 그 관계를 정의하려면 다수의 독립형 주석이 필요합니다.

### 타입스크립트

- 타입스크립트는 2010년대 초 마이크로소프트 내부에서 만들어진 후 2012년 출시 및 오픈 소스화되었습니다.
  - 프로그래밍 언어, 타입 검사기, 컴파일러, 언어 서비스
- 타입스크립트는 매개변수와 변수에 제공되는 값의 타입을 지정 가능하고, 명시적으로 작성해야 합니다.
- 잘못된 인수를 사용해서 함수를 호출하는 건 타입스크립트가 제한하는 자바스크립트가 가진 근시안적인 자유입니다.

    ```tsx
    function sayMyName(fullName) {
    	console.log(`You acting kind of shady, ain't callin' me ${fullName}`)
    }
    
    sayMyName("Beyonce", "Knowles");
    ```


## CHAPTER 2. 타입 시스템

### 타입의 종류

- ‘타입’은 자바스크립트에서 다루는 값의 형태, 즉 `typeof` 연산자가 설명하는 것, 그것을 의미합니다.
- 자바스크립트의 일곱 가지 기본 원시 타입(primitive type)이 타입스크립트의 기본적인 타입입니다.
  - `null`
  - `undefined`
  - `boolean` // ture 혹은 false
  - `string` // “”, “Hi!”, “abc123”, …
  - `number` // 0, 2.1, -4, …
  - `bigint` // 0n, 2n, -4n, …
  - `symbol` // Symbol(), Symbol(”hi”), …
- 타입스크립트의 순서

    ```tsx
    let firstName = "Whitney";
    firstName.length();
    
    // This expression is not callable.
    // Type 'Number' has no call signatures.
    ```

  - 코드를 읽고 `firstName`이라는 변수를 이해 → 초깃값이 “Whitney”이므로 `firstName`이 `string`이라고 결론 지음 → `firstName`의 .length 멤버를 함수처럼 호출하는 코드 확인 → `string`의 .length 멤버는 함수가 아닌 숫자라는 오류를 표시, 즉 함수처럼 호출할 수 없음
- 오류 종류
  - 구문 오류: 타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
  - 타입 오류: 타입 검사기에 따라 일치하지 않는 것이 감지된 경우

### 할당 가능성

- 변수의 초깃값을 기준으로 새롭게 할당된 값읠 타입이 변수의 타입과 동일하지 확인합니다. 타입 스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 **할당 가능성(assignability)**이라고 합니다. 즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인합니다.
- ‘Type…is not assignable to type…’

    ```tsx
    let firstName: string = 'Choi';
    firstName = 123;
    
    // Type 'number' is not assignable to type 'string'.
    ```

  - 첫 번째 type은 할당하려 시도한 값, 두 번째 type은 이미 할당된 값

### 타입 에너테이션

- 변수에 초깃값이 없는 경우, 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않고, 기본적으로 변수의 암묵적인 `any` 타입으로 간주합니다. 초기 타입을 유추할 수 없는 변수는 **진화하는 any**라고 부릅니다. 특정 타입을 강제하는 대신 새로운 값이 할당될 때마다 변수 타입에 대한 이해를 발전(진화)시킵니다.
- 일반적으로 `any` 타입으로 진화하는 것을 허용하게 되면 타입 검사 목적을 부분적으로 쓸모없게 만듭니다. (단, 해당 타입에 걸맞는 내장 함수 등은 체크 가능)
- 타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 **타입 에너테이션(type annotation)**을 제공합니다.

    ```tsx
    let rocker: string;
    rocker = "Joan Jett";
    ```

- 자바스크립트로 컴파일하면 해당 타입 애너테이션 코드는 삭제되고, 런타임 코드에도 영향을 주지 않습니다.

### 타입 형태

- 타입스크립트는 해당 자료형의 내장 함수의 존재 유무를 체크하거나, 해당 객체의 key값의 존재 유무를 체크하는 등 원래 타입과 일치하는지 확인하는 것 이상을 수행합니다.
- 스크립트 파일과는 다른 ECMA스크립트 모듈 파일의 선언 스코프

## CHAPTER 3. 유니언과 리터럴

- 타입스크립트가 해당 값을 바탕으로 추론을 수행하는 두 가지 핵심 개념
  - 유니언(union): 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것
  - 내로잉(narrowing): 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것

### 유니언 타입

- 변수의 초깃값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 유니언 타입을 사용합니다.

    ```tsx
    let thinker: string | null = null; // 초깃값은 null이지만,
    
    if(Math.random() > 0.5) {
    	thinker = "Susanne Langer"; // null 대신 string이 될 수 있음
    }
    ```

- 유니언 타입 선언의 순서는 중요하지 않습니다. 타입스크립트에서는 `boolean | number`나 `number | boolean` 모두 똑같이 취급합니다.
- 유니언 타입일 때 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있습니다. 이건 일종의 안전 조치에 해당합니다.

    ```tsx
    let physicist = Math.random() > 0.5 ? "Marie Curie" : 84;
    
    physicist.toString();
    physicist.toUpperCase(); // physicist.toUpperCase is not a function 
    physicist.toFixed(); // physicist.toUpperCase is not a function
    ```


### 내로잉

- 유니언 타입에서 하나의 타입으로 된 값의 속성을 사용하려면 구체적인 타입(specific type)을 선언해줘야 하는데, 이때 사용하는 것이 **내로잉**입니다.
- 변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 **값 할당 내로잉**이 작동합니다. 타입스크립트는 유니언 타입 중 하나의 값을 받을 수 있지만,초깃값의 타입으로 시작합니다.

    ```tsx
    let admiral: number | string;
    
    admiral = "Grace Hopper";
    
    admiral.toUpperCase(); // Ok: string
    admiral.toFixed(); // admiral.toFixed is not a function
    ```

- 단, 일반적으로 if문을 통한 내로잉을 주로 사용합니다.

    ```tsx
    let scientist = Math.random() > 0.5 ? "Rosalind Franklin" : 51;
    
    if (scientist === "Rosalind Franklin") {
      scientist.toUpperCase(); // OK
    }
    
    scientist.toUpperCase(); // [ERR]: scientist.toUpperCase is not a function
    ```

- `typeof` 검사를 통한 내로잉도 가능합니다. `typeof` 검사는 타입을 좁히기 위해 **자주 사용하는 실용적인 방법**입니다.

    ```tsx
    let researcher = Math.random() > 0.5 ? "Rosalind Franklin" : 51;
    
    if(typeof researcher === 'string') {
      researcher.toUpperCase(); // Ok: string
    }
    ```


### 리터럴 타입

- 리터럴 타입은 좀 더 구체적인 버전의 원시타입입니다. 원시 타입 값 중 어떤 것이 아닌 **특정 원싯값**으로 알려진 타입이 리터럴 타입입니다. 즉, 원시 타입은 해당 타입의 가능한 모든 리터럴 값의 집합이라고 볼 수 있습니다.
- 리터럴 타입을 선언한 값에는 다른 값이나 다른 타입을 할당할 수 없습니다. 단, 리터럴 타입 그 자체는 그 값이 해당하는 원시 타입에는 할당할 수 있습니다.

    ```tsx
    let specificallyAda: "Ada";
    
    specificallyAda = "Ada"; // OK
    specificallyAda = "Byron"; // Type '"Byron"' is not assignable to type '"Ada"'.
    
    let someString = "";
    specificallyAda = someString; // Type 'string' is not assignable to type '"Ada"'
    
    someString = specificallyAda; // Ok
    ```


### 엄격한 null 검사

- 리터럴로 좁혀진 유니언의 힘은 타입스크립트에서 **엄격한 null 검사(strict null checking)**라 부르는 타입 시스템 영역인 ‘잠재적으로 정의되지 않은 `undefined` 값’으로 작업할 때 특히 두드러집니다. `strictNullChecks`는 엄격한 `null` 검사를 활성화할지 여부를 결정합니다. `strictNullChecks`를 활성화하면 코드가 `null` 또는 `undefined` 값으로 인한 오류로부터 안전한지 여부를 쉽게 파악할 수 있습니다.

    ```tsx
    let nameMaybe = Math.random() > 0.5 ? "Tony Hoare" : undefined;
    
    nameMaybe.toLowerCase(); // nameMaybe' is possibly 'undefined'.
    ```

- 참 검사를 통한 내로잉도 가능합니다. 자바스크립트에서 `false`, `0`, `-0`, `0n`, `“”`, `null`, `undefined`, `NaN`처럼 **falsy**로 정의된 값을 제외한 모든 값은 모두 참입니다. 잠재적인 값 중 **truthy**로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있습니다.

    ```tsx
    let geneticist = Math.random() > 0.5 ? "Barbara McClintock" : undefined;
    
    if(geneticist) {
      geneticist.toUpperCase();
    }
    
    geneticist.toUpperCase(); // 'geneticist' is possibly 'undefined'.
    ```


### 타입 별칭

- 타입스크립트에는 재사용하는 타입에 더 쉬운 이름을 할당하는 **타입 별칭(type alias)**이 있습니다. 타입 별칭은 파스칼 케이스(PascalCase)로 지정합니다.

    ```tsx
    type RawData = boolean | number | string | null | undefined;
    
    let rawDataFirst: RawData;
    let rawDataSecond: RawData;
    let rawDataThird: RawData;
    ```

- 타입 애너테이션과 마찬가지로 자바스크립트로 컴파일되진 않습니다. 런타임에 존재하지 않는 항목이기 때문에 접근하려 하면 타입 오류가 나옵니다. 타입 별칭은 순전히 ‘개발 시’에만 존재합니다.

    ```tsx
    type SomeType = string | undefined;
    console.log(SomeType); // 'SomeType' only refers to a type, but is being used as a value here.
    ```

- 타입 별칭은 다른 타입 별칭을 참조해서 작성할 수 있습니다.

## CHAPTER 4. 객체

### 객체 타입

- 객체 타입 선언 - 객체의 타입을 명시적으로 선언하고 싶을 때 아래와 같이 선언할 수 있습니다.

    ```tsx
    let poetLater: {
        born: number;
        name: string;
    }
    
    poetLater = {
        born: 1935,
        name: 'Mary Oliver',
    }
    
    poetLater = "Sappho"; // Type 'string' is not assignable to type '{ born: number; name: string; }'.
    ```

- 단, 저런 형식으로 매번 객체 타입을 작성하는 것은 번거로운 일입니다. 그래서 타입 별칭을 사용하는 것이 좀 더 일반적입니다.

    ```tsx
    type Poet = {
        born: number;
        name: string;
    }
    
    let poetLater: Poet;
    
    poetLater = {
        born: 1935,
        name: "Sara Teasdale",
    }
    
    poetLater = "Emily Dickinson"; // Type 'string' is not assignable to type 'Poet'.
    ```

  - 대부분의 타입스크립트 프로젝트는 객체 타입을 설명할 때 인터페이스(interface) 키워드 사용을 선호합니다. 별칭 객체 타입과 거의 동일합니다.

### 구조적 타이핑

- 자바스크립트는 **덕 타입(duck typed)**인 반면, 타입스크립트는 **구조적으로 타입화**됩니다.
- 사용 검사
  - 할당하는 값에는 객체 타입의 필수 속성이 있어야 합니다. 객체 타입에 필요한 멤버가 없다면 타입 오류가 발생합니다.

      ```tsx
      type FirstAndLastNames = {
          first: string;
          last: string;
      }
      
      // Ok
      const hasBoth: FirstAndLastNames = {
          first: 'Sarojini',
          last: 'Naidu',
      }
      
      // Property 'last' is missing in type '{ first: string; }'
      // but required in type 'FirstAndLastNames'.
      const hasOnlyOne: FirstAndLastNames = {
          first: "Sappho"
      }
      ```

  - 또한 당연히 지정된 객체의 속성과 일치하지 않으면 타입 오류를 발생시킵니다.
- 초과 속성 검사
  - 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있으면 타입 오류가 발생합니다.
  -

## 참고자료

- 러닝 타입스크립트(조시 골드버그, 2023)