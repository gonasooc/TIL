# PART 1. 개념

## CHAPTER 1. 자바스크립트에서 타입스크립트로

### 자바스크립트의 역사

- 1995년 넷스케이프의 브렌던 아이크는 웹사이트에 쉽게 접근하고 사용 가능한 자바스크립트를 10일 만에 설계했습니다. 별난 특성과 결점 덕분에 조롱 받기도 했지만 그 이후 브라우저, 임베디드 애플리케이션, 서버 런타임 환경 등 엄청나게 발전했습니다.

### 바닐라 자바스크립트의 함정

- 순수한 자바스크립트 자체를 바닐라라고 부릅니다.
- 값 비싼 자유 - 코드 구성의 제한이 없고 이런 자유 덕분에 초기엔 재밌지만, 규모가 커질 수록 그 자유가 얼마나 훼손될 수 있는지 명확해집니다.
- 다른 언어는 컴파일러가 충돌할 수 있다 판단되면 코드 실행을 거부할 수 있지만, 충돌 가능성을 먼저 확인하지 않고 코드를 실행하는 동적 타입(Dynamic type) 언어인 자바스크립트는 그렇지 않습니다.
- 부족한 문서 - 블록 주석으로 함수와 변수를 설명하는 JSDoc 표준을 채택했지만, 규모가 있는 코드베이스에서 사용하기 불편합니다.
  - JSDoc 설명이 코드가 잘못되는 것을 막을 수 없고, 이전에는 정확했더라도 코드 리팩토링 중에 생긴 변경 사항과 관련된 현재 유효하지 않은 JSDoc 주석을 모두 찾기는 어려우며, 복잡한 객체를 설명할 때는 다루기 어렵고 장황해서 타입과 그 관계를 정의하려면 다수의 독립형 주석이 필요합니다.

### 타입스크립트

- 타입스크립트는 2010년대 초 마이크로소프트 내부에서 만들어진 후 2012년 출시 및 오픈 소스화되었습니다.
  - 프로그래밍 언어, 타입 검사기, 컴파일러, 언어 서비스
- 타입스크립트는 매개변수와 변수에 제공되는 값의 타입을 지정 가능하고, 명시적으로 작성해야 합니다.
- 잘못된 인수를 사용해서 함수를 호출하는 건 타입스크립트가 제한하는 자바스크립트가 가진 근시안적인 자유입니다.

    ```tsx
    function sayMyName(fullName) {
    	console.log(`You acting kind of shady, ain't callin' me ${fullName}`)
    }
    
    sayMyName("Beyonce", "Knowles");
    ```


## CHAPTER 2. 타입 시스템

### 타입의 종류

- ‘타입’은 자바스크립트에서 다루는 값의 형태, 즉 `typeof` 연산자가 설명하는 것, 그것을 의미합니다.
- 자바스크립트의 일곱 가지 기본 원시 타입(primitive type)이 타입스크립트의 기본적인 타입입니다.
  - `null`
  - `undefined`
  - `boolean` // ture 혹은 false
  - `string` // “”, “Hi!”, “abc123”, …
  - `number` // 0, 2.1, -4, …
  - `bigint` // 0n, 2n, -4n, …
  - `symbol` // Symbol(), Symbol(”hi”), …
- 타입스크립트의 순서

    ```tsx
    let firstName = "Whitney";
    firstName.length();
    
    // This expression is not callable.
    // Type 'Number' has no call signatures.
    ```

  - 코드를 읽고 `firstName`이라는 변수를 이해 → 초깃값이 “Whitney”이므로 `firstName`이 `string`이라고 결론 지음 → `firstName`의 .length 멤버를 함수처럼 호출하는 코드 확인 → `string`의 .length 멤버는 함수가 아닌 숫자라는 오류를 표시, 즉 함수처럼 호출할 수 없음
- 오류 종류
  - 구문 오류: 타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
  - 타입 오류: 타입 검사기에 따라 일치하지 않는 것이 감지된 경우

### 할당 가능성

- 변수의 초깃값을 기준으로 새롭게 할당된 값읠 타입이 변수의 타입과 동일하지 확인합니다. 타입 스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 **할당 가능성(assignability)**이라고 합니다. 즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인합니다.
- ‘Type…is not assignable to type…’

    ```tsx
    let firstName: string = 'Choi';
    firstName = 123;
    
    // Type 'number' is not assignable to type 'string'.
    ```

  - 첫 번째 type은 할당하려 시도한 값, 두 번째 type은 이미 할당된 값

### 타입 에너테이션

- 변수에 초깃값이 없는 경우, 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않고, 기본적으로 변수의 암묵적인 `any` 타입으로 간주합니다. 초기 타입을 유추할 수 없는 변수는 **진화하는 any**라고 부릅니다. 특정 타입을 강제하는 대신 새로운 값이 할당될 때마다 변수 타입에 대한 이해를 발전(진화)시킵니다.
- 일반적으로 `any` 타입으로 진화하는 것을 허용하게 되면 타입 검사 목적을 부분적으로 쓸모없게 만듭니다. (단, 해당 타입에 걸맞는 내장 함수 등은 체크 가능)
- 타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 **타입 에너테이션(type annotation)**을 제공합니다.

    ```tsx
    let rocker: string;
    rocker = "Joan Jett";
    ```

- 자바스크립트로 컴파일하면 해당 타입 애너테이션 코드는 삭제되고, 런타임 코드에도 영향을 주지 않습니다.

### 타입 형태

- 타입스크립트는 해당 자료형의 내장 함수의 존재 유무를 체크하거나, 해당 객체의 key값의 존재 유무를 체크하는 등 원래 타입과 일치하는지 확인하는 것 이상을 수행합니다.
- 스크립트 파일과는 다른 ECMA스크립트 모듈 파일의 선언 스코프

## CHAPTER 3. 유니언과 리터럴

- 타입스크립트가 해당 값을 바탕으로 추론을 수행하는 두 가지 핵심 개념
  - 유니언(union): 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것
  - 내로잉(narrowing): 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것

### 유니언 타입

- 변수의 초깃값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 유니언 타입을 사용합니다.

    ```tsx
    let thinker: string | null = null; // 초깃값은 null이지만,
    
    if(Math.random() > 0.5) {
    	thinker = "Susanne Langer"; // null 대신 string이 될 수 있음
    }
    ```

- 유니언 타입 선언의 순서는 중요하지 않습니다. 타입스크립트에서는 `boolean | number`나 `number | boolean` 모두 똑같이 취급합니다.
- 유니언 타입일 때 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있습니다. 이건 일종의 안전 조치에 해당합니다.

    ```tsx
    let physicist = Math.random() > 0.5 ? "Marie Curie" : 84;
    
    physicist.toString();
    physicist.toUpperCase(); // physicist.toUpperCase is not a function 
    physicist.toFixed(); // physicist.toUpperCase is not a function
    ```


### 내로잉

- 유니언 타입에서 하나의 타입으로 된 값의 속성을 사용하려면 구체적인 타입(specific type)을 선언해줘야 하는데, 이때 사용하는 것이 **내로잉**입니다.
- 변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 **값 할당 내로잉**이 작동합니다. 타입스크립트는 유니언 타입 중 하나의 값을 받을 수 있지만,초깃값의 타입으로 시작합니다.

    ```tsx
    let admiral: number | string;
    
    admiral = "Grace Hopper";
    
    admiral.toUpperCase(); // Ok: string
    admiral.toFixed(); // admiral.toFixed is not a function
    ```

- 단, 일반적으로 if문을 통한 내로잉을 주로 사용합니다.

    ```tsx
    let scientist = Math.random() > 0.5 ? "Rosalind Franklin" : 51;
    
    if (scientist === "Rosalind Franklin") {
      scientist.toUpperCase(); // OK
    }
    
    scientist.toUpperCase(); // [ERR]: scientist.toUpperCase is not a function
    ```

- `typeof` 검사를 통한 내로잉도 가능합니다. `typeof` 검사는 타입을 좁히기 위해 **자주 사용하는 실용적인 방법**입니다.

    ```tsx
    let researcher = Math.random() > 0.5 ? "Rosalind Franklin" : 51;
    
    if(typeof researcher === 'string') {
      researcher.toUpperCase(); // Ok: string
    }
    ```


### 리터럴 타입

- 리터럴 타입은 좀 더 구체적인 버전의 원시타입입니다. 원시 타입 값 중 어떤 것이 아닌 **특정 원싯값**으로 알려진 타입이 리터럴 타입입니다. 즉, 원시 타입은 해당 타입의 가능한 모든 리터럴 값의 집합이라고 볼 수 있습니다.
- 리터럴 타입을 선언한 값에는 다른 값이나 다른 타입을 할당할 수 없습니다. 단, 리터럴 타입 그 자체는 그 값이 해당하는 원시 타입에는 할당할 수 있습니다.

    ```tsx
    let specificallyAda: "Ada";
    
    specificallyAda = "Ada"; // OK
    specificallyAda = "Byron"; // Type '"Byron"' is not assignable to type '"Ada"'.
    
    let someString = "";
    specificallyAda = someString; // Type 'string' is not assignable to type '"Ada"'
    
    someString = specificallyAda; // Ok
    ```


### 엄격한 null 검사

- 리터럴로 좁혀진 유니언의 힘은 타입스크립트에서 **엄격한 null 검사(strict null checking)**라 부르는 타입 시스템 영역인 ‘잠재적으로 정의되지 않은 `undefined` 값’으로 작업할 때 특히 두드러집니다. `strictNullChecks`는 엄격한 `null` 검사를 활성화할지 여부를 결정합니다. `strictNullChecks`를 활성화하면 코드가 `null` 또는 `undefined` 값으로 인한 오류로부터 안전한지 여부를 쉽게 파악할 수 있습니다.

    ```tsx
    let nameMaybe = Math.random() > 0.5 ? "Tony Hoare" : undefined;
    
    nameMaybe.toLowerCase(); // nameMaybe' is possibly 'undefined'.
    ```

- 참 검사를 통한 내로잉도 가능합니다. 자바스크립트에서 `false`, `0`, `-0`, `0n`, `“”`, `null`, `undefined`, `NaN`처럼 **falsy**로 정의된 값을 제외한 모든 값은 모두 참입니다. 잠재적인 값 중 **truthy**로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있습니다.

    ```tsx
    let geneticist = Math.random() > 0.5 ? "Barbara McClintock" : undefined;
    
    if(geneticist) {
      geneticist.toUpperCase();
    }
    
    geneticist.toUpperCase(); // 'geneticist' is possibly 'undefined'.
    ```


### 타입 별칭

- 타입스크립트에는 재사용하는 타입에 더 쉬운 이름을 할당하는 **타입 별칭(type alias)**이 있습니다. 타입 별칭은 파스칼 케이스(PascalCase)로 지정합니다.

    ```tsx
    type RawData = boolean | number | string | null | undefined;
    
    let rawDataFirst: RawData;
    let rawDataSecond: RawData;
    let rawDataThird: RawData;
    ```

- 타입 애너테이션과 마찬가지로 자바스크립트로 컴파일되진 않습니다. 런타임에 존재하지 않는 항목이기 때문에 접근하려 하면 타입 오류가 나옵니다. 타입 별칭은 순전히 ‘개발 시’에만 존재합니다.

    ```tsx
    type SomeType = string | undefined;
    console.log(SomeType); // 'SomeType' only refers to a type, but is being used as a value here.
    ```

- 타입 별칭은 다른 타입 별칭을 참조해서 작성할 수 있습니다.

## CHAPTER 4. 객체

### 객체 타입

- 객체 타입 선언 - 객체의 타입을 명시적으로 선언하고 싶을 때 아래와 같이 선언할 수 있습니다.

    ```tsx
    let poetLater: {
        born: number;
        name: string;
    }
    
    poetLater = {
        born: 1935,
        name: 'Mary Oliver',
    }
    
    poetLater = "Sappho"; // Type 'string' is not assignable to type '{ born: number; name: string; }'.
    ```

- 단, 저런 형식으로 매번 객체 타입을 작성하는 것은 번거로운 일입니다. 그래서 타입 별칭을 사용하는 것이 좀 더 일반적입니다.

    ```tsx
    type Poet = {
        born: number;
        name: string;
    }
    
    let poetLater: Poet;
    
    poetLater = {
        born: 1935,
        name: "Sara Teasdale",
    }
    
    poetLater = "Emily Dickinson"; // Type 'string' is not assignable to type 'Poet'.
    ```

  - 대부분의 타입스크립트 프로젝트는 객체 타입을 설명할 때 인터페이스(interface) 키워드 사용을 선호합니다. 별칭 객체 타입과 거의 동일합니다.

### 구조적 타이핑

- 자바스크립트는 **덕 타입(duck typed)**인 반면, 타입스크립트는 **구조적으로 타입화**됩니다.
- 사용 검사
  - 할당하는 값에는 객체 타입의 필수 속성이 있어야 합니다. 객체 타입에 필요한 멤버가 없다면 타입 오류가 발생합니다.

      ```tsx
      type FirstAndLastNames = {
          first: string;
          last: string;
      }
      
      // Ok
      const hasBoth: FirstAndLastNames = {
          first: 'Sarojini',
          last: 'Naidu',
      }
      
      // Property 'last' is missing in type '{ first: string; }'
      // but required in type 'FirstAndLastNames'.
      const hasOnlyOne: FirstAndLastNames = {
          first: "Sappho"
      }
      ```

  - 또한 당연히 지정된 객체의 속성과 일치하지 않으면 타입 오류를 발생시킵니다.
- 초과 속성 검사
  - 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있으면 타입 오류가 발생합니다.
  - 초과 속성 검사는 **객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만** 일어납니다. 기존 객체 리티럴을 제공하면 초과 속성 검사를 우회합니다.

      ```tsx
      type Poet = {
          born: number;
          name: string;
      }
      
      const existingObject = {
          activity: "walking",
          born: 1935,
          name: "Mary Oliver",
      }
      
      const extraPropertyButOk: Poet = existingObject;
      ```

  - 중첩된 객체 타입 - 중첩된 타입을 자체 타입 별칭으로 추출하면 타입스크립트의 타입 오류 메시지에 더 많은 정보를 담을 수 있습니다.
  - 선택적 속성 - 타입의 속성 애너테이션에서 : 앞에 `?`를 추가하면 선택적 속성임을 나타낼 수 있습니다. **유니언 타입은 둘 중에 어느 하나의 타입은 반드시 있어야 하지만 선택적 속성은 해당 속성이 존재하지 않아도 됩니다.**

      ```tsx
      type Book = {
          author?: string;
          pages: number;
      }
      
      const ok: Book = {
          author: "Rita Dove",
          pages: 80,
      }
      
      const missing: Book = {
          pages: 100,
      }
      ```


### 객체 타입 유니언

- 유추된 객체 타입 유니언 - 변수에 여러 객체 타입 중 하나가 될 수 있는 초깃값이 주어지면 타입스크립트는 해당 타입을 객체 타입 유니언으로 유추합니다.

    ```tsx
    const poem = Math.random() > 0.5
        ? { name: "The Double Image", pages: 7 }
        : { name: "Her Kind", rhymes: true };
    // 타입:
    // {
    //     name: string;
    //     pages: number;
    //     rhymes?: undefined;
    // }
    // |
    // {
    //     name: string;
    //     pages?: undefined;
    //     rhymes: boolean;
    // }
    ```

- 명시된 객체 타입 유니언 - 명시적으로 선언을 해두면 모든 유니언 타입에 존재하는 속성에 대한 접근만 허용합니다. 잠재적으로 존재하지 않는 객체의 멤버에 대한 접근을 제한할 수 있기 때문에 객체 타입 유니언도 타입을 좁혀서 좀 더 안전하게 작성할 수 있습니다.

    ```tsx
    type PoemWithPages = {
        name: string;
        pages: number;
    }
    
    type PoemWithRhymes = {
        name: string;
        rhymes: boolean;
    }
    
    type Poem = PoemWithPages | PoemWithRhymes;
    
    const poem: Poem = Math.random() > 0.5
        ? { name: "The Double Image", pages: 7 }
        : { name: "Her Kind", rhymes: true };
    
    poem.name;
    
    poem.pages;
    // Property 'pages' does not exist on type 'Poem'.
    //   Property 'pages' does not exist on type 'PoemWithRhymes'.
    ```

- 객체 타입 내로잉 - 타입 내로잉을 통해서 해당 타입의 범위를 명시적으로 좁힐 수 있습니다.

    ```tsx
    type PoemWithPages = {
        name: string;
        pages: number;
    }
    
    type PoemWithRhymes = {
        name: string;
        rhymes: boolean;
    }
    
    type Poem = PoemWithPages | PoemWithRhymes;
    
    const poem: Poem = Math.random() > 0.5
        ? { name: "The Double Image", pages: 7 }
        : { name: "Her Kind", rhymes: true };
    
    poem.name;
    
    if("pages" in poem) {
        poem.pages;
    }
    ```

- 판별된 유니언(discriminated union) - 각각의 타입에 타입을 가리키는 속성, 즉 판별값을 부여하고, 타입 내로잉을 수행할 수 있습니다.

    ```tsx
    interface Bird {
      type: "bird";
      flyingSpeed: number;
    }
    
    interface Horse {
      type: "horse";
      runningSpeed: number;
    }
    
    type Animal = Bird | Horse;
    
    function getAnimalSpped(animal: Animal) {
      let speed: number = 0;
      switch (animal.type) {
        case "bird":
          speed = animal.flyingSpeed;
          break;
        case "horse":
          speed = animal.runningSpeed;
          break;
      }
      console.log(`${animal.type} is moving with speed ${speed}km`);
    }
    
    getAnimalSpped({
      type: "bird",
      flyingSpeed: 10,
    });
    ```


### 교차 타입

- 자바스크립트의 런타임 `|` 연산자가 `&` 연산자에 대응하는 역할을 하는 것처럼, 타입스크립트에서도 `&` 교체 타입(intersection type)을 사용해 여러 타입을 동시에 나타냅니다.

    ```tsx
    type Artwork = {
        genre: string;
        name: string;
    };
    
    type Writing = {
        pages: number;
        name: string;
    }
    
    type WrittenArt = Artwork & Writing;
    
    // 다음과 같음
    // {
    //     genre: string;
    //     name: string;
    //     pages: number;
    // }
    ```

- 교차 타입의 위험성 - 유용한 개념이지만, 혼동될 수 있기 때문에 가능한 코드를 간결하게 유지해야 합니다.
  - 긴 할당 가능성 오류 - 복잡한 교차 타입을 만들게 되면 할당 가능성 오류 메시지는 읽기 어려워집니다.
  - `never` - 원시 타입의 값은 동시에 여러 타입이 될 수 없기 때문에 교차 타입의 구성 요소로 함께 결합할 수 없습니다. 두 개의 원시 타입을 함께 시도하면 `never` 키워드로 표시되는 `never` 타입이 됩니다.

      ```tsx
      type NotPossible = number & string; // 타입: never
      ```

    - `never` 키워드와 `never` 타입은 프로그래밍 언어에서 bottom 타입 또는 empty 타입을 뜻합니다. bottom 타입은 값을 가질 수 없고 참조할 수 없는 타입이므로 bottom 타입에 그 어떠한 타입도 제공할 수 없습니다.

## CHAPTER 5. 함수

### 함수 매개변수

- 필수 매개변수 - 자바스크립트에서는 인수의 수와 상관없이 함수를 호출할 수 있습니다. 잘못된 수의 인수로 호출되면 오류 가능성이 있기 때문에 이의를 제기합니다. 필수 매개변수를 제공하고 강제하면 타입 안정성을 강화하는 데 도움이 됩니다.

    ```tsx
    function singTwo(first: string, second: string) {
        console.log(`${first} / ${second}`);
    }
    
    singTwo("Ball and Chain"); // Expected 2 arguments, but got 1.
    singTwo("Ball and Chain", "Higher Love");
    singTwo("Ball and Chain", "Higher Love", "Dreams"); // Expected 2 arguments, but got 3.
    ```

- 선택적 매개변수 - 자바스크립트에서 함수의 매개변수가 제공되지 않으면 함수 내부의 인숫값은 `undefined`가 기본값으로 설정됩니다. 물론 `undefined` 값을 위해 의도적으로 사용할 수도 있습니다. 타입 애너테이션 `:` 앞에 `?`를 추가하면 매개변수가 선택적이라는 것으로 지정할 수 있습니다. 유니언 타입 매개변수와는 다릅니다. 유니언 매개변수는 `undefined`일지라도 명시적으로 항상 제공되어야 합니다.

    ```tsx
    function announceSongBy(song: string, singer: string | undefined) {
        console.log('test');
    }
    
    announceSongBy('Greensleeves'); // Expected 2 arguments, but got 1.
    announceSongBy('Greensleeves', undefined);
    announceSongBy('Greensleeves', 'Sia');
    ```

- 기본 매개변수 - 자바스크립트에서 매개변수 선언 시 `=`와 같이 기본값을 포함할 수 있습니다. 선택적 매개변수에는 기본적으로 값이 제공되기 때문에 해당 타입스크립트 타입에는 암묵적으로 함수 내부에 `| undefined` 유니언 타이 추가됩니다. 타입 스크립트의 타입 추론은 초기 변숫값과 마찬가지로 기본 함수 매개변수에 대해서도 유사하게 작동합니다. 매개변수에 기본값이 있고 타입 애너테이션이 없는 경우, 해당 기본값을 기반으로 타입을 유추합니다.

    ```tsx
    function rateSong(song: string, rating = 0) {
        console.log(`${song} gets ${rating}/5 stars!`);
    }
    
    rateSong("Photograph");
    rateSong("Set Fire to tje Rain", 5);
    rateSong("Set Fire to tje Rain", undefined);
    
    rateSong("At Last!", "100");
    // Argument of type 'string' is not assignable to parameter of type 'number'.
    ```

- 나머지 매개변수 - 자바스크립트의 일부 함수는 임의의 수의 인수로 호출할 수 있도록 만들어집니다. …스프레드 연산자는 함수 선언의 마지막 매개변수에 위치하고, 해당 매개변수에서 시작해 함수의 전달된 ‘나머지(rest)’ 인수가 모두 단일 배열에 저장되어야 함을 나타냅니다. 타입스크립트에서 애너테이션 끝에 [] 구문이 추가되어 표기합니다.

    ```tsx
    function singAllTheSongs(singer: string, ...songs: string[]) {
        for(const song of songs) {
            console.log(`${song}, by ${singer}`);
        }
    }
    
    singAllTheSongs("Alicia Keys");
    singAllTheSongs("Lady Gaga", "Bad Romance", "Just Dance", "Poker Face");
    
    singAllTheSongs("Ella Fitzgerald", 2000);
    // Argument of type 'number' is not assignable to parameter of type 'string'.
    ```


### 반환 타입

## 참고자료

- 러닝 타입스크립트(조시 골드버그, 2023)
- [https://velog.io/@hoplin/TypeScript-고급타입-구별된-유니온Discriminated-Union](https://velog.io/@hoplin/TypeScript-%EA%B3%A0%EA%B8%89%ED%83%80%EC%9E%85-%EA%B5%AC%EB%B3%84%EB%90%9C-%EC%9C%A0%EB%8B%88%EC%98%A8Discriminated-Union)