# 1강. 운영체제 소개

## 운영체제란 무엇인가

### 컴퓨터 시스템의 구성

- 운영체제 - 대표적인 시스템 소프트웨어, 컴퓨터 시스템 자원을 관리하고 프로그램 동작을 위한 서비스를 제공하는 프로그램들의 모음

### 운영체제의 역할

- 컴퓨터 시스템의 자원 관리 - 컴퓨터 시스템을 효율적으로 운영하는 목적
- 사용자 지원 - GUI 등 사용자 편의성 제공

### 컴퓨터 시스템과 운영체제

- 운영체제가 없던 초기의 컴퓨터 시스템
  - 응용 프로그램에서 직접 시스템의 자원 제어 → 즉, 개발자가 로우 레벨에서 개발해야 하기 때문에 하드웨어 제어 방법을 잘 알아야 함 ex) 몇 번 포트에 빛을 쏴준다거나
  - 여러 사용자가 하드웨어를 공유하는 경우 자원 분할 어려움
- 운영체제가 있는 컴퓨터 시스템
  - 하드웨어와 응용 프로그램 사이에 운영체제 위치
  - 여러 사용자의 자원 분배 및 제어 가능 → 안정적으로 효율적으로 동작 가능

### 커널 모드와 사용자 모드

- 커널 모드(슈퍼바이저 모드) - 하드웨어 직접 제어
- 사용자 모드 - 하드웨어 직접 제어 불가능
- 일체형 커널(monolithic kernel) - 운영체제의 모든 서비스가 커널 내에 포함
  - 커널 내부 요소들이 효율적 상호작용
  - 하나라도 오류가 발생하면 전체 장애 발생
  - ex) UNIX, Linux
- 마이크로커널(mircokernel) - 운영체제 요소 대부분을 커널 외부에 분리
  - 메모리 관리, 멀티태스킹 등 최소한의 요소만 커널 내 남김
  - 새로운 서비스 추가로 운영체제 확장 쉽고, 유지보수 용이하고 안정성이 우수함
  - 커널 외부 요소들 사이에 IPC(프로세스 통신)가 필요해서 성능 저하 발생
- 일반적으로 사용자 모드를 사용하다가 하드웨어에 대한 제어가 필요한 경우(**시스템 호출**) 커널 모드로 전환 → 제어가 끝나면 다시 사용자 모드로 전환

## 운영체제의 구성

- 컴퓨터 시스템 자원의 성격에 따라 구분
  - 프로세스 관리자, 메모리 관리자, 파일 관리자, 장치 관리자

### 프로세스 관리자

- 메모리에서 실행 중인 프로세스의 생성 및 삭제 등 관리, CPU 할당을 위한 스케줄링

### 메모리 관리자

- 메모리 할당 및 회수, 공간 보호(ex) OS가 사용하는 메모리 공간 보호) 등

### 장치 관리자

- 모든 장치에 대한 관리

### 파일 관리자

- 저장장치의 공간 관리 및 파일의 접근 제한 등 관리

## 운영체제의 유형

### 일괄처리 운영체제

- 작업을 모아서 순서대로 처리하는 방식
- 앞선 작업들을 기다려야 해서 상호작용 없이 기다려야 하는 비효율성 존재

### 시분할 운영체제(time-sharing)

- 대화형(interactive) 운영체제라고도 함
- 응답시간이 일괄처리 운영체제보다 크게 단축됨

### 실시간 운영체제(RTOS)

- 처리 결과가 현재의 결정에 영향을 주는 특수 목적의 환경에서 사용 ex) 미사일 제어 시스템, 증권거래 관리 시스템 등
- 우선순위가 높은 작업을 먼저 처리

### 분산 운영체제

- 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템

# 2강. 프로세스와 쓰레드

## 프로세스

- 프로세스(process): 실행 중인 프로그램 - 시스템 프로세스(백그라운드) / 사용자 프로세스
  - 프로그램: 동작을 하지 않은 정적, 수동적 개체
  - 프로세스: 동작을 하는 능동적 개체
- 운영체제로부터 자원 할당
  - 자원: CPU, 메모리, 입출력장치, 파일 등
  - 동작: CPU가 프로세스의 명령을 실행
- 운영체제는 프로세스를 실행 및 종료하고, 스케줄링하면서 관리
- 메모리 구조 - 코드 영역/데이터 영역
  - 코드 영역은 프로그램 자체
  - 데이터 영역(정적 데이터/스택/힙) - 실행 시 필요한 데이터, 상수나 변수, 서브프로그램 호출 상태 등
- 프로세스 제어 블록(Process Control Block: PCB) - 운영체제가 프로세스 관리를 위해 필요한 정보
  - 프로세스 번호(PID), 프로세스 상태, 프로그램 카운터(PC), 레지스터, 메모리 관리 정보, 프로세스 우선순위, 회계정보
- 프로세스 상태 관리
  - 생성 - 준비 - _대기_ - 실행 - 종료
- 프로세스 상태 변화
  - 생성 → 준비 →(디스패치)←(할당시간 만료) 실행 →(이벤트 대기) 대기 →(재개 조건 만족), 실행 → 종료
- 부모 프로세스와 자식 프로세스
  - 사용자가 직접 실행할 수도 있지만 한 프로세스가 다른 프로세스를 생성할 수 있음 → 프로세스 생성 시스템 호출 이용
  - 부모 프로세스는 그 시스템 호출을 하는 프로세스
  - 자식 프로세스는 시스템 호출을 통해 새로 생성된 프로세스
  - UNIX, Linux
    - fork() - 자식 프로세스는 부모 프로세스의 복제본(PID만 다르게 부여)
    - exec() - 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행(PID 외 데이터는 다 변동)
  - Windows
    - CreateProcess() - 자식 프로세스는 아예 애초에 새로운 프로그램으로 생성
- 프로세스 종료 방법
  - 프로세스가 모든 처리를 완료(정상 종료)
  - 부모 프로세스에 의해 자식 프로세스 강제 종료
    - 종료 시스템 호출 이용
    - 자식 프로세스 생성 시 얻은 자식 PID 이용
  - 부모 프로세스가 종료되면 자식 프로세스 같이 종료

## 쓰레드

- 쓰레드 - 프로세스 내에서 다중 처리를 위해 제안된 개념
- 하나의 프로그램 실행을 위한 기본적인 단위, 디스패칭의 단위
- 쓰레드는 실행에 필요한 최소한의 정보만 가짐
  - PC를 포함한 레지스터 값
  - 상태 정보
  - 스택 영역
  - 그 외 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유
- 다중 쓰레드로 구성된 프로세스
  - 멀티 CPU 또는 멀티코어 컴퓨터 시스템 - 다중 쓰레드로 병렬 처리 가능
  - 처리속도 별로 쓰레드가 나눠진 경우 - 효율적인 처리 가능

# 3강. 프로세스 스케줄링

## 프로세스 스케줄링

### 프로세스 스케줄링

- 주어진 프로세스가 여러 개인 경우 프로세스 처리순서를 결정하는 것

### 하위단계 스케줄링

- 준비 큐에 있는 프로세스를 선택하여 사용 가능한 CPU를 할당(디스패치)하는 역할
- 수행 주체: 디스패처(dispatcher)

### 스케줄링의 목표

- 일괄처리 운영체제 - 처리량의 극대화, 반환시간의 최소화, CPU 활용의 극대화
- 시분할 운영체제 - 빠른 응답시간, 과다한 대기시간 방지
- 실시간 운영체제 - 처리기한 맞춤

### 스케줄링 정책

**선점 스케줄링 정책(preemptive)**

- 실행 중인 프로세스 인터럽트 후 다른 프로세스에 CPU 할당
- 높은 우선순위의 프로세스 처리
- 문맥 교환에 따른 오버헤드
- 운영체제는 문맥 교환에 빠르게 실행되도록 만들어져야 함, 실시간 시스템/시분할 시스템

**문맥(context)**

- CPU의 모든 레지스터와 기타 운영체제에 요구되는 프로세스의 상태

**문맥 교환(context switching)**

- 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업

**비선점 스케줄링 정책(nonpreemptive)**

- 실행 중인 프로세스는 바로 준비상태로 전이 불가
- 대기나 종료 상태에서 전이될 때까지 계속 실행 상태에 있게 됨
- 강제 문맥 교환이 없어서 오버헤드 발생하지 않음
- 긴 프로세스가 실행 중이라면 짧은 프로세스가 오래 기다리게 됨

### 스케줄링의 평가 기준

- 평균대기시간과 평균반환시간

## 스케줄링 알고리즘

**FCFS(First-Come First-Served) 스케줄링**

- 비선점 방식
- 장점 - 가장 간단한 스케줄링
- 단점 - 짧은 프로세스 대기 시간 있음, 중요 프로세스 나중에 수행될 가능성, 프로세스들의 도착 순서에 따라 평균 반환 시간이 크게 변함, 시분할 운영체제나 실시간 운영체제에는 부적합

**SJF(Shortest Job First) 스케줄링**

- 비선점 방식
- 준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧다고 예상되는 거 먼저 디스패치
- 장점 - 일괄 처리 환경에서 구현 쉬움
- 단점 - 준비 큐가 기준이기 때문에 이미 실행 중인 프로세스가 있는 경우 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수 있음, CPU 시간을 예상하기 어려워서 스케줄링을 도입하는 것이 쉽지 않음

**SRT(Shortest Remaining Time) 스케줄링**

- SJF 알고리즘의 선점 방식
- 준비 큐 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 거 먼저 디스패치
- 장점 - SJF보다 평균대기시간, 평균반환시간에서 효율적
- 단점 - 역시 실제로는 프로세스의 CPU 시간을 예상하는 게 어려움(거의 불가능), 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼

**RR(Round Robin) 스케줄링**

- 선점 방식
- 기본적으로는 FCFS와 같지만 정해진 시간 할당량에 의해 실행 제한
- 시간 할당량 안에 종료하지 못한 프로세스는 준비 큐 마지막에 배치됨
- 장점 - CPU 독점 없이 공평, 시분할 운영체제에 적합
- 단점 - 시간 할당량이 너무 크면 FCFS와 다를 바가 없고, 시간 할당량이 너무 작으면 너무 많은 문맥 교환 발생으로 오버헤드가 커짐

**HRN(Highest Response Ratio Next) 스케줄링**

- 비선점 방식
- 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치
- 예상 실행 시간이 짧을수록 + 대기시간이 길수록 응답 비율이 커짐
- 장점 - SJF 스케줄링 단점 보완 - 오래 대기한 경우 응답 비율이 커져 나중에 들어오는 단순히 짧은 프로세스보다 먼저 디스패치 가능
- 단점 - 실제로는 프로세스의 CPU 시간을 예상하기 어려움

**다단계 피드백 큐 스케줄링**

- 선점 방식, Round Robin 확장 느낌
- 시간 할당량이 다 되면 다음 단계로 가면서 다른 시간 할당량 부여
- I/O 위주 프로세스는 높은 우선권 유지, 연산 위주의 프로세스는 낮은 우선권이지만 긴 시간 할당량

# 4강. 병행 프로세스 I

## 병행 프로세스의 개요

- 병행성
  - 여러 개의 프로세스 또는 쓰레드가 동시 수행되는 시스템의 특성
    병행 프로세스의 실행 형태
  - 1개의 CPU - 인터리빙 형식
  - 여러 개의 CPU - 병렬처리 형식
  - 멀티 프로세서 시스템에서의 메모리 구조에 따라 강결합 시스템(공유 메모리 구조)와 역결합 시스템(분산 메모리 구조)로 나눠짐
    **프로세스 간의 관계**
  - 독립 프로세스 - 수행 중인 다른 프로세스에 영향을 주지도 받지도 않음, 입력에 의해서만 결정되고 같은 입력에 대해 동일한 실행 결과
  - 협력 프로세스 - 수행 중인 다른 프로세스와 영향을 주고 받음, 실행결과는 실행순서에 좌우됨, 같은 입력에 대해 항상 동일한 실행결과를 보장하지 못함

## 병행성 문제

- 협력 프로세스인 경우 발생 가능한 문제 - 상호배제, 동기화, 통신
- 상호배제 - 2개 이상의 프로세스가 동시에 임계영역을 수행하지 못하도록 하는 것
  - 임계영역 - 2개 이상의 프로세스가 동시에 사용하면 안 되는 공유자원을 엑세스하는 프로그램 코드 영역
    - ex) A의 ATM과 B의 모바일 뱅킹을 사용할 때 임계영역
- 동기화 - 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것
  - 상호배제 또한 임계영역에 대한 동기화 문제라고 볼 수 있음
- 통신
  - 프로세스들이 데이터 공유하기 위해 필요, 프로세스 간 통신(IPC)
  - 하나의 변수 사용, 메시지를 주고 받음

## 세마포어

- 세마포어
  - 상호배제와 동기화 문제를 해결하기 위한 도구, Dijkstra가 제안
  - 정수형 공용변수 - 상황에 맞춰 0 이상인 정수로 초기화
  - 두 기본연산 P와 V에 의해서만 사용됨 - 인터럽트되지 않고 하나의 단위로 처리됨
  - 연산 P(검사, 감소시키려는 시도), 연산 V(증가)
  - 각각의 세마포어마다 대기 큐가 필요
- 상호배제와 동기화 해결

# 5강. 병행 프로세스 II

## 생산자-소비자 문제

- 생산자-소비자 문제 정의
  - 두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다루는 문제
    - 생산자 - 데이터를 넣는 프로세스
    - 소비자 - 데이터를 꺼내는 프로세스
- 생산자-소비자 문제 조건
  - 버퍼에 여러 프로세스가 동시에 접근할 수 없음 → 상호 배제 필요
  - 버퍼의 크기가 유한(유한 버퍼 문제) → 동기화 필요
- 세마포어를 이용한 해결

## 판독기-기록기 문제

- 판독기-기록기 문제 정의
  - 여러 협력 프로세스 사이에 공유자원을 두고 판독기와 기록기의 상황을 다루는 문제
    - 판독기 - 데이터를 읽는 프로세스(공유자원을 변경시키지 않음)
    - 기록기 - 데이터를 쓰는 프로세스(공유자원 변경)
- 판독기-기록기 문제 조건
  - 하나의 기록기가 공유자원에 데이터를쓰는 중에는 다른 기록기나 판독기는 공유자원에 접근할 수 없음 → 상호배제 필요
  - 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있고 문제 없음
  - 판독기가 읽는 중 기록기 대기 → 새로운 판독기 읽기 시도할 때 가능할지 불가능할지 정책적으로 결정 필요
- 제1판독기-기록기 문제
  - 판독기 우선 - 새로운 판독기는 즉시 공유자원 접근 가능
  - 문제점 - 기록기의 기아 상태 유발
- 제2판독기-기록기 문제
  - 기록기 우선 - 판독기가 공유자원에 접근 중이라면 판독기보다 기록기에 우선순위를 줌
  - 문제점 - 판독기의 병행성이 떨어지고 기아 상태 유발

## 프로세스 간 통신

- InterProcess Communication
  - 병행 프로세스가 데이터를 서로 공유하는 방법
    - 공유 메모리 방법, 메시지 전달 방법
  - 하나의 운영체제에서 두 방법 함께 사용 가능
- 공유 메모리 방법
  - 동일한 변수: 공유자원인 메모리 공간 사용
  - 대량 데이터 교환: 고속 통신 가능
  - 통신산 발생 가능 문제 해결 → 응용 프로그래머 필요
- 메시지 전달 방법
  - 시스템 호출 send(). receive()
  - 소량 데이터 교환에 적합하고 통신상 발생 가능 문제에 대한 고민이 필요 없음, 운영체제가 알아서 처리
- 메시지 전달 방법의 논리적 구조
  - 통신 링크(메시지가 지나다니는 통로)의 구현 형태
    - 연결 대상: 두 프로세스, 셋 이상의 프로세스
    - 두 프로세스 사이의 링크 개수: 하나 혹은 둘 이상
    - 방향성: 단방향 or 양방향
    - 용량: 무한 or 유한 or 0
- 통신 링크의 용량
  - 무한 - 큐가 무한이라 송신자는 대기 없음
  - 유한 - 큐가 유한이라 송신자는 큐가 가득 차면 대기
  - 0 - 송신자는 수신자가 메시지를 받을 수 있을 때까지 대기(큐가 존재하지 않아서 바로 받아야 되는 구조)
- 직접통신
  - 두 프로세스가 직접 서로를 지정하여 메시지 전달
  - 오직 하나의 통신 링크가 자동 설정
  - 하나의 통신 링크는 오직 두 프로세스 사이에만 연관
  - 통신 링크는 양방향
  - 대칭형 주소 지정 or 비대칭형 주소 지정(수신자가 여러 송신자와 통신 링크를 갖는 경우)
- 간접통신

  - 프로세스 사이에 둔 우편함을 통해 메시지 전달
  - 같은 우편함이면 통신 링크가 설정, 여러 우편함을 이용하면 여러 개의 통신 링크 존재
  - 하나의 통신 링크가 여러 프로세스와 연관 가능
  - 통신 링크는 단방향 or 양방향

  # 6강. 교착상태 I

## 교착상태의 개요

- 프로세스의 자원 사용 절차
  - 요구 → 사용 → 해제
  - 요구과정에서 가용 자원 없으면 자원 획득할 때까지 대기
- 교착상태(deadlock)
  - 여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있어 어느 쪽도 영원히 진행하지 못하는 상태
- 교착상태와 기아상태의 차이
  - 교착상태는 영원히 멈춰 있으나, 기아상태는 언젠가 해소될 가능성이 있는 것

## 교착상태의 특성

- 교착상태의 필요조건
  - 상호배제
  - 점유대기
  - 비선점
  - 환형대기
- 상호배제(mutual exclusion) 조건
  - 프로세스가 자원에 대한 배타적 통제권을 요구하는 경우
- 점유대기(hold and wait) 조건
  - 프로세스가 이미 한 자원을 할당 받아 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는 또 다른 자원을 요구하여 해제되기를 기다리고 있는 상황
- 비선점(no preemption) 조건
  - 프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에는 해제되지 않음
  - 할당된 자원은 타의에 의해서는 해제되지 않음
- 환형대기(circular wait) 조건
  - 프로세스가 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 상황
- 교착상태의 필요조건 표현
  - 상호배제 - 하나의 할당간선
  - 점유대기 - 한 프로세스에 할당간선과 요구간선 연결
  - 비선점 - 요구간선
  - 환형대기 - 사이클(cycle)
- 자원할당 그래프
  - 사이클 없음 → 교착상태 없음
  - 사이클 있음 → 교착상태 발생 가능(했을 수도, 할 예정일 수도)
- 교착상태 처리기법
  - 교착상태 예방 - 네 가지 필요조건의 동시 만족을 피하고 발생하지 않도록 하는 방법
  - 교착상태 회피 - 자원의 최대량에 대한 정보를 이용해서 교착상태가 발생하지 않도록 하는 방법
  - 교착상태 탐지 및 복구 - 교착상태 체크 후 적절한 조치를 취해 복구하는 방법

## 교착상태 예방

- 상호배제 조건 제거
  - 공유할 수 없는 자원: 반드시 상호배제 필요 ex) 프린터 → 상호배제 조건 제거로 교착상태 예방 불가능
- 점유대기 조건 제거
  - 자원을 점유했을 때 대기하지 않도록 → 프로세스가 앞으로 필요 자원 모두를 처음 한꺼번에 요구하여 할당 받음 → 자원이용률 낮아짐, 기아상태 가능
  - 대기할 때 자원을 점유하지 않도록 → 새로운 자원 요구할 때 할당 받았던 자원 모두 해제, 점유 도중 해제할 수 없는 자원에는 적용 불가
- 비선점 조건 제거
  - 선점이 가능하도록 → 자원의 특성에 따라 불가능한 경우 존재 ex) 프린터
- 환형대기 조건 제거
  - 모든 자원에 일련번호를 지정
  - 방법 1 - 프로세스는 자원을 요구할 때 일련번호 기준으로 항상 오른차순이 되도록 요구
  - 방법 2 - 프로세스가 자원을 요구할 때 그보다 일련번호가 작은 자원만 점유하도록 함
  - 점유대기 중인 프로세스는 점유 중인 자원의 일련번호보다 대기 중인 자원의 일련번호가 큼 → 환형대기 발생 불가능

# 7강. 교착상태 II

## 교착상태 회피

- 안전상태와 안전순서열
  - 안전상태 - 교착상태를 회피하면서 각 프로세스에 그들의 최대 요구량까지 빠짐없이 자원 할당이 가능한 상태, 교착상태 회피 가능
  - 안전순서열이 존재하는 경우
  - 불안전상태 - 안전순서열이 존재하지 않는 경우, 교착상태 발생 가능성 있음
- 안전순서열
  - 순서 있는 프로세스의 집합
- 교착상태 회피
  - 교착상태는 불안정상태에서만 발생 가능
  - 항상 안전상태를 유지해야
  - 프로세스 가용상태의 자원을 요구하더라도 프로세느는 대기상태가 될 수 있음 → 자원이용률은 낮아질 수 있음
- 교착상태 회피 알고리즘
  - 각 자원의 단위 자원이 하나밖에 없는 경우
    - 변형된 자원할당 그래프
      - 자원을 요구 받으면 해당 선언간선을 요구간선으로 변경
      - 변경해도 사이클이 생기지 않는 경우에만 자원을 할당하고 할당간선으로 변환
  - 각 자원의 단위 자원이 여러 개일 수 있는 경우
    - 은행원 알고리즘
      - 자원을 요구 받으면 그 자원을 할당해주고 난 후의 상태를 계산해서 그것이 안전상태인지 확인
      - 안전 상태가 보장되는 경우에만 자원을 할당

## 교착상태 탐지 및 복구

- 교착상태 탐지 및 복구
  - 교착상태 탐지(상태 조사 알고리즘 수행) → 교착상태 복구
- 교착상태 탐지
  - Shoshani와 Coffman 알고리즘(현재 교착상태만 탐지)
- 교착상태 복구
  - 복구의 주체
    - 오퍼레이터 - 수작업으로 복구 / 운영체제 - 자동으로 복구
  - 복구 방법
    - 교착상태 프로세스를 종료
    - 교착상태 프로세스가 할당받은 자원을 해제
  - 교착상태 프로세스 종료 → 진행했던 내용에 대한 복원비용이 큼
  - 사이클이 제거될 때까지 교착상태 프로세스를 하나씩 종료 → 교착상태 재호가인을 위한 비용 필요
  - 할당 자원 해제 → 할당된 자원을 단계적으로 선점해서 다른 프로세스에 할당 → 프로세스 진척도, 사용 중인 자원의 수 등을 통해 자원 선택 기준 → 복귀시점도 제반 요소 고려해서 결정, 기아상태에 빠지지 않도록 프로세스 선택 시 복구 횟수 고려

# 8강. 메모리 관리

## 프로세스와 메모리

- 프로세스의 동작
  - 프로그램 카운터(PC)를 참조하여 수행될 명령을 메모리에서 읽어 CPU로 수행하는 것
  - 캐시메모리 ↔ 메모리 ↔ 보조기억장치
- 기억장치 계층구조 - 적절한 비용으로 높은 성능을 내기 위해
  - CPU(레지스터) - 캐시 메모리 - 메모리 - 보조기억장치
  - ← 접근속도가 빠름, 비트당 기억장치 비용이 높음
  - → 대용량
- 메모리 관리
  - 메모리 호출 - 언제 새로운 프로세스를 메모리에 둘 것인가
  - 메모리 배치 - 다음 실행될 프로세스를 메모리 내 어느 곳에 둘 것인가
  - 메모리 교체 - 메모리가 꽉 찬 상태에서 프로세스를 메모리에 적재해야 한다면 어떤 프로세스를 제거할 것인가
  - 그 외 고정/동적 분할, 고정/유동 적재영역 등

## 단일 프로그래밍 환경

- 단일 프로그래밍 - 하나의 프로세스만 메모리를 전용으로 사용
- 단일 프로그래밍의 문제점
  - 메모리의 용량부터 큰 프로세스는 실행 못함
  - 메모리 낭비 심함 - 지속적으로 사용되지 않는 프로세스도 메모리에 계속 적재
- 주변장치 등 자원 낭비 심함 - 계산 위주일 때는 I/O가 쉬고 있고, I/O 위주일 때는 CPU가 놀고 있음

## 다중 프로그래밍 환경

- 다중 프로그래밍
  - 여러 개의 프로세스가 메모리에 동시 적재되는 것
  - CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가
- 메모리 분할 - 고정 분할
  - 여러 개의 고정된 크기의 영역으로 분할(ex) 분할1(25MB), 분할2(40MB), 분할3(60MB))
  - 분할영역마다 큐를 두고 큐에 들어온 프로세스는 해당 분할영역에만 적재
  - 프로세스 배치 방법 1 - 절대 번역 및 적재, 분할영역이 정해져 있어서 분할 영역이 놀고 있을 수 있기에 효율성 낮음
  - 프로세스 배치 방법 2 - 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할영역에든 적재, 재배치 가능 번역 및 적재, 복잡함(컴파일이나 주소에 대한 계산 등)
  - 문제점: 내부 단편화 - 프로세스 크기가 분할 영역의 크기보다 작아서 분할 영역 내에 남게 되는 메모리 발생 → 하나의 분할 속에서는 하나의 프로세스만 올 수 있기 때문에 남는 공간 활용 불가능(내부 단편화)
    - 수행할 프로세스의 크기에 맞춰 고정분할을 할 수도 있지만 현실성이 없음, 거의 불가능
- 메모리 분할 - 동적 분할
  - 문제점: 외부 단편화 - 메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김
    - 통합 - 인정된 공백을 더 큰 하나의 공백으로 만들어 외부 단편화 해결 → 멀리 떨어진 공백은 해소 방법 없음
    - 집약 - 메모리 내에 모든 공백을 하나로 모아 외부 단편화 해결 - 집약을 위해선 분할된 메모리들을 모아줘야 함 → 매번 할 순 없고 적당한 시점에 해줘야 비용적으로 가능함
- 메모리 보호 - 프로세스가 다른 할당영역을 침범하지 않게 하는 것

## 메모리 배치기법

- 메모리 배치기법
  - 동적 분할에서 새로 반입된 프로그램이나 데이터를 메모리 어디에 배치할 것인가 결정
  - 최초 적합, 후속 적합, 최적 적합, 최악 적합
- 최초 적합
  - 프로세스가 적재될 수 있는 빈 공간 중 가장 먼저 발견된 곳에 할당(첫 공백이 가용공간이 부족하다면 그 다음 공간)
- 후속 적합
  - 최초 적합의 변형, 이전 탐색이 끝난 그 다음 부분에 할당
- 최적 적합
  - 가능한 빈 공간 중 가장 작은 곳을 선택하여 할당
  - 큰 빈 공간을 최대한 많이 남겨놓기 위한 방법
- 최악 적합
  - 가능한 빈 공간 중 가장 큰 곳을 선택하여 할당
  - 애매한 작은 자투리 공간이 남아 사용하지 못하는 걸 최소화하기 위한 방법

# 9강. 가상 메모리

## 가상 메모리의 개념

- 연속 메모리 할당
  - 메모리 크기보다 더 큰 기억공간이 필요한 프로세스는 실행 불가
- 가상 메모리
  - 실제 메모리 크기보다 더 큰 기억공간이 필요한 프로세스도 실행할 수 있게 하는 방법
  - 프로세스 중 PC가 가리키는 부분만 메모리에 담는다면 처리 가능
  - 실행 중인 프로세스에 의해 참조되는 주소를 메모리에서 사용하는 주소와 분리
  - 현재 필요한 일부만 메모리에 적재
- 사상(mapping)
  - 프로세스 실행을 위해 가상 주소를 실주소로 변환하는 과정
  - 동적 주소변환(DAT): 프로세스가 실행되는 동안 사상
  - 인위적 연속성 - 가상주소 공간에서 연속적인 주소가 실주소 공간에서도 연속적일 필요가 없음

## 블록 단위 주소변환

- 주소 변환
  - 주소 변환 사상표 - 동적 주소변환을 위한 정보를 가진 표
  - 주소 변환이 바이트나 워드 단위로 이뤄지면 변환에 필요한 정보량이 너무 많아 비효율적임 → 그래서 블록 단위로 접근
- 블록 사상 시스템
  - 블록 단위로 주소 변환
  - 가상 메모리의 각 블록이 메모리의 어디에 위치하는지 관리
  - 가상 주소 v = (b, d) - b: 블록 번호, d: 블록의 시작점으로부터 변위
  - 블록의 크기는 적절히 정해야 함
    - 크기가 커질수록 → 사상표 크기 감소, 블록 전송시간 증가, 동시 적재할 프로세스 수 감소
    - 크기가 작아질수록 → 사상표 크기 증가, 블록 전송시간 감소, 동시 적재할 프로세스 수 증가
- 블록 구성방식
  - 페이지(page) - 블록의 크기가 동일
  - 세그먼트(segment) - 블록의 크기가 다를 수 있음
- 페이징 기법 - 동일한 크기의 페이지 프레임으로 나눔
  - 페이지 프레임: 페이지를 담을 수 있는 틀
  - 페이지 사상표(가상 주소를 실 주소로 동적 변환을 위함)
    - 페이지 번호에 대한 페이지 프레임 번호 저장
  - 직접사상에 의한 동적 주소변환 - 페이지 사상표를 직접 이용
  - 연관사상의 의한 동적 주소변환 - 페이지 변환 정보를 연관 메모리에 저장한 연관사상표를 이용
  - (연관 메모리를 고가이기 때문에) 연관/직접 사상에 의한 동적 주소변환
    - 연관사상표에는 가장 최근에 참조된 페이지만 보관
    - 연관사상표에 없을 때만 직접사상 이용
- 페이징 기법의 특징
  - 논리적 의미와 무관한 동일 크기의 페이지로 나눔, 메모리 보호는 페이지 단위로 이루어짐
  - 외부 단편화는 발생하지 않지만, 내부 단편화 발생 가능
- 세그먼테이션 기법
  - 가상 메모리르 세그먼트 단위로 나누어 관리하는 기법
    - 세그먼트: 논리적 의미에 부합하는 다양한 크기의 블록
  - 세그먼트 사상표
    - 세그먼트 번호에 대한 실주소에서의 시작 위치 저장
    - 세그먼트 길이는 오버플로 확인용
- 페이징/세그먼테이션 혼용기법
  - 세그먼테이션 기법의 논리적 장점 + 페이징 기법의 메모리 관리 측면의 장점
  - 가상 메모리를 세그먼트 단위로 분할 후 각 세그먼트를 다시 페이지 단위로 분할
  - 메모리는 페이지 프레임으로 분할

## 메모리 호출기법

- 메모리 호출기법
  - 어느 시점에 페이지 또는 세그먼트를 메모리에 적재할 것인가 결정하는 기법
- 요구 페이지 호출기법
  - 프로세스의 페이지 요구가 있을 때 요구된 페이지를 메모리에 적재
- 예상 페이지 호출기법
  - 곧 사용될 것으로 예상되는 페이지를 미리 메모리에 적재
- 메모리 호출기법 비교
  - 요구 페이지 호출기법 - 옮길 페이지 결정에 대한 오버헤드 최소화, 적재된 페이지는 실제 참조, 프로세스 시작 시점에는 연속적으로 페이지 부재 발생
  - 예상 페이지 호출기법 - 예상이 잘못된 경우 시간과 메모리 공간 낭비, 프로세스 시작 시점에 적용하면 성능 개선

# 10강. 페이지 교체 알고리즘

### 페이지 교체 알고리즘

- 페이징 기법
  - 모든 페이지 프레임이 사용되고 있을 때 새로 적재될 페이지를 위해 적절한 교체 대상을 결정
- 교체 대상 선택
  - 최적화의 원칙 - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택, 하지만 이론적으로 최적이나 미래를 예측할 수 없어 불가능
  - 선택을 위한 기본 정책 - 대체로 좋은 결론을 내리면서 선택을 위한 시간 및 공간 오버헤드가 적은 방법
  - 교체 제외 페이지
    - 페이징을 위한 커널 코드 영역
    - 보조기억장치 드라이버 영역
    - 시간을 맞춰 동작해야 하는 코드 영역
    - 입출력장치를 위한 데이터 버퍼 영역 등
- FIFO 페이지 교체
  - First-In First-Out - 메모리 내에 가장 오래된 페이지를 교체
  - 단점 - 가장 많이 쓰이는 페이지를 교체시킬 가능성 있음, Belady의 이상현상(프로세스에 더 많은 수의 페이지 프레임을 할당하면 오히려 페이지 부재가 더 많이 발생)
- LRU 페이지 교체
  - Least Recently Used - 메모리 내에서 가장 오랫동안 사용되지 않은 페이지를 교체
  - 국부성(Locality) 휴리스틱에 기반 - 최근 상황이 가까운 미래에 대한 좋은 척도로 사용 및 예측, 시간 국부성, 공간 국부성
  - 참조시각을 이용한 구현
    - 각 페이지가 참조될 때마다 그때의 시각을 테이블에 기록, 교체가 필요한 경우 참조시각이 가장 오래된 페이지를 선택하여 교체
  - 리스트를 이용한 구현
    - 각 페이지가 참조될 때마다 리슬트의 선두로 옮김, 교체가 필요한 경우 리스트의 끝에 있는 페이지를 선택하여 교체, 추가 작업이 필요해서 오버헤드가 필요
  - 장점 - Belady의 이상현상 없음, 많은 경우 최적화 원칙에 근사
  - 단점 - 국부성에 맞지 않는 상황도 존재, 막대한 오버헤드
- LFU 페이지 교체
  - Least Frequently Used - 메모리 내에서 참조된 횟수가 가장 적은 페이지를 교체
  - 단점 - 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성이 높고, 초기에 많이 사용됐지만 더 이상 사용되지 않는 페이지는 교체 가능성이 낮아지게 됨, 막대한 오버헤드
- 2차 기회 페이지 교체
  - 참조 비트가 0이면서 메모리 내에 가장 오래 있었던 페이지를 교체
  - 각 페이지가 메모리에 적재될 때는 참조 비트 0, 적재된 상태에서 추가로 참조되면 참조 비트 1
  - 변형된 원형 큐를 이용한 구현(클럭 페이지 교체 알고리즘)
    - 포인터는 마지막에 추가된 페이지의 다음 위치를 가리킴

### 프로세스별 페이지 집합관리

- 프로세스별 페이지 집합
  - 프로세스마다 사용할 수 있는 페이지 프레임의 개수만큼 메모리에 유지되고 있는 페이지 집합
  - 집합의 크기가 작을수록 시스템 처리량 증대, 각 프로세스별 페이지 부재는 자주 발생하여 성능 저하
  - 집합의 크기가 클수록 적재될 수 있는 프로세스는 줄어듬, 페이지 부재는 감소
  - 페이지 프레임 관리 → 워킹 세트 알고리즘, PFF 알고리즘
- 워킹 세트 알고리즘
  - 페이지 부재 비율을 감소시키지 위해 Denning이 제안한 모델
  - 프로세스의 워킹세트 W - 시각 t에 t를 포함한 직전 8시간 동안 참조한 페이지의 집합
  - 과거를 통해 미래 예측이 정확하지 않음, 지속적인 업데이트가 현실적으로 어려움, 최적값을 알기 어려우며 이 역시 변화할 수 있음
- PFF 알고리즘
  - Page Fault Frequency - 페이지 부재 빈도를 이용하여 프로세스별 페이지 집합의 크기를 변화시키는 기법
  - PFF의 상한과 하한을 정해둠
  - 프로세스별 페이지 집합이 워킹 세트 알고리즘처럼 자주 바뀌지 않기 때문에 유지보수성이 좋음

# 11강. 장치관리

### 장치의 개념

- 컴퓨터 시스템의 구성
  - 다양한 장치들 - CPU, 메모리, 나머지 장치들(데이터 입출력 등)
- 세 가지 범주 - 전용장치, 공용장치, 가상장치
- 전용장치
  - 한 번에 단지 하나의 프로세스에만 할당, 테이프 드라이브, 프린터, 플로터 등, 대기시간이 길어질 수 있음
- 공용장치
  - 여러 프로세스에 할당, 하드디스크 같은 직접 저장 장치, 스케줄링 기법 필요
- 가상장치
  - 전용장치를 공용장치처럼 보이게 함
  - 디스크 같은 공용장치를 거쳐서(데이터를 통해) 이용, 공용장치에 데이터를 전송함으로서 각각의 프로세스 입장에서는 작업이 끝났다고 인식할 수 있음

### 장치의 구성

- 논리적 구성
  - 장치제어기 - 운영체제와 장치 사이, 장치를 직접적으로 다루는 전자장치
    - 장치에 발생하는 각종 데이터를 전자신호로 변환하여 운영체제로 보냄
    - 운영체제가 요청하는 명령을 받아 장치 구동, 운영체제가 보내는 출력을 장치에 맞게 변환
  - 장치 드라이버 - 응용 프로그램의 입출력 요청을 해당 장치에 맞게 변환
  - 장치에 종류나 제조사에 따라 이해하는 명령이나 종류가 다를 수 있어서 장치 제조사에서 해당 장치의 드라이버도 같이 제공
- 물리적 구성
  - CPU의 장치 사용법 - 장치제어기의 레지스터 이용, 장치의 상태를 확인하거나 장치에 명령

### 입출력 처리 유형

- 프로세스가 진행하며 입출력이 발생하는 경우
- 세 가지 유형 - 프로그램 방법, 인터럽트 방법, DMA 방법
- 프로그램 방법
  - CPU만 이용하는 폴링(polling)을 이용하여 입출력 처리 - CPU가 입출력 장치의 상태를 지속적으로 확인하며 CPU가 원하는 상태가 될 때까지 기다림
  - CPU 낭비가 심해 비효율적
- 인터럽트 방법
  - 인터럽트, 즉 어떤 장치가 다른 장치의 작업을 잠시 중단시키고 자신의 상태를 알리는 기능을 이용하여 입출력 처리
  - 프로세스를 대기상태로 보내고 인터럽트가 발생할 때까지 CPU는 다른 프로세스 처리 가능
  - I/O 장치가 가용 상태라고 인터럽트 제어기에 신호 보냄 → 인터럽트 제어기는 CPU에 인터럽트 신호 보냄 → CPU는 현재 실행 중인 명령만 마치고 즉시 인터럽트에 응답 → 인터럽트 제어기는 이벤트 대상에 대한 정보를 CPU에 보냄 → CPU는 현재 상태 보관 후 필요한 입출력 처리
- DMA 방법
  - Direct Memory Access를 이용하여 입출력 처리
  - DMA 제어기를 이용하여 CPU를 통하지 않고 메모리에 직접 접근하여 데이터를 전송하는 방법
  - 인터럽트 발생 횟수를 단 한 번으로 줄여 CPU 효율 증대
  - CPU는 입출력에 필요한 정보를 DMA 제어기에 넘김(그 이후 CPU는 다른 프로세스 가용 가능)
  - 사이클 스틸링(cycle stealing) - CPU와 DMA 제어기가 동시에 메모리 엑세스를 시도하면 DMA 제어기에 우선권 부여

### 입출력 관리

- 버퍼링
  - CPU의 데이터 처리속도와 I/O 장치의 데이터 전송속도의 차이로 인한 문제를 버퍼를 통해 해결
  - 메모리를 일시적인 데이터 저장장소인 버퍼로 이용
  - 단일 버퍼링 - 저장과 처리를 동시에 할 수 없어 비효율적
  - 이중 버퍼링 - 두 개의 버퍼를 통해 저장과 처리 같이 처리
  - 순환 버퍼링 - 여러 개의 버퍼를 통해 동시 처리
- 스풀링
  - 입출력 프로세스와 저속 입출력장치 사이에 데이터 전송을 자기 디스크와 같은 고속장치를 통하도록 하는 것
  - 프로세스 입장에서는 입출력 작업이 빨리 끝남, 전용장치를 가상장치로 변화시킴

# 12강. 저장장치 및 파일 관리

### 저장장치의 종류

- 순차접근 저장장치
  - 데이터를 순차적으로 읽거나 쓸 수 있는 저장장치 ex) 테이프 장치
  - 초기 접근시간이 굉장히 오래 걸림, 현재는 대량의 데이터 백업용으로 사용
- 직접접근 저장장치
  - 지정한 위치를 직접 찾아 데이터를 읽거나 쓸 수 있는 저장장치
  - 임의접근 저장장치
  - 자기 디스크
    - 자성을 띤 디스크의 표면에 데이터를 쓰거나 읽음
  - 광디스크
    - 디스크 표면에 레이저를 쏘아 반사되는 빛의 차이를 이용하여 데이터를 읽거나 씀
    - 나선형인 하나의 트랙으로 구성 ex) 블루레이, CD 등
  - SSD
    - 읽고 쓰기가 가능하면서 전력공급이 없어도 데이터가 지워지지 않는 메모리 이용
    - 자기 디스크보다 속도가 빠르고 전력 소모가 적지만, 비싸고 수명이 짧음

### 디스크 스케줄링 알고리즘

- 디스크 스케줄링
  - 디스크 접근 요구를 효율적으로 처리하는 순서를 결정하는 작업
    - 디스크 접근 요구: 디스크에서 데이터를 읽거나 쓰는 요구
  - 프로세스들의 요구를 디스크 큐에 두고 관리
  - 기계적 동작이 최소화되도록 디스크 큐를 재배열 - 직접 접근을 위해 헤드의 이동, 디스크의 회전 같은 기계적 움직임 필요
- 디스크 접근 요구 처리 시간
  - 탐구시간(seek - 트랙을 찾아가는 시간)+회전지연시간(Rotational latency time)+전송시간(실제 데이터를 읽고 쓰는 시간)
  - 전송시간은 무조건 필요, 고정적
  - 스케줄링 형태는 즉 탐구시간과 회전지연시간을 최적화하는 데에 목적 - 주로 탐구시간 최적화에 맞춰져 있음
- FCFS 스케줄링
  - First-Come First-Served
  - 먼저 도착한 접근 요구가 먼저 서비스를 받는 방법
  - 공평하고 단순하지만, 도착순서에 따라 총탐구시간이 커질 수 있음, 디스크 부하가 높을수록 응답시간이 길어짐
- SSTF 스케줄링
  - Shortest Seek Time First
  - 현재 헤드 위치 기준 매순간 탐구시간이 가장 짧은 접근 요구를 먼저 처리하는 방법
  - 양 끝 쪽에 위치한 트랙에 대한 접근 요구는 기아상태 발생 가능
  - 트랙 위치에 따라 응답시간 편차가 커서 시분할 운영체제에 부적합
- SCAN 스케줄링
  - 양 끝 트랙 사이를 왕복하며 진행방향의 가장 가까운 접근 요구를 먼저 처리하는 방법
  - SSTF 스케줄링의 응답시간 편차를 어느 정도 개선
  - 새로운 요구가 헤드 진행방향의 바로 앞이냐 뒤냐에 따라 새로운 응답시간 편차 발생
  - 양 끝 트랙은 헤드가 한번 왕복할 때마다 한 번의 서비스 기회만 있음
- C-SCAN 스케줄링
  - 오로지 한쪽 방향으로만 진행방향의 가장 가까운 접근 요구를 먼저 처리하는 방법, 나머지는 SCAN과 동일
  - 양 끝 트랙에 대한 접근 요구 차별 제거, 응답시간의 편차가 매우 작음
- LOOK 스케줄링
  - SCAN과 동일하되 진행방향으로 더 이상 접근 요구가 없으면 방향을 바꿈
- C-LOOK 스케줄링
  - C-SCAN 스케줄링과 동일하되 진행방향으로 더 이상 접근 요구가 없으면 방향으로 바꾸어 가장 먼 접근 요구 트랙까지 이동하는 방법
- SLTF 스케줄링
  - Shortest Latency Time First
  - 동일 실린더의 여러 섹터에 대한 접근 요구에 대해 회전지연시간이 가장 짧은 것을 먼저 처리하는 방법
  - 회전지연시간 최적화, 이론적인 최적해와 거의 일치, 높은 부하 상태에 유용

### 파일 관리

- 파일 관리자의 요소
  - 엑세스 방식 - 파일에 저장된 데이터에 접근
  - 파일 관리 - 저장, 참조, 공유 및 안전하게 보호
  - 보조기억장치 관리 - 보조기억장치에 파일 저장하는 데 필요한 공간 할당
  - 파일 무결성 유지 - 파일의 정보가 소실되지 않도록 보장
- 파일 구조와 접근 방식
  - 파일 구조 - 보조기억장치에 레코드들이 배치되는 방식
  - 접근 방식: 순차 파일, 인덱스된 순차 파일, 직접 파일
  - 순차 파일 - 차례대로 물리적 순서에 따라 저장
  - 인덱스된 순차 파일 - 인덱스가 추가
  - 직접 파일 - 레코드의 키를 이용하여 직접접근 저장장치의 물리적 주소를 통해 직접 엑세스되는 파일
- 디스크 공간 할당
  - 연속 할당 기법 - 보조기억장치의 연속된 가용공간에 파일 저장공간 할당, 필요 공간의 크기를 미리 정해야 함, 엑세스가 효율적이고 디렉터리 구현이 단순, 다만 외부 단편화와 파일 크기 확장에 대한 대응이 비효율적
  - 불연속 할당 기법 - 섹터 또는 블록 단위로 공간 할당, 포인터를 이용하여 블록들을 연결, 단편화 문제 및 파일 확장 문제 해결, 다만 파일 공간 분산으로 성능저하, 포인터 관리를 위한 연산 및 공간 소비
