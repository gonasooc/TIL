# 1강. 운영체제 소개

## 운영체제란 무엇인가

### 컴퓨터 시스템의 구성

- 운영체제 - 대표적인 시스템 소프트웨어, 컴퓨터 시스템 자원을 관리하고 프로그램 동작을 위한 서비스를 제공하는 프로그램들의 모음

### 운영체제의 역할

- 컴퓨터 시스템의 자원 관리 - 컴퓨터 시스템을 효율적으로 운영하는 목적
- 사용자 지원 - GUI 등 사용자 편의성 제공

### 컴퓨터 시스템과 운영체제

- 운영체제가 없던 초기의 컴퓨터 시스템
  - 응용 프로그램에서 직접 시스템의 자원 제어 → 즉, 개발자가 로우 레벨에서 개발해야 하기 때문에 하드웨어 제어 방법을 잘 알아야 함 ex) 몇 번 포트에 빛을 쏴준다거나
  - 여러 사용자가 하드웨어를 공유하는 경우 자원 분할 어려움
- 운영체제가 있는 컴퓨터 시스템
  - 하드웨어와 응용 프로그램 사이에 운영체제 위치
  - 여러 사용자의 자원 분배 및 제어 가능 → 안정적으로 효율적으로 동작 가능

### 커널 모드와 사용자 모드

- 커널 모드(슈퍼바이저 모드) - 하드웨어 직접 제어
- 사용자 모드 - 하드웨어 직접 제어 불가능
- 일체형 커널(monolithic kernel) - 운영체제의 모든 서비스가 커널 내에 포함
  - 커널 내부 요소들이 효율적 상호작용
  - 하나라도 오류가 발생하면 전체 장애 발생
  - ex) UNIX, Linux
- 마이크로커널(mircokernel) - 운영체제 요소 대부분을 커널 외부에 분리
  - 메모리 관리, 멀티태스킹 등 최소한의 요소만 커널 내 남김
  - 새로운 서비스 추가로 운영체제 확장 쉽고, 유지보수 용이하고 안정성이 우수함
  - 커널 외부 요소들 사이에 IPC(프로세스 통신)가 필요해서 성능 저하 발생
- 일반적으로 사용자 모드를 사용하다가 하드웨어에 대한 제어가 필요한 경우(**시스템 호출**) 커널 모드로 전환 → 제어가 끝나면 다시 사용자 모드로 전환

## 운영체제의 구성

- 컴퓨터 시스템 자원의 성격에 따라 구분
  - 프로세스 관리자, 메모리 관리자, 파일 관리자, 장치 관리자

### 프로세스 관리자

- 메모리에서 실행 중인 프로세스의 생성 및 삭제 등 관리, CPU 할당을 위한 스케줄링

### 메모리 관리자

- 메모리 할당 및 회수, 공간 보호(ex) OS가 사용하는 메모리 공간 보호) 등

### 장치 관리자

- 모든 장치에 대한 관리

### 파일 관리자

- 저장장치의 공간 관리 및 파일의 접근 제한 등 관리

## 운영체제의 유형

### 일괄처리 운영체제

- 작업을 모아서 순서대로 처리하는 방식
- 앞선 작업들을 기다려야 해서 상호작용 없이 기다려야 하는 비효율성 존재

### 시분할 운영체제(time-sharing)

- 대화형(interactive) 운영체제라고도 함
- 응답시간이 일괄처리 운영체제보다 크게 단축됨

### 실시간 운영체제(RTOS)

- 처리 결과가 현재의 결정에 영향을 주는 특수 목적의 환경에서 사용 ex) 미사일 제어 시스템, 증권거래 관리 시스템 등
- 우선순위가 높은 작업을 먼저 처리

### 분산 운영체제

- 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템

# 2강. 프로세스와 쓰레드

## 프로세스

- 프로세스(process): 실행 중인 프로그램 - 시스템 프로세스(백그라운드) / 사용자 프로세스
  - 프로그램: 동작을 하지 않은 정적, 수동적 개체
  - 프로세스: 동작을 하는 능동적 개체
- 운영체제로부터 자원 할당
  - 자원: CPU, 메모리, 입출력장치, 파일 등
  - 동작: CPU가 프로세스의 명령을 실행
- 운영체제는 프로세스를 실행 및 종료하고, 스케줄링하면서 관리
- 메모리 구조 - 코드 영역/데이터 영역
  - 코드 영역은 프로그램 자체
  - 데이터 영역(정적 데이터/스택/힙) - 실행 시 필요한 데이터, 상수나 변수, 서브프로그램 호출 상태 등
- 프로세스 제어 블록(Process Control Block: PCB) - 운영체제가 프로세스 관리를 위해 필요한 정보
  - 프로세스 번호(PID), 프로세스 상태, 프로그램 카운터(PC), 레지스터, 메모리 관리 정보, 프로세스 우선순위, 회계정보
- 프로세스 상태 관리
  - 생성 - 준비 - _대기_ - 실행 - 종료
- 프로세스 상태 변화
  - 생성 → 준비 →(디스패치)←(할당시간 만료) 실행 →(이벤트 대기) 대기 →(재개 조건 만족), 실행 → 종료
- 부모 프로세스와 자식 프로세스
  - 사용자가 직접 실행할 수도 있지만 한 프로세스가 다른 프로세스를 생성할 수 있음 → 프로세스 생성 시스템 호출 이용
  - 부모 프로세스는 그 시스템 호출을 하는 프로세스
  - 자식 프로세스는 시스템 호출을 통해 새로 생성된 프로세스
  - UNIX, Linux
    - fork() - 자식 프로세스는 부모 프로세스의 복제본(PID만 다르게 부여)
    - exec() - 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행(PID 외 데이터는 다 변동)
  - Windows
    - CreateProcess() - 자식 프로세스는 아예 애초에 새로운 프로그램으로 생성
- 프로세스 종료 방법
  - 프로세스가 모든 처리를 완료(정상 종료)
  - 부모 프로세스에 의해 자식 프로세스 강제 종료
    - 종료 시스템 호출 이용
    - 자식 프로세스 생성 시 얻은 자식 PID 이용
  - 부모 프로세스가 종료되면 자식 프로세스 같이 종료

## 쓰레드

- 쓰레드 - 프로세스 내에서 다중 처리를 위해 제안된 개념
- 하나의 프로그램 실행을 위한 기본적인 단위, 디스패칭의 단위
- 쓰레드는 실행에 필요한 최소한의 정보만 가짐
  - PC를 포함한 레지스터 값
  - 상태 정보
  - 스택 영역
  - 그 외 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유
- 다중 쓰레드로 구성된 프로세스
  - 멀티 CPU 또는 멀티코어 컴퓨터 시스템 - 다중 쓰레드로 병렬 처리 가능
  - 처리속도 별로 쓰레드가 나눠진 경우 - 효율적인 처리 가능

# 3강. 프로세스 스케줄링

## 프로세스 스케줄링

### 프로세스 스케줄링

- 주어진 프로세스가 여러 개인 경우 프로세스 처리순서를 결정하는 것

### 하위단계 스케줄링

- 준비 큐에 있는 프로세스를 선택하여 사용 가능한 CPU를 할당(디스패치)하는 역할
- 수행 주체: 디스패처(dispatcher)

### 스케줄링의 목표

- 일괄처리 운영체제 - 처리량의 극대화, 반환시간의 최소화, CPU 활용의 극대화
- 시분할 운영체제 - 빠른 응답시간, 과다한 대기시간 방지
- 실시간 운영체제 - 처리기한 맞춤

### 스케줄링 정책

**선점 스케줄링 정책(preemptive)**

- 실행 중인 프로세스 인터럽트 후 다른 프로세스에 CPU 할당
- 높은 우선순위의 프로세스 처리
- 문맥 교환에 따른 오버헤드
- 운영체제는 문맥 교환에 빠르게 실행되도록 만들어져야 함, 실시간 시스템/시분할 시스템

**문맥(context)**

- CPU의 모든 레지스터와 기타 운영체제에 요구되는 프로세스의 상태

**문맥 교환(context switching)**

- 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업

**비선점 스케줄링 정책(nonpreemptive)**

- 실행 중인 프로세스는 바로 준비상태로 전이 불가
- 대기나 종료 상태에서 전이될 때까지 계속 실행 상태에 있게 됨
- 강제 문맥 교환이 없어서 오버헤드 발생하지 않음
- 긴 프로세스가 실행 중이라면 짧은 프로세스가 오래 기다리게 됨

### 스케줄링의 평가 기준

- 평균대기시간과 평균반환시간

## 스케줄링 알고리즘

**FCFS(First-Come First-Served) 스케줄링**

- 비선점 방식
- 장점 - 가장 간단한 스케줄링
- 단점 - 짧은 프로세스 대기 시간 있음, 중요 프로세스 나중에 수행될 가능성, 프로세스들의 도착 순서에 따라 평균 반환 시간이 크게 변함, 시분할 운영체제나 실시간 운영체제에는 부적합

**SJF(Shortest Job First) 스케줄링**

- 비선점 방식
- 준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧다고 예상되는 거 먼저 디스패치
- 장점 - 일괄 처리 환경에서 구현 쉬움
- 단점 - 준비 큐가 기준이기 때문에 이미 실행 중인 프로세스가 있는 경우 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수 있음, CPU 시간을 예상하기 어려워서 스케줄링을 도입하는 것이 쉽지 않음

**SRT(Shortest Remaining Time) 스케줄링**

- SJF 알고리즘의 선점 방식
- 준비 큐 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 거 먼저 디스패치
- 장점 - SJF보다 평균대기시간, 평균반환시간에서 효율적
- 단점 - 역시 실제로는 프로세스의 CPU 시간을 예상하는 게 어려움(거의 불가능), 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼

**RR(Round Robin) 스케줄링**

- 선점 방식
- 기본적으로는 FCFS와 같지만 정해진 시간 할당량에 의해 실행 제한
- 시간 할당량 안에 종료하지 못한 프로세스는 준비 큐 마지막에 배치됨
- 장점 - CPU 독점 없이 공평, 시분할 운영체제에 적합
- 단점 - 시간 할당량이 너무 크면 FCFS와 다를 바가 없고, 시간 할당량이 너무 작으면 너무 많은 문맥 교환 발생으로 오버헤드가 커짐

**HRN(Highest Response Ratio Next) 스케줄링**

- 비선점 방식
- 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치
- 예상 실행 시간이 짧을수록 + 대기시간이 길수록 응답 비율이 커짐
- 장점 - SJF 스케줄링 단점 보완 - 오래 대기한 경우 응답 비율이 커져 나중에 들어오는 단순히 짧은 프로세스보다 먼저 디스패치 가능
- 단점 - 실제로는 프로세스의 CPU 시간을 예상하기 어려움

**다단계 피드백 큐 스케줄링**

- 선점 방식, Round Robin 확장 느낌
- 시간 할당량이 다 되면 다음 단계로 가면서 다른 시간 할당량 부여
- I/O 위주 프로세스는 높은 우선권 유지, 연산 위주의 프로세스는 낮은 우선권이지만 긴 시간 할당량

# 4강. 병행 프로세스 I

## 병행 프로세스의 개요

- 병행성
  - 여러 개의 프로세스 또는 쓰레드가 동시 수행되는 시스템의 특성
    병행 프로세스의 실행 형태
  - 1개의 CPU - 인터리빙 형식
  - 여러 개의 CPU - 병렬처리 형식
  - 멀티 프로세서 시스템에서의 메모리 구조에 따라 강결합 시스템(공유 메모리 구조)와 역결합 시스템(분산 메모리 구조)로 나눠짐
    **프로세스 간의 관계**
  - 독립 프로세스 - 수행 중인 다른 프로세스에 영향을 주지도 받지도 않음, 입력에 의해서만 결정되고 같은 입력에 대해 동일한 실행 결과
  - 협력 프로세스 - 수행 중인 다른 프로세스와 영향을 주고 받음, 실행결과는 실행순서에 좌우됨, 같은 입력에 대해 항상 동일한 실행결과를 보장하지 못함

## 병행성 문제

- 협력 프로세스인 경우 발생 가능한 문제 - 상호배제, 동기화, 통신
- 상호배제 - 2개 이상의 프로세스가 동시에 임계영역을 수행하지 못하도록 하는 것
  - 임계영역 - 2개 이상의 프로세스가 동시에 사용하면 안 되는 공유자원을 엑세스하는 프로그램 코드 영역
    - ex) A의 ATM과 B의 모바일 뱅킹을 사용할 때 임계영역
- 동기화 - 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것
  - 상호배제 또한 임계영역에 대한 동기화 문제라고 볼 수 있음
- 통신
  - 프로세스들이 데이터 공유하기 위해 필요, 프로세스 간 통신(IPC)
  - 하나의 변수 사용, 메시지를 주고 받음

## 세마포어

- 세마포어
  - 상호배제와 동기화 문제를 해결하기 위한 도구, Dijkstra가 제안
  - 정수형 공용변수 - 상황에 맞춰 0 이상인 정수로 초기화
  - 두 기본연산 P와 V에 의해서만 사용됨 - 인터럽트되지 않고 하나의 단위로 처리됨
  - 연산 P(검사, 감소시키려는 시도), 연산 V(증가)
  - 각각의 세마포어마다 대기 큐가 필요
- 상호배제와 동기화 해결

# 5강. 병행 프로세스 II

## 생산자-소비자 문제

- 생산자-소비자 문제 정의
  - 두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다루는 문제
    - 생산자 - 데이터를 넣는 프로세스
    - 소비자 - 데이터를 꺼내는 프로세스
- 생산자-소비자 문제 조건
  - 버퍼에 여러 프로세스가 동시에 접근할 수 없음 → 상호 배제 필요
  - 버퍼의 크기가 유한(유한 버퍼 문제) → 동기화 필요
- 세마포어를 이용한 해결

## 판독기-기록기 문제

- 판독기-기록기 문제 정의
  - 여러 협력 프로세스 사이에 공유자원을 두고 판독기와 기록기의 상황을 다루는 문제
    - 판독기 - 데이터를 읽는 프로세스(공유자원을 변경시키지 않음)
    - 기록기 - 데이터를 쓰는 프로세스(공유자원 변경)
- 판독기-기록기 문제 조건
  - 하나의 기록기가 공유자원에 데이터를쓰는 중에는 다른 기록기나 판독기는 공유자원에 접근할 수 없음 → 상호배제 필요
  - 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있고 문제 없음
  - 판독기가 읽는 중 기록기 대기 → 새로운 판독기 읽기 시도할 때 가능할지 불가능할지 정책적으로 결정 필요
- 제1판독기-기록기 문제
  - 판독기 우선 - 새로운 판독기는 즉시 공유자원 접근 가능
  - 문제점 - 기록기의 기아 상태 유발
- 제2판독기-기록기 문제
  - 기록기 우선 - 판독기가 공유자원에 접근 중이라면 판독기보다 기록기에 우선순위를 줌
  - 문제점 - 판독기의 병행성이 떨어지고 기아 상태 유발

## 프로세스 간 통신

- InterProcess Communication
  - 병행 프로세스가 데이터를 서로 공유하는 방법
    - 공유 메모리 방법, 메시지 전달 방법
  - 하나의 운영체제에서 두 방법 함께 사용 가능
- 공유 메모리 방법
  - 동일한 변수: 공유자원인 메모리 공간 사용
  - 대량 데이터 교환: 고속 통신 가능
  - 통신산 발생 가능 문제 해결 → 응용 프로그래머 필요
- 메시지 전달 방법
  - 시스템 호출 send(). receive()
  - 소량 데이터 교환에 적합하고 통신상 발생 가능 문제에 대한 고민이 필요 없음, 운영체제가 알아서 처리
- 메시지 전달 방법의 논리적 구조
  - 통신 링크(메시지가 지나다니는 통로)의 구현 형태
    - 연결 대상: 두 프로세스, 셋 이상의 프로세스
    - 두 프로세스 사이의 링크 개수: 하나 혹은 둘 이상
    - 방향성: 단방향 or 양방향
    - 용량: 무한 or 유한 or 0
- 통신 링크의 용량
  - 무한 - 큐가 무한이라 송신자는 대기 없음
  - 유한 - 큐가 유한이라 송신자는 큐가 가득 차면 대기
  - 0 - 송신자는 수신자가 메시지를 받을 수 있을 때까지 대기(큐가 존재하지 않아서 바로 받아야 되는 구조)
- 직접통신
  - 두 프로세스가 직접 서로를 지정하여 메시지 전달
  - 오직 하나의 통신 링크가 자동 설정
  - 하나의 통신 링크는 오직 두 프로세스 사이에만 연관
  - 통신 링크는 양방향
  - 대칭형 주소 지정 or 비대칭형 주소 지정(수신자가 여러 송신자와 통신 링크를 갖는 경우)
- 간접통신

  - 프로세스 사이에 둔 우편함을 통해 메시지 전달
  - 같은 우편함이면 통신 링크가 설정, 여러 우편함을 이용하면 여러 개의 통신 링크 존재
  - 하나의 통신 링크가 여러 프로세스와 연관 가능
  - 통신 링크는 단방향 or 양방향

  # 6강. 교착상태 I

## 교착상태의 개요

- 프로세스의 자원 사용 절차
  - 요구 → 사용 → 해제
  - 요구과정에서 가용 자원 없으면 자원 획득할 때까지 대기
- 교착상태(deadlock)
  - 여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있어 어느 쪽도 영원히 진행하지 못하는 상태
- 교착상태와 기아상태의 차이
  - 교착상태는 영원히 멈춰 있으나, 기아상태는 언젠가 해소될 가능성이 있는 것

## 교착상태의 특성

- 교착상태의 필요조건
  - 상호배제
  - 점유대기
  - 비선점
  - 환형대기
- 상호배제(mutual exclusion) 조건
  - 프로세스가 자원에 대한 배타적 통제권을 요구하는 경우
- 점유대기(hold and wait) 조건
  - 프로세스가 이미 한 자원을 할당 받아 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는 또 다른 자원을 요구하여 해제되기를 기다리고 있는 상황
- 비선점(no preemption) 조건
  - 프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에는 해제되지 않음
  - 할당된 자원은 타의에 의해서는 해제되지 않음
- 환형대기(circular wait) 조건
  - 프로세스가 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 상황
- 교착상태의 필요조건 표현
  - 상호배제 - 하나의 할당간선
  - 점유대기 - 한 프로세스에 할당간선과 요구간선 연결
  - 비선점 - 요구간선
  - 환형대기 - 사이클(cycle)
- 자원할당 그래프
  - 사이클 없음 → 교착상태 없음
  - 사이클 있음 → 교착상태 발생 가능(했을 수도, 할 예정일 수도)
- 교착상태 처리기법
  - 교착상태 예방 - 네 가지 필요조건의 동시 만족을 피하고 발생하지 않도록 하는 방법
  - 교착상태 회피 - 자원의 최대량에 대한 정보를 이용해서 교착상태가 발생하지 않도록 하는 방법
  - 교착상태 탐지 및 복구 - 교착상태 체크 후 적절한 조치를 취해 복구하는 방법

## 교착상태 예방

- 상호배제 조건 제거
  - 공유할 수 없는 자원: 반드시 상호배제 필요 ex) 프린터 → 상호배제 조건 제거로 교착상태 예방 불가능
- 점유대기 조건 제거
  - 자원을 점유했을 때 대기하지 않도록 → 프로세스가 앞으로 필요 자원 모두를 처음 한꺼번에 요구하여 할당 받음 → 자원이용률 낮아짐, 기아상태 가능
  - 대기할 때 자원을 점유하지 않도록 → 새로운 자원 요구할 때 할당 받았던 자원 모두 해제, 점유 도중 해제할 수 없는 자원에는 적용 불가
- 비선점 조건 제거
  - 선점이 가능하도록 → 자원의 특성에 따라 불가능한 경우 존재 ex) 프린터
- 환형대기 조건 제거
  - 모든 자원에 일련번호를 지정
  - 방법 1 - 프로세스는 자원을 요구할 때 일련번호 기준으로 항상 오른차순이 되도록 요구
  - 방법 2 - 프로세스가 자원을 요구할 때 그보다 일련번호가 작은 자원만 점유하도록 함
  - 점유대기 중인 프로세스는 점유 중인 자원의 일련번호보다 대기 중인 자원의 일련번호가 큼 → 환형대기 발생 불가능

# 7강. 교착상태 II

## 교착상태 회피

- 안전상태와 안전순서열
  - 안전상태 - 교착상태를 회피하면서 각 프로세스에 그들의 최대 요구량까지 빠짐없이 자원 할당이 가능한 상태, 교착상태 회피 가능
  - 안전순서열이 존재하는 경우
  - 불안전상태 - 안전순서열이 존재하지 않는 경우, 교착상태 발생 가능성 있음
- 안전순서열
  - 순서 있는 프로세스의 집합
- 교착상태 회피
  - 교착상태는 불안정상태에서만 발생 가능
  - 항상 안전상태를 유지해야
  - 프로세스 가용상태의 자원을 요구하더라도 프로세느는 대기상태가 될 수 있음 → 자원이용률은 낮아질 수 있음
- 교착상태 회피 알고리즘
  - 각 자원의 단위 자원이 하나밖에 없는 경우
    - 변형된 자원할당 그래프
      - 자원을 요구 받으면 해당 선언간선을 요구간선으로 변경
      - 변경해도 사이클이 생기지 않는 경우에만 자원을 할당하고 할당간선으로 변환
  - 각 자원의 단위 자원이 여러 개일 수 있는 경우
    - 은행원 알고리즘
      - 자원을 요구 받으면 그 자원을 할당해주고 난 후의 상태를 계산해서 그것이 안전상태인지 확인
      - 안전 상태가 보장되는 경우에만 자원을 할당

## 교착상태 탐지 및 복구

- 교착상태 탐지 및 복구
  - 교착상태 탐지(상태 조사 알고리즘 수행) → 교착상태 복구
- 교착상태 탐지
  - Shoshani와 Coffman 알고리즘(현재 교착상태만 탐지)
- 교착상태 복구
  - 복구의 주체
    - 오퍼레이터 - 수작업으로 복구 / 운영체제 - 자동으로 복구
  - 복구 방법
    - 교착상태 프로세스를 종료
    - 교착상태 프로세스가 할당받은 자원을 해제
  - 교착상태 프로세스 종료 → 진행했던 내용에 대한 복원비용이 큼
  - 사이클이 제거될 때까지 교착상태 프로세스를 하나씩 종료 → 교착상태 재호가인을 위한 비용 필요
  - 할당 자원 해제 → 할당된 자원을 단계적으로 선점해서 다른 프로세스에 할당 → 프로세스 진척도, 사용 중인 자원의 수 등을 통해 자원 선택 기준 → 복귀시점도 제반 요소 고려해서 결정, 기아상태에 빠지지 않도록 프로세스 선택 시 복구 횟수 고려
