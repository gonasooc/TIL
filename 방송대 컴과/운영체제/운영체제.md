# 1강. 운영체제 소개

## 운영체제란 무엇인가

### 컴퓨터 시스템의 구성

- 운영체제 - 대표적인 시스템 소프트웨어, 컴퓨터 시스템 자원을 관리하고 프로그램 동작을 위한 서비스를 제공하는 프로그램들의 모음

### 운영체제의 역할

- 컴퓨터 시스템의 자원 관리 - 컴퓨터 시스템을 효율적으로 운영하는 목적
- 사용자 지원 - GUI 등 사용자 편의성 제공

### 컴퓨터 시스템과 운영체제

- 운영체제가 없던 초기의 컴퓨터 시스템
  - 응용 프로그램에서 직접 시스템의 자원 제어 → 즉, 개발자가 로우 레벨에서 개발해야 하기 때문에 하드웨어 제어 방법을 잘 알아야 함 ex) 몇 번 포트에 빛을 쏴준다거나
  - 여러 사용자가 하드웨어를 공유하는 경우 자원 분할 어려움
- 운영체제가 있는 컴퓨터 시스템
  - 하드웨어와 응용 프로그램 사이에 운영체제 위치
  - 여러 사용자의 자원 분배 및 제어 가능 → 안정적으로 효율적으로 동작 가능

### 커널 모드와 사용자 모드

- 커널 모드(슈퍼바이저 모드) - 하드웨어 직접 제어
- 사용자 모드 - 하드웨어 직접 제어 불가능
- 일체형 커널(monolithic kernel) - 운영체제의 모든 서비스가 커널 내에 포함
  - 커널 내부 요소들이 효율적 상호작용
  - 하나라도 오류가 발생하면 전체 장애 발생
  - ex) UNIX, Linux
- 마이크로커널(mircokernel) - 운영체제 요소 대부분을 커널 외부에 분리
  - 메모리 관리, 멀티태스킹 등 최소한의 요소만 커널 내 남김
  - 새로운 서비스 추가로 운영체제 확장 쉽고, 유지보수 용이하고 안정성이 우수함
  - 커널 외부 요소들 사이에 IPC(프로세스 통신)가 필요해서 성능 저하 발생
- 일반적으로 사용자 모드를 사용하다가 하드웨어에 대한 제어가 필요한 경우(**시스템 호출**) 커널 모드로 전환 → 제어가 끝나면 다시 사용자 모드로 전환

## 운영체제의 구성

- 컴퓨터 시스템 자원의 성격에 따라 구분
  - 프로세스 관리자, 메모리 관리자, 파일 관리자, 장치 관리자

### 프로세스 관리자

- 메모리에서 실행 중인 프로세스의 생성 및 삭제 등 관리, CPU 할당을 위한 스케줄링

### 메모리 관리자

- 메모리 할당 및 회수, 공간 보호(ex) OS가 사용하는 메모리 공간 보호) 등

### 장치 관리자

- 모든 장치에 대한 관리

### 파일 관리자

- 저장장치의 공간 관리 및 파일의 접근 제한 등 관리

## 운영체제의 유형

### 일괄처리 운영체제

- 작업을 모아서 순서대로 처리하는 방식
- 앞선 작업들을 기다려야 해서 상호작용 없이 기다려야 하는 비효율성 존재

### 시분할 운영체제(time-sharing)

- 대화형(interactive) 운영체제라고도 함
- 응답시간이 일괄처리 운영체제보다 크게 단축됨

### 실시간 운영체제(RTOS)

- 처리 결과가 현재의 결정에 영향을 주는 특수 목적의 환경에서 사용 ex) 미사일 제어 시스템, 증권거래 관리 시스템 등
- 우선순위가 높은 작업을 먼저 처리

### 분산 운영체제

- 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템

# 2강. 프로세스와 쓰레드

## 프로세스

- 프로세스(process): 실행 중인 프로그램 - 시스템 프로세스(백그라운드) / 사용자 프로세스
  - 프로그램: 동작을 하지 않은 정적, 수동적 개체
  - 프로세스: 동작을 하는 능동적 개체
- 운영체제로부터 자원 할당
  - 자원: CPU, 메모리, 입출력장치, 파일 등
  - 동작: CPU가 프로세스의 명령을 실행
- 운영체제는 프로세스를 실행 및 종료하고, 스케줄링하면서 관리
- 메모리 구조 - 코드 영역/데이터 영역
  - 코드 영역은 프로그램 자체
  - 데이터 영역(정적 데이터/스택/힙) - 실행 시 필요한 데이터, 상수나 변수, 서브프로그램 호출 상태 등
- 프로세스 제어 블록(Process Control Block: PCB) - 운영체제가 프로세스 관리를 위해 필요한 정보
  - 프로세스 번호(PID), 프로세스 상태, 프로그램 카운터(PC), 레지스터, 메모리 관리 정보, 프로세스 우선순위, 회계정보
- 프로세스 상태 관리
  - 생성 - 준비 - _대기_ - 실행 - 종료
- 프로세스 상태 변화
  - 생성 → 준비 →(디스패치)←(할당시간 만료) 실행 →(이벤트 대기) 대기 →(재개 조건 만족), 실행 → 종료
- 부모 프로세스와 자식 프로세스
  - 사용자가 직접 실행할 수도 있지만 한 프로세스가 다른 프로세스를 생성할 수 있음 → 프로세스 생성 시스템 호출 이용
  - 부모 프로세스는 그 시스템 호출을 하는 프로세스
  - 자식 프로세스는 시스템 호출을 통해 새로 생성된 프로세스
  - UNIX, Linux
    - fork() - 자식 프로세스는 부모 프로세스의 복제본(PID만 다르게 부여)
    - exec() - 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행(PID 외 데이터는 다 변동)
  - Windows
    - CreateProcess() - 자식 프로세스는 아예 애초에 새로운 프로그램으로 생성
- 프로세스 종료 방법
  - 프로세스가 모든 처리를 완료(정상 종료)
  - 부모 프로세스에 의해 자식 프로세스 강제 종료
    - 종료 시스템 호출 이용
    - 자식 프로세스 생성 시 얻은 자식 PID 이용
  - 부모 프로세스가 종료되면 자식 프로세스 같이 종료

## 쓰레드

- 쓰레드 - 프로세스 내에서 다중 처리를 위해 제안된 개념
- 하나의 프로그램 실행을 위한 기본적인 단위, 디스패칭의 단위
- 쓰레드는 실행에 필요한 최소한의 정보만 가짐
  - PC를 포함한 레지스터 값
  - 상태 정보
  - 스택 영역
  - 그 외 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유
- 다중 쓰레드로 구성된 프로세스
  - 멀티 CPU 또는 멀티코어 컴퓨터 시스템 - 다중 쓰레드로 병렬 처리 가능
  - 처리속도 별로 쓰레드가 나눠진 경우 - 효율적인 처리 가능

# 3강. 프로세스 스케줄링

## 프로세스 스케줄링

### 프로세스 스케줄링

- 주어진 프로세스가 여러 개인 경우 프로세스 처리순서를 결정하는 것

### 하위단계 스케줄링

- 준비 큐에 있는 프로세스를 선택하여 사용 가능한 CPU를 할당(디스패치)하는 역할
- 수행 주체: 디스패처(dispatcher)

### 스케줄링의 목표

- 일괄처리 운영체제 - 처리량의 극대화, 반환시간의 최소화, CPU 활용의 극대화
- 시분할 운영체제 - 빠른 응답시간, 과다한 대기시간 방지
- 실시간 운영체제 - 처리기한 맞춤

### 스케줄링 정책

**선점 스케줄링 정책(preemptive)**

- 실행 중인 프로세스 인터럽트 후 다른 프로세스에 CPU 할당
- 높은 우선순위의 프로세스 처리
- 문맥 교환에 따른 오버헤드
- 운영체제는 문맥 교환에 빠르게 실행되도록 만들어져야 함, 실시간 시스템/시분할 시스템

**문맥(context)**

- CPU의 모든 레지스터와 기타 운영체제에 요구되는 프로세스의 상태

**문맥 교환(context switching)**

- 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업

**비선점 스케줄링 정책(nonpreemptive)**

- 실행 중인 프로세스는 바로 준비상태로 전이 불가
- 대기나 종료 상태에서 전이될 때까지 계속 실행 상태에 있게 됨
- 강제 문맥 교환이 없어서 오버헤드 발생하지 않음
- 긴 프로세스가 실행 중이라면 짧은 프로세스가 오래 기다리게 됨

### 스케줄링의 평가 기준

- 평균대기시간과 평균반환시간

## 스케줄링 알고리즘

**FCFS(First-Come First-Served) 스케줄링**

- 비선점 방식
- 장점 - 가장 간단한 스케줄링
- 단점 - 짧은 프로세스 대기 시간 있음, 중요 프로세스 나중에 수행될 가능성, 프로세스들의 도착 순서에 따라 평균 반환 시간이 크게 변함, 시분할 운영체제나 실시간 운영체제에는 부적합

**SJF(Shortest Job First) 스케줄링**

- 비선점 방식
- 준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧다고 예상되는 거 먼저 디스패치
- 장점 - 일괄 처리 환경에서 구현 쉬움
- 단점 - 준비 큐가 기준이기 때문에 이미 실행 중인 프로세스가 있는 경우 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수 있음, CPU 시간을 예상하기 어려워서 스케줄링을 도입하는 것이 쉽지 않음

**SRT(Shortest Remaining Time) 스케줄링**

- SJF 알고리즘의 선점 방식
- 준비 큐 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 거 먼저 디스패치
- 장점 - SJF보다 평균대기시간, 평균반환시간에서 효율적
- 단점 - 역시 실제로는 프로세스의 CPU 시간을 예상하는 게 어려움(거의 불가능), 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼

**RR(Round Robin) 스케줄링**

- 선점 방식
- 기본적으로는 FCFS와 같지만 정해진 시간 할당량에 의해 실행 제한
- 시간 할당량 안에 종료하지 못한 프로세스는 준비 큐 마지막에 배치됨
- 장점 - CPU 독점 없이 공평, 시분할 운영체제에 적합
- 단점 - 시간 할당량이 너무 크면 FCFS와 다를 바가 없고, 시간 할당량이 너무 작으면 너무 많은 문맥 교환 발생으로 오버헤드가 커짐

**HRN(Highest Response Ratio Next) 스케줄링**

- 비선점 방식
- 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치
- 예상 실행 시간이 짧을수록 + 대기시간이 길수록 응답 비율이 커짐
- 장점 - SJF 스케줄링 단점 보완 - 오래 대기한 경우 응답 비율이 커져 나중에 들어오는 단순히 짧은 프로세스보다 먼저 디스패치 가능
- 단점 - 실제로는 프로세스의 CPU 시간을 예상하기 어려움

**다단계 피드백 큐 스케줄링**

- 선점 방식, Round Robin 확장 느낌
- 시간 할당량이 다 되면 다음 단계로 가면서 다른 시간 할당량 부여
- I/O 위주 프로세스는 높은 우선권 유지, 연산 위주의 프로세스는 낮은 우선권이지만 긴 시간 할당량

# 4강. 병행 프로세스 I

## 병행 프로세스의 개요

- 병행성
  - 여러 개의 프로세스 또는 쓰레드가 동시 수행되는 시스템의 특성
    병행 프로세스의 실행 형태
  - 1개의 CPU - 인터리빙 형식
  - 여러 개의 CPU - 병렬처리 형식
  - 멀티 프로세서 시스템에서의 메모리 구조에 따라 강결합 시스템(공유 메모리 구조)와 역결합 시스템(분산 메모리 구조)로 나눠짐
    **프로세스 간의 관계**
  - 독립 프로세스 - 수행 중인 다른 프로세스에 영향을 주지도 받지도 않음, 입력에 의해서만 결정되고 같은 입력에 대해 동일한 실행 결과
  - 협력 프로세스 - 수행 중인 다른 프로세스와 영향을 주고 받음, 실행결과는 실행순서에 좌우됨, 같은 입력에 대해 항상 동일한 실행결과를 보장하지 못함

## 병행성 문제

- 협력 프로세스인 경우 발생 가능한 문제 - 상호배제, 동기화, 통신
- 상호배제 - 2개 이상의 프로세스가 동시에 임계영역을 수행하지 못하도록 하는 것
  - 임계영역 - 2개 이상의 프로세스가 동시에 사용하면 안 되는 공유자원을 엑세스하는 프로그램 코드 영역
    - ex) A의 ATM과 B의 모바일 뱅킹을 사용할 때 임계영역
- 동기화 - 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것
  - 상호배제 또한 임계영역에 대한 동기화 문제라고 볼 수 있음
- 통신
  - 프로세스들이 데이터 공유하기 위해 필요, 프로세스 간 통신(IPC)
  - 하나의 변수 사용, 메시지를 주고 받음

## 세마포어

- 세마포어
  - 상호배제와 동기화 문제를 해결하기 위한 도구, Dijkstra가 제안
  - 정수형 공용변수 - 상황에 맞춰 0 이상인 정수로 초기화
  - 두 기본연산 P와 V에 의해서만 사용됨 - 인터럽트되지 않고 하나의 단위로 처리됨
  - 연산 P(검사, 감소시키려는 시도), 연산 V(증가)
  - 각각의 세마포어마다 대기 큐가 필요
- 상호배제와 동기화 해결

# 5강. 병행 프로세스 II

## 생산자-소비자 문제

- 생산자-소비자 문제 정의
  - 두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다루는 문제
    - 생산자 - 데이터를 넣는 프로세스
    - 소비자 - 데이터를 꺼내는 프로세스
- 생산자-소비자 문제 조건
  - 버퍼에 여러 프로세스가 동시에 접근할 수 없음 → 상호 배제 필요
  - 버퍼의 크기가 유한(유한 버퍼 문제) → 동기화 필요
- 세마포어를 이용한 해결

## 판독기-기록기 문제

- 판독기-기록기 문제 정의
  - 여러 협력 프로세스 사이에 공유자원을 두고 판독기와 기록기의 상황을 다루는 문제
    - 판독기 - 데이터를 읽는 프로세스(공유자원을 변경시키지 않음)
    - 기록기 - 데이터를 쓰는 프로세스(공유자원 변경)
- 판독기-기록기 문제 조건
  - 하나의 기록기가 공유자원에 데이터를쓰는 중에는 다른 기록기나 판독기는 공유자원에 접근할 수 없음 → 상호배제 필요
  - 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있고 문제 없음
  - 판독기가 읽는 중 기록기 대기 → 새로운 판독기 읽기 시도할 때 가능할지 불가능할지 정책적으로 결정 필요
- 제1판독기-기록기 문제
  - 판독기 우선 - 새로운 판독기는 즉시 공유자원 접근 가능
  - 문제점 - 기록기의 기아 상태 유발
- 제2판독기-기록기 문제
  - 기록기 우선 - 판독기가 공유자원에 접근 중이라면 판독기보다 기록기에 우선순위를 줌
  - 문제점 - 판독기의 병행성이 떨어지고 기아 상태 유발

## 프로세스 간 통신

- InterProcess Communication
  - 병행 프로세스가 데이터를 서로 공유하는 방법
    - 공유 메모리 방법, 메시지 전달 방법
  - 하나의 운영체제에서 두 방법 함께 사용 가능
- 공유 메모리 방법
  - 동일한 변수: 공유자원인 메모리 공간 사용
  - 대량 데이터 교환: 고속 통신 가능
  - 통신산 발생 가능 문제 해결 → 응용 프로그래머 필요
- 메시지 전달 방법
  - 시스템 호출 send(). receive()
  - 소량 데이터 교환에 적합하고 통신상 발생 가능 문제에 대한 고민이 필요 없음, 운영체제가 알아서 처리
- 메시지 전달 방법의 논리적 구조
  - 통신 링크(메시지가 지나다니는 통로)의 구현 형태
    - 연결 대상: 두 프로세스, 셋 이상의 프로세스
    - 두 프로세스 사이의 링크 개수: 하나 혹은 둘 이상
    - 방향성: 단방향 or 양방향
    - 용량: 무한 or 유한 or 0
- 통신 링크의 용량
  - 무한 - 큐가 무한이라 송신자는 대기 없음
  - 유한 - 큐가 유한이라 송신자는 큐가 가득 차면 대기
  - 0 - 송신자는 수신자가 메시지를 받을 수 있을 때까지 대기(큐가 존재하지 않아서 바로 받아야 되는 구조)
- 직접통신
  - 두 프로세스가 직접 서로를 지정하여 메시지 전달
  - 오직 하나의 통신 링크가 자동 설정
  - 하나의 통신 링크는 오직 두 프로세스 사이에만 연관
  - 통신 링크는 양방향
  - 대칭형 주소 지정 or 비대칭형 주소 지정(수신자가 여러 송신자와 통신 링크를 갖는 경우)
- 간접통신

  - 프로세스 사이에 둔 우편함을 통해 메시지 전달
  - 같은 우편함이면 통신 링크가 설정, 여러 우편함을 이용하면 여러 개의 통신 링크 존재
  - 하나의 통신 링크가 여러 프로세스와 연관 가능
  - 통신 링크는 단방향 or 양방향

  # 6강. 교착상태 I

## 교착상태의 개요

- 프로세스의 자원 사용 절차
  - 요구 → 사용 → 해제
  - 요구과정에서 가용 자원 없으면 자원 획득할 때까지 대기
- 교착상태(deadlock)
  - 여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있어 어느 쪽도 영원히 진행하지 못하는 상태
- 교착상태와 기아상태의 차이
  - 교착상태는 영원히 멈춰 있으나, 기아상태는 언젠가 해소될 가능성이 있는 것

## 교착상태의 특성

- 교착상태의 필요조건
  - 상호배제
  - 점유대기
  - 비선점
  - 환형대기
- 상호배제(mutual exclusion) 조건
  - 프로세스가 자원에 대한 배타적 통제권을 요구하는 경우
- 점유대기(hold and wait) 조건
  - 프로세스가 이미 한 자원을 할당 받아 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는 또 다른 자원을 요구하여 해제되기를 기다리고 있는 상황
- 비선점(no preemption) 조건
  - 프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에는 해제되지 않음
  - 할당된 자원은 타의에 의해서는 해제되지 않음
- 환형대기(circular wait) 조건
  - 프로세스가 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 상황
- 교착상태의 필요조건 표현
  - 상호배제 - 하나의 할당간선
  - 점유대기 - 한 프로세스에 할당간선과 요구간선 연결
  - 비선점 - 요구간선
  - 환형대기 - 사이클(cycle)
- 자원할당 그래프
  - 사이클 없음 → 교착상태 없음
  - 사이클 있음 → 교착상태 발생 가능(했을 수도, 할 예정일 수도)
- 교착상태 처리기법
  - 교착상태 예방 - 네 가지 필요조건의 동시 만족을 피하고 발생하지 않도록 하는 방법
  - 교착상태 회피 - 자원의 최대량에 대한 정보를 이용해서 교착상태가 발생하지 않도록 하는 방법
  - 교착상태 탐지 및 복구 - 교착상태 체크 후 적절한 조치를 취해 복구하는 방법

## 교착상태 예방

- 상호배제 조건 제거
  - 공유할 수 없는 자원: 반드시 상호배제 필요 ex) 프린터 → 상호배제 조건 제거로 교착상태 예방 불가능
- 점유대기 조건 제거
  - 자원을 점유했을 때 대기하지 않도록 → 프로세스가 앞으로 필요 자원 모두를 처음 한꺼번에 요구하여 할당 받음 → 자원이용률 낮아짐, 기아상태 가능
  - 대기할 때 자원을 점유하지 않도록 → 새로운 자원 요구할 때 할당 받았던 자원 모두 해제, 점유 도중 해제할 수 없는 자원에는 적용 불가
- 비선점 조건 제거
  - 선점이 가능하도록 → 자원의 특성에 따라 불가능한 경우 존재 ex) 프린터
- 환형대기 조건 제거
  - 모든 자원에 일련번호를 지정
  - 방법 1 - 프로세스는 자원을 요구할 때 일련번호 기준으로 항상 오른차순이 되도록 요구
  - 방법 2 - 프로세스가 자원을 요구할 때 그보다 일련번호가 작은 자원만 점유하도록 함
  - 점유대기 중인 프로세스는 점유 중인 자원의 일련번호보다 대기 중인 자원의 일련번호가 큼 → 환형대기 발생 불가능

# 7강. 교착상태 II

## 교착상태 회피

- 안전상태와 안전순서열
  - 안전상태 - 교착상태를 회피하면서 각 프로세스에 그들의 최대 요구량까지 빠짐없이 자원 할당이 가능한 상태, 교착상태 회피 가능
  - 안전순서열이 존재하는 경우
  - 불안전상태 - 안전순서열이 존재하지 않는 경우, 교착상태 발생 가능성 있음
- 안전순서열
  - 순서 있는 프로세스의 집합
- 교착상태 회피
  - 교착상태는 불안정상태에서만 발생 가능
  - 항상 안전상태를 유지해야
  - 프로세스 가용상태의 자원을 요구하더라도 프로세느는 대기상태가 될 수 있음 → 자원이용률은 낮아질 수 있음
- 교착상태 회피 알고리즘
  - 각 자원의 단위 자원이 하나밖에 없는 경우
    - 변형된 자원할당 그래프
      - 자원을 요구 받으면 해당 선언간선을 요구간선으로 변경
      - 변경해도 사이클이 생기지 않는 경우에만 자원을 할당하고 할당간선으로 변환
  - 각 자원의 단위 자원이 여러 개일 수 있는 경우
    - 은행원 알고리즘
      - 자원을 요구 받으면 그 자원을 할당해주고 난 후의 상태를 계산해서 그것이 안전상태인지 확인
      - 안전 상태가 보장되는 경우에만 자원을 할당

## 교착상태 탐지 및 복구

- 교착상태 탐지 및 복구
  - 교착상태 탐지(상태 조사 알고리즘 수행) → 교착상태 복구
- 교착상태 탐지
  - Shoshani와 Coffman 알고리즘(현재 교착상태만 탐지)
- 교착상태 복구
  - 복구의 주체
    - 오퍼레이터 - 수작업으로 복구 / 운영체제 - 자동으로 복구
  - 복구 방법
    - 교착상태 프로세스를 종료
    - 교착상태 프로세스가 할당받은 자원을 해제
  - 교착상태 프로세스 종료 → 진행했던 내용에 대한 복원비용이 큼
  - 사이클이 제거될 때까지 교착상태 프로세스를 하나씩 종료 → 교착상태 재호가인을 위한 비용 필요
  - 할당 자원 해제 → 할당된 자원을 단계적으로 선점해서 다른 프로세스에 할당 → 프로세스 진척도, 사용 중인 자원의 수 등을 통해 자원 선택 기준 → 복귀시점도 제반 요소 고려해서 결정, 기아상태에 빠지지 않도록 프로세스 선택 시 복구 횟수 고려

# 8강. 메모리 관리

## 프로세스와 메모리

- 프로세스의 동작
  - 프로그램 카운터(PC)를 참조하여 수행될 명령을 메모리에서 읽어 CPU로 수행하는 것
  - 캐시메모리 ↔ 메모리 ↔ 보조기억장치
- 기억장치 계층구조 - 적절한 비용으로 높은 성능을 내기 위해
  - CPU(레지스터) - 캐시 메모리 - 메모리 - 보조기억장치
  - ← 접근속도가 빠름, 비트당 기억장치 비용이 높음
  - → 대용량
- 메모리 관리
  - 메모리 호출 - 언제 새로운 프로세스를 메모리에 둘 것인가
  - 메모리 배치 - 다음 실행될 프로세스를 메모리 내 어느 곳에 둘 것인가
  - 메모리 교체 - 메모리가 꽉 찬 상태에서 프로세스를 메모리에 적재해야 한다면 어떤 프로세스를 제거할 것인가
  - 그 외 고정/동적 분할, 고정/유동 적재영역 등

## 단일 프로그래밍 환경

- 단일 프로그래밍 - 하나의 프로세스만 메모리를 전용으로 사용
- 단일 프로그래밍의 문제점
  - 메모리의 용량부터 큰 프로세스는 실행 못함
  - 메모리 낭비 심함 - 지속적으로 사용되지 않는 프로세스도 메모리에 계속 적재
- 주변장치 등 자원 낭비 심함 - 계산 위주일 때는 I/O가 쉬고 있고, I/O 위주일 때는 CPU가 놀고 있음

## 다중 프로그래밍 환경

- 다중 프로그래밍
  - 여러 개의 프로세스가 메모리에 동시 적재되는 것
  - CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가
- 메모리 분할 - 고정 분할
  - 여러 개의 고정된 크기의 영역으로 분할(ex) 분할1(25MB), 분할2(40MB), 분할3(60MB))
  - 분할영역마다 큐를 두고 큐에 들어온 프로세스는 해당 분할영역에만 적재
  - 프로세스 배치 방법 1 - 절대 번역 및 적재, 분할영역이 정해져 있어서 분할 영역이 놀고 있을 수 있기에 효율성 낮음
  - 프로세스 배치 방법 2 - 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할영역에든 적재, 재배치 가능 번역 및 적재, 복잡함(컴파일이나 주소에 대한 계산 등)
  - 문제점: 내부 단편화 - 프로세스 크기가 분할 영역의 크기보다 작아서 분할 영역 내에 남게 되는 메모리 발생 → 하나의 분할 속에서는 하나의 프로세스만 올 수 있기 때문에 남는 공간 활용 불가능(내부 단편화)
    - 수행할 프로세스의 크기에 맞춰 고정분할을 할 수도 있지만 현실성이 없음, 거의 불가능
- 메모리 분할 - 동적 분할
  - 문제점: 외부 단편화 - 메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김
    - 통합 - 인정된 공백을 더 큰 하나의 공백으로 만들어 외부 단편화 해결 → 멀리 떨어진 공백은 해소 방법 없음
    - 집약 - 메모리 내에 모든 공백을 하나로 모아 외부 단편화 해결 - 집약을 위해선 분할된 메모리들을 모아줘야 함 → 매번 할 순 없고 적당한 시점에 해줘야 비용적으로 가능함
- 메모리 보호 - 프로세스가 다른 할당영역을 침범하지 않게 하는 것

## 메모리 배치기법

- 메모리 배치기법
  - 동적 분할에서 새로 반입된 프로그램이나 데이터를 메모리 어디에 배치할 것인가 결정
  - 최초 적합, 후속 적합, 최적 적합, 최악 적합
- 최초 적합
  - 프로세스가 적재될 수 있는 빈 공간 중 가장 먼저 발견된 곳에 할당(첫 공백이 가용공간이 부족하다면 그 다음 공간)
- 후속 적합
  - 최초 적합의 변형, 이전 탐색이 끝난 그 다음 부분에 할당
- 최적 적합
  - 가능한 빈 공간 중 가장 작은 곳을 선택하여 할당
  - 큰 빈 공간을 최대한 많이 남겨놓기 위한 방법
- 최악 적합
  - 가능한 빈 공간 중 가장 큰 곳을 선택하여 할당
  - 애매한 작은 자투리 공간이 남아 사용하지 못하는 걸 최소화하기 위한 방법

# 9강. 가상 메모리

## 가상 메모리의 개념

- 연속 메모리 할당
  - 메모리 크기보다 더 큰 기억공간이 필요한 프로세스는 실행 불가
- 가상 메모리
  - 실제 메모리 크기보다 더 큰 기억공간이 필요한 프로세스도 실행할 수 있게 하는 방법
  - 프로세스 중 PC가 가리키는 부분만 메모리에 담는다면 처리 가능
  - 실행 중인 프로세스에 의해 참조되는 주소를 메모리에서 사용하는 주소와 분리
  - 현재 필요한 일부만 메모리에 적재
- 사상(mapping)
  - 프로세스 실행을 위해 가상 주소를 실주소로 변환하는 과정
  - 동적 주소변환(DAT): 프로세스가 실행되는 동안 사상
  - 인위적 연속성 - 가상주소 공간에서 연속적인 주소가 실주소 공간에서도 연속적일 필요가 없음

## 블록 단위 주소변환

- 주소 변환
  - 주소 변환 사상표 - 동적 주소변환을 위한 정보를 가진 표
  - 주소 변환이 바이트나 워드 단위로 이뤄지면 변환에 필요한 정보량이 너무 많아 비효율적임 → 그래서 블록 단위로 접근
- 블록 사상 시스템
  - 블록 단위로 주소 변환
  - 가상 메모리의 각 블록이 메모리의 어디에 위치하는지 관리
  - 가상 주소 v = (b, d) - b: 블록 번호, d: 블록의 시작점으로부터 변위
  - 블록의 크기는 적절히 정해야 함
    - 크기가 커질수록 → 사상표 크기 감소, 블록 전송시간 증가, 동시 적재할 프로세스 수 감소
    - 크기가 작아질수록 → 사상표 크기 증가, 블록 전송시간 감소, 동시 적재할 프로세스 수 증가
- 블록 구성방식
  - 페이지(page) - 블록의 크기가 동일
  - 세그먼트(segment) - 블록의 크기가 다를 수 있음
- 페이징 기법 - 동일한 크기의 페이지 프레임으로 나눔
  - 페이지 프레임: 페이지를 담을 수 있는 틀
  - 페이지 사상표(가상 주소를 실 주소로 동적 변환을 위함)
    - 페이지 번호에 대한 페이지 프레임 번호 저장
  - 직접사상에 의한 동적 주소변환 - 페이지 사상표를 직접 이용
  - 연관사상의 의한 동적 주소변환 - 페이지 변환 정보를 연관 메모리에 저장한 연관사상표를 이용
  - (연관 메모리를 고가이기 때문에) 연관/직접 사상에 의한 동적 주소변환
    - 연관사상표에는 가장 최근에 참조된 페이지만 보관
    - 연관사상표에 없을 때만 직접사상 이용
- 페이징 기법의 특징
  - 논리적 의미와 무관한 동일 크기의 페이지로 나눔, 메모리 보호는 페이지 단위로 이루어짐
  - 외부 단편화는 발생하지 않지만, 내부 단편화 발생 가능
- 세그먼테이션 기법
  - 가상 메모리르 세그먼트 단위로 나누어 관리하는 기법
    - 세그먼트: 논리적 의미에 부합하는 다양한 크기의 블록
  - 세그먼트 사상표
    - 세그먼트 번호에 대한 실주소에서의 시작 위치 저장
    - 세그먼트 길이는 오버플로 확인용
- 페이징/세그먼테이션 혼용기법
  - 세그먼테이션 기법의 논리적 장점 + 페이징 기법의 메모리 관리 측면의 장점
  - 가상 메모리를 세그먼트 단위로 분할 후 각 세그먼트를 다시 페이지 단위로 분할
  - 메모리는 페이지 프레임으로 분할

## 메모리 호출기법

- 메모리 호출기법
  - 어느 시점에 페이지 또는 세그먼트를 메모리에 적재할 것인가 결정하는 기법
- 요구 페이지 호출기법
  - 프로세스의 페이지 요구가 있을 때 요구된 페이지를 메모리에 적재
- 예상 페이지 호출기법
  - 곧 사용될 것으로 예상되는 페이지를 미리 메모리에 적재
- 메모리 호출기법 비교
  - 요구 페이지 호출기법 - 옮길 페이지 결정에 대한 오버헤드 최소화, 적재된 페이지는 실제 참조, 프로세스 시작 시점에는 연속적으로 페이지 부재 발생
  - 예상 페이지 호출기법 - 예상이 잘못된 경우 시간과 메모리 공간 낭비, 프로세스 시작 시점에 적용하면 성능 개선
