# 1강. 자료구조란 무엇인가

## 자료와 정보

- 자료의 가공 결과(정보)
    - 자료 → 컴퓨터 처리 → 정보
    - 자료의 가공이란 머신러닝 등 빅데이터 관련 처리 전에 필터링 및 보완하는 작업
- 자료 - 관찰과 측정을 통해 수집된 값이나 사실
- 정보 - 적절한 의사결정을 할 수 있게 해주는 지식, 처리 과정을 거친 2차 처리 결과물

## 추상화의 개념

- 자료의 추상화 - 물리적이고 전기적 동작과 무관하게 자료를 생각하고 바라보는 사람의 상상, 정수 그 자체를 머릿속의 그림처럼 떠올리는 것

## 자료구조와 알고리즘

- 자료구조 - 추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화
- 알고리즘 - (추상화된) 명령어의 연속된 덩어리
- 추상 자료형 - 자료구조와 알고리즘의 중간쯤에 있는 자료의 복잡한 논리적 성격을 정의하는 형식

## 알고리즘의 개념과 조건

- 알고리즘의 조건
    - 출력 - 알고리즘을 수행 후에는 적어도 한 가지 결과를 생성해야 함
    - 유효성 - 반드시 실행 가능해야 함
    - 입력 - 외부/내부 입력값은 유한해야 하며 반드시 입력 형태가 정의될 수 있어야 함
    - 명확성 - 각 명령들은 명확해야 함
    - 유한성 - 반드시 종료가 명확하게 정의되어야 함

## 알고리즘의 성능

- 알고리즘의 실행시간 분석 - 예측 실행시간을 추정, 알고리즘의 실행 횟수를 O(n)이라고 표현, 같은 O(n)를 가진다고 해서 같은 실행 시간을 갖는 것이 아니라 실행 시간의 유사한 증가 경향에 대한 표현 방법
- 알고리즘의 실행 메모리 분석 - 공간 복잡도(space complexity)는 프로그램을 실행 후 완료되는 데 필요한 총 메모리 공간
    - 고정 공간은 입출력 횟수나 크기에 관게 없이 컴파일 시 결정되어 실행이 끝날 때까지 고정적으로 필요한 메모리 공간
    - 가변 공간 - 실행 과정에서 동적 할당되는 자료 구조와 변수들을 위해 필요한 메인메모리 공간


# 2강. 배열

## 배열의 정의

- 배열의 정의 - 인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합
- 개발자가 인지하는 추상화된 인덱스값과 컴퓨터 내부의 물리적 주소값 사이에 실제 value가 있음

## 배열의 추상 자료형

- 추상자료형 - 자료 구조 구현 전 설계 단계
- 자료형 - 자료 구조의 구현 단계(프로그래밍 언어를 이용한 선언)

## 배열 연산의 구현

- 정의된 언어를 통해 구현하면 컴파일러를 통해 물리적 공간에 자료 할당
- e.g., a[i] = e; → 이 언어를 통해 컴파일러가 해석해서 값을 다시 할당함

## 1차원 배열

- 1차원 배열 - 한 줄짜리 배열로 하나의 인덱스로 구분
- A[i]의 메모리 저장 주소는 [a + i*k]가 됨

## 배열의 확장

- 행 우선 배열과 행 우선 할당을 통해 메모리 영역을 우선 할당
- 열 우선 배열과 열 우선 할당을 통해 메모리 영역을 우선 할당
- C언어에서의 2차원 배열(행 우선 순서 저장) - C언어에서 A[3][5]를 선언하면 다음과 같은 배열이 생성

## 희소행렬의 표현

- 희소행렬 - 원소값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많음
- 0인 원소는 저장하지 않고 0이 아닌 값만 따로 모아서 저장, 메모리 낭비를 막고 효율성 향상
- 메모리 성능은 좋으나 연산이 복잡함 → 연산을 별도로 정의해야 하기 때문에 연산의 복잡도나 시간이 늘어남


# 3강. 스택

## 스택의 개념

- 스택의 정의 - 객체와 그 객체가 저장되는 순서를 기억하는 방법에 관한 자료구조

## 스택의 추상 자료형

- StackIsFull과 StackIsEmptry 연산이 존재함

## 스택의 응용

- 변수 할당, 연산자 우선순위에 따른 계산 순서가 결정되는 수식 계산, 컴파일러, 순환 호출 관리 등

## 스택의 연산

- top— 에서 사용된 — 연산자의 위치에 따라 연산의 적용순서가 달라질 수 있음

## 사칙연산의 전위, 후위, 중위 표현

- 중위 표기법, 전위 표기법, 후위 표기법
- 중위 표기법인 사칙연산의 알고리즘을 통해 후위 표기법으로 변환하여 스택에 담는 과정

# 4강. 큐

## 큐의 의미

- 한쪽에서는 삽입연산만 발생, 다른 한쪽에서는 삭제 연산만 발생 가능, FIFO

## 큐의 응용

- CPU의 관리 방법
    - FCFS(First-Come First-Served) 스케줄링(또는 FIFO 스케줄링이라고도 함) 기법은 작업(프로그램)이 준비 큐에 도착한 순서대로 CPU를 할당받고 작업이 완료될 때까지 CPU를 사용하는 기법
    - RR(Round Robin) 스케줄링 기법은 대화형 시스템에 적합하며, 일정 시간(time slice)만 CPU를 사용하는 스케줄링 방식

## 원형 큐

- 배열의 문제점을 해결하기 위해 원형 큐 제안, 파이프의 입구와 출구 부분을 연결시킨 형태

# 출석수업

- **데이터(자료): 현실 세계에서 관찰이나 측정을 통해 수집된 값이나 사실**
- **정보: 적절한 의사결정을 수행할 수 있게 하는 지식**
- **I = P(D) 데이터를 처리하면 정보가 된다, 컴퓨터로 자료를 처리해서 유의미한 정보를 만들어낸다**
- 객관식 문제
- **자료구조의 정의 - 자료 사이의 논리적 관계를 컴퓨터나 프로그램에 적용하기 위해서는 자료의 추상화가 필요하며 추상화를 통해 자료의 논리적 관계를 구조화한 것을 자료구조라고 한다.**
- 알고리즘의 정의 - ‘라면 잘 끓이는 방법’ 등 어떠한 문제를 처리하는 순서나 과정을 묘사한 것을 알고리즘이라고 한다.
- **동일한 자료형을 갖는 여러 개의 데이터를 동일한 변수 이름의 방에 일렬로 저장하는 자료의 집합체는 배열**
    - 배열은 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 묶어 놓은 데이터의 집합체이며 각 원소는 인덱스와 데이터 값의 쌍으로 이루어진다
- **1차원 배열에서의 주소 계산 - 시작주소를 a를 기준으로 더해줌 a+3*k**
- **희소행렬은 원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많은 행렬이다.**
    - **배열 전체를 저장하게 되면 메모리 공간 낭비**
    - **행 갯수 / 열 갯수 / 0이 아닌 갯수**
- 스택과 큐의 개념
    - **스택: 데이터의 삽입과 삭제가 한쪽에서만 이루어지느 자료구조, 후입선출(LIFO), top 인덱스를 통해 삽입과 삭제가 이루어진다**
    - **큐: 한쪽에서는 데이터의 삭제만 이루어지고 다른 한쪽은 삽입만 이루어지는 자료구조, 선입선출(FIFO), rear와 front를 통해 삽입과 삭제가 이루어짐**
- **큐는 작업 스케줄링과 관련이 있음, 큐의 응용영역으로 적합한 것은 작업 스케줄링**
- **스택에서의 계산은 피연산자를 스택으로 모아두고, 연산자를 만나면 2개를 꺼내서 계산**

# 5강. 연결 리스트

## 리스트의 개념

- 배열과의 차이라면 리스트는 ‘일정한 순서’의 나열, 어떤 정의에 의한 ‘논리적인 순서’의 나열

## 배열을 이용한 리스트의 구현

- 배열의 확장 - 삽입을 위해선 원소값을 하나씩 뒤로 밀어야 하는 상황 발생, 연산 시간 증가, 비효율적인 컴퓨팅 성능 유발

# 6강. 연결 리스트의 응용

## 연결 리스트의 변형

- 단순 연결 리스트의 문제점 → 하나의 링크만 있고, 각각의 노드의 링크는 후행 노드만을 가리키는 구조, 후행 노드는 쉽게 접근할 수 있지만 선행 노드의 접근은 헤드 노드부터 재검색 필요
- 이중 연결 리스트 - 선행 노드를 가리키는 링크와 후행 노드를 가리키는 링크를 가짐
- 원형 연결 리스트 - 리스트의 마지막 원소 뒤에는 아무 원소도 없기 때문에 연결 리스트의 마지막 노드의 링크 필드는 언제나null, 마지막 링크 필드를 활용하면서 성느에 도움이 되도로 하기 위해 원형 연결 리스트 제안됨

## 원형 연결 리스트

- 원형 연결 리스트는 마지막 노드가 첫 번째 노드를 가리키는 특수한 형태의 연결 리스트, 이를 통해 리스트의 끝에서 시작으로 순환할 수 있는 구조 제공
- 특징
    - 마지막 노드의 링크가 null이 아닌, 첫 번째 노드의 주소를 가짐.
    - 헤드 노드가 리스트의 시작을 나타내며, 리스트 전체를 관리

## 이중 연결 리스트

- 양쪽 방향으로 순화할 수 있도록 링크 필드 두 개 필요, 시작점(head)도 두 개의 링크(Lhead, Fhead)가 필요
- 두 개의 링크 필드(Llink, Rlink)와 한 개의 데이터 필드

# 7강. 트리

## 트리의 개념

- 검색의 편리함, 논리적 계층, 계급적 특성

## 트리의 표현 방법

- 노드, 부모노드-자식노드
- 트리의 구성 - 루트 노드, 서브트리, 잎 노드
- 진입/진출 차수
    - 루트 노드 - 진입 차수 0
    - 루트를 제외한 모든 노드의 진입 차수 1
    - 잎 노드 - 진출 차수 0
- 트리의 깊이 - 트리 레벨에서 가장 큰 값에 1을 더한 것

## 이진 트리

- 모든 노드의 차수가 2 이하인 트리
- 가득 찬 이진 트리와 완전 이진 트리
- 배열을 이용한 이진 트리의 구현 → 트리가 완전 이진 트리 또는 가득 찬 이진 트리의 경우 낭비되는 공간이 없어 효율적
- 포인터를 이용한 이진 트리의 구현

## 이진 트리 연산

- 이진 트리의 전위 순회 - 루트노드 - 왼쪽 자식노드(왼쪽 서브트리) - 오른쪽 자식노드(오른쪽 서브트리)
- 이진 트리의 후위 순회 - 왼쪽 자식노드 - 오른쪽 자식노드 - 루트 노드
- 이진 트리의 중위 순회 - 왼쪽 자식노드 - 루트 노드 - 오른쪽 자식노드

# 8강. 스레드 트리

## 스레드 트리

- 이진 트리의 노드 순회 - 전위, 중위, 후외 순회
- 이진 트리의 노드를 순환 함수를 사용하지 않고 순회할 때 방문하지 않고 지나쳐 온 노드들은 스택에 저장하여 관리해야 하는 번거로움 발생
- 스레드 트리: ‘스레드’라는 포인터를 추가하여 트리 순화를 편리하게 한 것
    - 스레드: 순회 방법에 따른 방문순서를 유지하는 포인터

## 스레드 트리 구현

- 포인터 필드의 추가: 스레드를 저장하는 포인터를 추가하는 것
- 빈 포인터 활용 - 노드에 있는 사용하지 않은 포인터(빈 포인터)를 활용