# 1강. 자료구조란 무엇인가

## 자료와 정보

- 자료의 가공 결과(정보)
    - 자료 → 컴퓨터 처리 → 정보
    - 자료의 가공이란 머신러닝 등 빅데이터 관련 처리 전에 필터링 및 보완하는 작업
- 자료 - 관찰과 측정을 통해 수집된 값이나 사실
- 정보 - 적절한 의사결정을 할 수 있게 해주는 지식, 처리 과정을 거친 2차 처리 결과물

## 추상화의 개념

- 자료의 추상화 - 물리적이고 전기적 동작과 무관하게 자료를 생각하고 바라보는 사람의 상상, 정수 그 자체를 머릿속의 그림처럼 떠올리는 것

## 자료구조와 알고리즘

- 자료구조 - 추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화
- 알고리즘 - (추상화된) 명령어의 연속된 덩어리
- 추상 자료형 - 자료구조와 알고리즘의 중간쯤에 있는 자료의 복잡한 논리적 성격을 정의하는 형식

## 알고리즘의 개념과 조건

- 알고리즘의 조건
    - 출력 - 알고리즘을 수행 후에는 적어도 한 가지 결과를 생성해야 함
    - 유효성 - 반드시 실행 가능해야 함
    - 입력 - 외부/내부 입력값은 유한해야 하며 반드시 입력 형태가 정의될 수 있어야 함
    - 명확성 - 각 명령들은 명확해야 함
    - 유한성 - 반드시 종료가 명확하게 정의되어야 함

## 알고리즘의 성능

- 알고리즘의 실행시간 분석 - 예측 실행시간을 추정, 알고리즘의 실행 횟수를 O(n)이라고 표현, 같은 O(n)를 가진다고 해서 같은 실행 시간을 갖는 것이 아니라 실행 시간의 유사한 증가 경향에 대한 표현 방법
- 알고리즘의 실행 메모리 분석 - 공간 복잡도(space complexity)는 프로그램을 실행 후 완료되는 데 필요한 총 메모리 공간
    - 고정 공간은 입출력 횟수나 크기에 관게 없이 컴파일 시 결정되어 실행이 끝날 때까지 고정적으로 필요한 메모리 공간
    - 가변 공간 - 실행 과정에서 동적 할당되는 자료 구조와 변수들을 위해 필요한 메인메모리 공간


# 2강. 배열

## 배열의 정의

- 배열의 정의 - 인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합
- 개발자가 인지하는 추상화된 인덱스값과 컴퓨터 내부의 물리적 주소값 사이에 실제 value가 있음

## 배열의 추상 자료형

- 추상자료형 - 자료 구조 구현 전 설계 단계
- 자료형 - 자료 구조의 구현 단계(프로그래밍 언어를 이용한 선언)

## 배열 연산의 구현

- 정의된 언어를 통해 구현하면 컴파일러를 통해 물리적 공간에 자료 할당
- e.g., a[i] = e; → 이 언어를 통해 컴파일러가 해석해서 값을 다시 할당함

## 1차원 배열

- 1차원 배열 - 한 줄짜리 배열로 하나의 인덱스로 구분
- A[i]의 메모리 저장 주소는 [a + i*k]가 됨

## 배열의 확장

- 행 우선 배열과 행 우선 할당을 통해 메모리 영역을 우선 할당
- 열 우선 배열과 열 우선 할당을 통해 메모리 영역을 우선 할당
- C언어에서의 2차원 배열(행 우선 순서 저장) - C언어에서 A[3][5]를 선언하면 다음과 같은 배열이 생성

## 희소행렬의 표현

- 희소행렬 - 원소값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많음
- 0인 원소는 저장하지 않고 0이 아닌 값만 따로 모아서 저장, 메모리 낭비를 막고 효율성 향상
- 메모리 성능은 좋으나 연산이 복잡함 → 연산을 별도로 정의해야 하기 때문에 연산의 복잡도나 시간이 늘어남


# 3강. 스택

## 스택의 개념

- 스택의 정의 - 객체와 그 객체가 저장되는 순서를 기억하는 방법에 관한 자료구조

## 스택의 추상 자료형

- StackIsFull과 StackIsEmptry 연산이 존재함

## 스택의 응용

- 변수 할당, 연산자 우선순위에 따른 계산 순서가 결정되는 수식 계산, 컴파일러, 순환 호출 관리 등

## 스택의 연산

- top— 에서 사용된 — 연산자의 위치에 따라 연산의 적용순서가 달라질 수 있음

## 사칙연산의 전위, 후위, 중위 표현

- 중위 표기법, 전위 표기법, 후위 표기법
- 중위 표기법인 사칙연산의 알고리즘을 통해 후위 표기법으로 변환하여 스택에 담는 과정

# 4강. 큐

## 큐의 의미

- 한쪽에서는 삽입연산만 발생, 다른 한쪽에서는 삭제 연산만 발생 가능, FIFO

## 큐의 응용

- CPU의 관리 방법
    - FCFS(First-Come First-Served) 스케줄링(또는 FIFO 스케줄링이라고도 함) 기법은 작업(프로그램)이 준비 큐에 도착한 순서대로 CPU를 할당받고 작업이 완료될 때까지 CPU를 사용하는 기법
    - RR(Round Robin) 스케줄링 기법은 대화형 시스템에 적합하며, 일정 시간(time slice)만 CPU를 사용하는 스케줄링 방식

## 원형 큐

- 배열의 문제점을 해결하기 위해 원형 큐 제안, 파이프의 입구와 출구 부분을 연결시킨 형태

# 출석수업

- **데이터(자료): 현실 세계에서 관찰이나 측정을 통해 수집된 값이나 사실**
- **정보: 적절한 의사결정을 수행할 수 있게 하는 지식**
- **I = P(D) 데이터를 처리하면 정보가 된다, 컴퓨터로 자료를 처리해서 유의미한 정보를 만들어낸다**
- 객관식 문제
- **자료구조의 정의 - 자료 사이의 논리적 관계를 컴퓨터나 프로그램에 적용하기 위해서는 자료의 추상화가 필요하며 추상화를 통해 자료의 논리적 관계를 구조화한 것을 자료구조라고 한다.**
- 알고리즘의 정의 - ‘라면 잘 끓이는 방법’ 등 어떠한 문제를 처리하는 순서나 과정을 묘사한 것을 알고리즘이라고 한다.
- **동일한 자료형을 갖는 여러 개의 데이터를 동일한 변수 이름의 방에 일렬로 저장하는 자료의 집합체는 배열**
    - 배열은 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 묶어 놓은 데이터의 집합체이며 각 원소는 인덱스와 데이터 값의 쌍으로 이루어진다
- **1차원 배열에서의 주소 계산 - 시작주소를 a를 기준으로 더해줌 a+3*k**
- **희소행렬은 원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많은 행렬이다.**
    - **배열 전체를 저장하게 되면 메모리 공간 낭비**
    - **행 갯수 / 열 갯수 / 0이 아닌 갯수**
- 스택과 큐의 개념
    - **스택: 데이터의 삽입과 삭제가 한쪽에서만 이루어지느 자료구조, 후입선출(LIFO), top 인덱스를 통해 삽입과 삭제가 이루어진다**
    - **큐: 한쪽에서는 데이터의 삭제만 이루어지고 다른 한쪽은 삽입만 이루어지는 자료구조, 선입선출(FIFO), rear와 front를 통해 삽입과 삭제가 이루어짐**
- **큐는 작업 스케줄링과 관련이 있음, 큐의 응용영역으로 적합한 것은 작업 스케줄링**
- **스택에서의 계산은 피연산자를 스택으로 모아두고, 연산자를 만나면 2개를 꺼내서 계산**

# 5강. 연결 리스트

## 리스트의 개념

- 배열과의 차이라면 리스트는 ‘일정한 순서’의 나열, 어떤 정의에 의한 ‘논리적인 순서’의 나열

## 배열을 이용한 리스트의 구현

- 배열의 확장 - 삽입을 위해선 원소값을 하나씩 뒤로 밀어야 하는 상황 발생, 연산 시간 증가, 비효율적인 컴퓨팅 성능 유발

# 6강. 연결 리스트의 응용

## 연결 리스트의 변형

- 단순 연결 리스트의 문제점 → 하나의 링크만 있고, 각각의 노드의 링크는 후행 노드만을 가리키는 구조, 후행 노드는 쉽게 접근할 수 있지만 선행 노드의 접근은 헤드 노드부터 재검색 필요
- 이중 연결 리스트 - 선행 노드를 가리키는 링크와 후행 노드를 가리키는 링크를 가짐
- 원형 연결 리스트 - 리스트의 마지막 원소 뒤에는 아무 원소도 없기 때문에 연결 리스트의 마지막 노드의 링크 필드는 언제나null, 마지막 링크 필드를 활용하면서 성느에 도움이 되도로 하기 위해 원형 연결 리스트 제안됨

## 원형 연결 리스트

- 원형 연결 리스트는 마지막 노드가 첫 번째 노드를 가리키는 특수한 형태의 연결 리스트, 이를 통해 리스트의 끝에서 시작으로 순환할 수 있는 구조 제공
- 특징
    - 마지막 노드의 링크가 null이 아닌, 첫 번째 노드의 주소를 가짐.
    - 헤드 노드가 리스트의 시작을 나타내며, 리스트 전체를 관리

## 이중 연결 리스트

- 양쪽 방향으로 순화할 수 있도록 링크 필드 두 개 필요, 시작점(head)도 두 개의 링크(Lhead, Fhead)가 필요
- 두 개의 링크 필드(Llink, Rlink)와 한 개의 데이터 필드

# 7강. 트리

## 트리의 개념

- 검색의 편리함, 논리적 계층, 계급적 특성

## 트리의 표현 방법

- 노드, 부모노드-자식노드
- 트리의 구성 - 루트 노드, 서브트리, 잎 노드
- 진입/진출 차수
    - 루트 노드 - 진입 차수 0
    - 루트를 제외한 모든 노드의 진입 차수 1
    - 잎 노드 - 진출 차수 0
- 트리의 깊이 - 트리 레벨에서 가장 큰 값에 1을 더한 것

## 이진 트리

- 모든 노드의 차수가 2 이하인 트리
- 가득 찬 이진 트리와 완전 이진 트리
- 배열을 이용한 이진 트리의 구현 → 트리가 완전 이진 트리 또는 가득 찬 이진 트리의 경우 낭비되는 공간이 없어 효율적
- 포인터를 이용한 이진 트리의 구현

## 이진 트리 연산

- 이진 트리의 전위 순회 - 루트노드 - 왼쪽 자식노드(왼쪽 서브트리) - 오른쪽 자식노드(오른쪽 서브트리)
- 이진 트리의 후위 순회 - 왼쪽 자식노드 - 오른쪽 자식노드 - 루트 노드
- 이진 트리의 중위 순회 - 왼쪽 자식노드 - 루트 노드 - 오른쪽 자식노드

# 8강. 스레드 트리

## 스레드 트리

- 이진 트리의 노드 순회 - 전위, 중위, 후외 순회
- 이진 트리의 노드를 순환 함수를 사용하지 않고 순회할 때 방문하지 않고 지나쳐 온 노드들은 스택에 저장하여 관리해야 하는 번거로움 발생
- 스레드 트리: ‘스레드’라는 포인터를 추가하여 트리 순화를 편리하게 한 것
    - 스레드: 순회 방법에 따른 방문순서를 유지하는 포인터

## 스레드 트리 구현

- 포인터 필드의 추가: 스레드를 저장하는 포인터를 추가하는 것
- 빈 포인터 활용 - 노드에 있는 사용하지 않은 포인터(빈 포인터)를 활용

# 9강. 힙

## 우선순위 큐

- 우선순위 큐 - 대기 리스트에서 우선순위가 높은 사람이 먼저 서비스르 받는 구조
- 우선순위 큐의 작동 방식 - 삭제 명령이 실행되면 저장된 데이터 중 가장 작은 값(가장 큰 값)이 삭제 → 나머지 데이터들은 어떤 순서로 저장되든 문제가 되지 않음

## 힙 추상 자료형

- 힙 객체의 정의 - 부분적으로 정렬된 완전 이진 트리로 부모 노드는 자식 노드보다 우선순위가 높음
- 최소 힙 - 루트가 최소값을 가짐
- 최대 힙 - 루트가 전체 노드 중 최대값인 힙
- 힙이 아닌 경우 - 완전 이진 트리가 아니거나 부모가 자식보다 작지 않음

## 힙에서 삭제 및 삽입 연산

- 완전 이진 트리이기 때문에 배열로 구현해도 기억 장소 낭비가 없음

# 10강. 선택 트리, 숲, 이진 트리 개수

## 선택 트리

- 합병 정렬 - 차례로 이미 정렬된 k개의 데이터 목록을 순서를 유지하는 하나의 데이터 리스트로 만드는 과정
- 신택 트리를 통해 비교 횟수를 줄일 수 있음
- 승자 트리 - 작은 값이 승자가 되어 올라감, 루트의 값이 가장 작은 값이 되지만 승자 트리 재구성 시 다시 계산
- 패자 트리 - 루트 노드 위에 최상위 0번 노드를 가짐, 패자가 올라가고 승자를 같이 들고 있음, 재구성 시 용이함

## 숲

- 분리된 트리 모임, 0개 이상의 분리된 트리 집합
- 트리에서 루트(혹은 다른 노드)를 제거하면 숲을 구성할 수 있음, 반대로 숲을 연결하면 별도의 트리 생성 가능

# 11강. BS, Splay, AVL, BB

## 이진 탐색 트리

- 특정 데이터의 효과적인 검색을 위해 제한점을 가지는 이진 트리

## Splay, AVL, BB 트리

- 좋은 성능의 BS 트리 → 자주 탐색하는 키를 가진 노드를 트리의 루트에 가깝게 놓고, 트리가 균형이 되도록 유지
- Splay 트리 → 가장 최근에 사용한 노드 x가 트리의 루트에 올 때까지 Splay 연산을 반복 적용하여 생성된 이진 트리

# 12강. 멀티웨이 탐색 트리 (1)

## m원 탐색 트리

- 이진 탐색 트리 - 왼쪽과 오른쪽이라는 방향성을 가지며 다루기가 매우 편리함, 부모 노드 기준으로 왼쪽은 작은 데이터 노드, 오른쪽은 큰 데이터 노드
- 일반적으로 노드의 개수가 많아지면 트리의 높이가 커지게 됨 → 같은 개수의 노드에도 불구하고 트리의 높이를 높지 않게 유지할 수 있는 트리 자료구조가 필요
- BS 트리는 2원(2-way) 탐색 트리
- m원 탐색 트리 - 같은 수의 노드를 갖는 이진 트리보다 낮은 높이의 m원 트리, 탐색 트리의 제한을 따르면서 2개 이상 ~ m개 이하의 자식 노드를 가질 수 있음

## B 트리

- m원 탐색 트리는 서브 트리의 균형에 대해서는 특별히 제한하지 않음
- 각 노드가 자식을 많이 갖게 하여 트리의 높이를 줄이고 전체적인 균형을 유지한다면 탐색 성능을 더욱 향상할 수 있음
- m원 탐색 트리를 개선한 B 트리는 인덱스 구조를 구현하는 데 가장 일반적으로 사용

## B*, B+ 트리

- B* 트리의 정의 - 노드의 약 2/3 이상이 채워지는 B 트리, B 트리와 동일한 수의 노드를 갖는다면 높이가 낮고, 삽입/삭제 시 발생하는 노드 분리르 줄이려고 고안
- B+ 트리의 정의 - B+ 트리는 인덱스된 순차 파일을 구성하는 데 사용, 모든 키값이 잎에 있고 그 키값에 대응하는 실제 데이터에 대한 주소를 잎 노드만이 갖고 있음

# 13강. 멀티웨이 탐색 트리 (2)

## 2-3 트리

- 차수가 2 또는 3인 내부 노드를 갖는 탐색 트리
- 2-노드 혹은 3-노드라는 제약이 내부 노드에만 해당, 모든 잎 노드는 같은 레벨에 있어야 한다는 제약만 존재

## 2-3-4 트리

- 2-3 트리를 확장하여 4개의 자식을 가진 4-노드를 허용하는 탐색 트리
- 2-3-4 트리는 2-3 트리와 같은 특성을 가지면서 2-3트리보다 삽입과 삭제가 용이하고 효율적

## 레드 블랙 트리

- 효율적인 기억 장소 사용을 위해 2-3-4 트리를 이진 트리로 나타낸 탐색 트리

# 14강. 그래프 (1)

## 개념 및 용어

- 그래프 - 관계를 그래프로 추상화하여 다룰 수 있음
- 간선 - 두 정점을 연결하는 선
- 무방향 그래프는 간선의 방향성이 없고, 방향 그래프는 간선의 방향성이 있음
- 무방향 그래프의 간선은 실선, 방향 그래프의 간선은 화살표로 나타냄
- 다중 그래프 - 두 장점을 잇는 간선이 여러 개인 그래프, 방향 다중 그래프, 무방향 다중 그래프
- 가중 그래프 - 간선이 가중치를 갖는 그래프 e.g., 네비게이션
- 완전 그래프 - 모든 장점들이 간선으로 서로 연결된 그래프
- 독립 정점 - 다른 어떤 정점과도 인접한지 않은 정점
- 널 그래프 - 독립 정점만으로 구성한 그래프
- 경로(path) - 임의의 두 정점을 연결하는 어떤 간선의 끝 정점(해당 간선의 머리)에서 그 간선의 시작 정점(해당 간선의 꼬리)으로 이어지는 간선의 연속(열)
- 단순 경로 - 경로 상에 있는 모든 정점이 서로 다른 경로
- 기본 경로 - 경로 상에 있는 모든 간선이 서로 다른 경로
- 방향 그래프 - 사이클을 포함한 경로
- 사이클 - 출발점과 도착점이 동일한 단순 경로
- 무사이클 그래프 - 트리라고도 함

## 그래프 표현법

- 인접 행렬
- 인접 리스트

# 15강. 그래프 (2)

## 그래프 탐색

- 깊이 우선 탐색(DFS) - 스택을 사용하여 가장 최근 선택 지점에 있던 정점을 찾아냄
- 너비 우선 탐색(BFS) - 너비 우선 탐색은 인접 정점을 모두 방문하기 때문에 스택이 필요하지 않고, 대신 큐를 사용

## 최소 비용 신장 트리

- 트리 - 사이클이 없는 단순 그래프
- 트리는 그래프면서 루트를 가지기 때문에 계층 개념이 있고, 사이클이 없어서 한 정점에서 다른 정점으로 가는 경로가 유일한 구조
- 프림 알고리즘 - n개의 장점을 갖는 연결 그래프 G에 대한 최소 비용 신장 트리 T를 구하는 알고리즘
- 크루스컬 알고리즘 - 남은 간선 중 무조건 최소 비용인 간선을 선택한 후 사이클을 형성하지 않으면 그 간선을 선택함
- 솔린 알고리즘 - 간선이 하나도 없는 그래프의 모든 정점들로 구성된 숲에서 시작함