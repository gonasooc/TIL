### 형성평가 문제

- 원형 연결 리스트에 대한 설명으로 틀린 것은?
    - 단순 연결 리스트의 마지막 노드의 링크 필드가 단순 연결 리스트의 처음 노드를 가리키도록 하는 구조이다.
    - **단순 연결 리스트에 비해 추가적인 메모리 공간이 필요하다. → 원형 연결 리스트는 단순 연결 리스트와 동일하게 각 노드가 하나의 데이터 필드와 하나의 포인터 필드를 가지므로, 추가적인 메모리 공간이 필요하지 않습니다.**
    - 단순 연결 리스트에 비해 추가적인 메모리 공간이 필요하다.
    - 한 노드의 후행 노드를 직접 접근하면서도, 선행 노드도 접근할 수 있다.
- 지문 프로그램의 (가) 에 적합한 것은? → (listNode*)malloc(sizeof(listNode));
- 지문 프로그램의 (나) 에 적합한 것은? → H → head = NewNode;
- 트리의 최상위 노드 혹은 부모가 없는 노드는 무엇인가? → 루트노드
- 지문의 프로그램이 수행하는 트리 순회는 무엇인가? → 전위순회
    
    ```c
    struct node *root ;
    void preorder(node *root) {
      if (root != NULL) {
         printf("%c", root → info) ;
         preorder(root → left) ;
         preorder(root → right) ;
      }  }
    ```
    
    - 중위 순회 (in-order traversal)
        - 순서: 왼쪽 서브트리 → 현재 노드 → 오른쪽 서브트리
        - 코드와 일치하지 않습니다.
    - 후위 순회 (post-order traversal)
        - 순서: 왼쪽 서브트리 → 오른쪽 서브트리 → 현재 노드
        - 코드와 일치하지 않습니다.
    - 전위 순회 (pre-order traversal)
        - 순서: 현재 노드 → 왼쪽 서브트리 → 오른쪽 서브트리
        - 코드와 정확히 일치합니다.
- 다음 중 완전 이진 트리는 무엇인가? → 완전 이진 트리는 모든 레벨이 왼쪽에서 오른쪽으로 순서대로 채워짐, 가득 찬 이진 트리는 단순히 모든 노드가 0개 또는 2개의 자식 노드를 가지는 것을 요구하므로, 노드 배치 순서에는 제약이 없음
- 이진 트리의 노드 개수를 n이라 하면, 잎 노드의 사용하지 않는 포인터 필드의 개수는 모두 몇 개인가? → n+1
- 스레드 트리에 대한 설명으로 옳은 것은 무엇인가?
    - 중위순회에서 사용 가능한 스레드는 후위순회나 전위순회에서는 사용할 수 없다. → 스레드 트리는 중위순회, 전위순회, 후위순회 모두에 적용될 수 있습니다. 특정 순회 방식에 국한되지 않습니다.
    - 루트노드의 빈 포인터 필드를 활용한다. → 스레드 트리는 모든 노드의 빈 포인터 필드를 활용하며, 특정 노드(예: 루트)에만 적용되지 않습니다.
    - 잎 노드의 빈 포인터 필드를 활용한다.
    - 경우에 따라서 스택을 활용하여 순회 연산을 수행한다. → 스레드 트리의 목적은 스택이나 재귀 호출 없이 순회를 가능하게 하는 것입니다.
- 다음 그림의 스레드는 어떤 순회 방식은 무엇인가?
    - 전위 순회 - 부모 -> 왼쪽 자식 -> 오른쪽 자식
    - 중위 순회 - 왼쪽 자식 -> 부모 -> 오른쪽 자식
    - 후위 순회 - 왼쪽 자식 -> 오른쪽 자식 -> 부모
- 다음 설명으로 옳은 것은 무엇인가 ?
    - 우선순위 스택 : 대기 리스트에서 항상 우선순위가 높은 것을 먼저 처리하는 구조 → 우선순위 큐
    - 스택 : 먼저 들어간 데이터가 먼저 삭제되는 자료구조 → 나중에 삭제됨
    - 최대 힙 : 루트가 최소값인 힙 → 최대값인 힙
    - 배열을 이용한 힙의 구현은 완전 이진트리이기 때문에 배열로 구현해도 기억장소 낭비가 없음
- 지문은 무엇에 대한 설명인가? → 최대 힙
    
    ```
    트리의 모든 노드가 자식 노드보다 큰 값을 가짐 
     ⇨ 트리의 레벨에 따라 데이터가 순서를 갖지는 않음
     ⇨ 탐색 트리처럼 왼쪽, 오른쪽 노드 사이에 크기 제한도 없음
     ⇨ 루트가 가장 큰 값을 갖고 부모는 자식보다 큰 값을 가지면 됨
    ```
    
- 차례로 정렬된 데이터 리스트 k를 완전한 순서를 유지하는 하나의 리스트로 만드는 과정을 무엇이나 하는가 ? → 합병 정렬
- 각 노드가 두 개의 자식노드 보다 더 작은 값(승자)을 갖는 완전 이진트리는 무엇인가 ? → 승자 트리
- 빠르게 탐색할 수 있도록 구성한 이진트리는 무엇인가 ? → 이진 탐색 트리
- Splay 트리에 대한 설명은 무엇인가 ? → 자주 탐색하는 키를 가진 노드를 루트에 가깝게 위치하도록 구성한 이진 탐색 트리
- 트리의 무게는 무엇인가 ? → 트리에 속한 잎 노드의 개수
- 노드의 약 2/3 이상이 차야하는  B트리는 무엇인가 ? → B*트리
- 다음 중 m-원 멀티 트리의 조건이 아닌 것은 무엇인가 ? → 모든 단말 노드는 동일한 레벨에 놓인다. → 이 조건은 완전 m-원 트리(Complete m-ary Tree)의 조건입니다. 그러나 일반적인 m-원 멀티 트리에서는 반드시 모든 단말 노드가 동일한 레벨에 위치할 필요는 없습니다. 따라서 이 조건은 m-원 멀티 트리의 조건이 아닙니다.
- 다음 중  B트리에 대한 설명이 아닌 것은 무엇인가 ? → 노드의 약 2/3 이상이 채워진다. → 이건 B* 트리의 설명
- 2-노드와 3-노드만으로 구성한 트리로 B 트리 계열과 거의 같은 성능을 유지하면서 상대적으로 삽입 삭제가 용이한 트리는 무엇인가 ? → 2-3 트리
- 2-3-4 트리를 이진 트리로 나타낸 것으로 기억장소를 효율적으로 사용할 수 있도록 만든 트리는 무엇인가 ? → 레드 블랙 트리
- 2-3-4 트리에서 lchild, mchild 및 rchild를 각각 3-노드의 왼쪽, 좌중간 및 우중간 자식이라 하고 lkey, rkey를 이 노드의 키값이라 하면, 틀린 설명은 무엇인가 ? → ‘mkey < lkey’ 를 만족한다.
- 다음 중 설명이 틀린 것은 무엇인가 ? 인접 리스트: 그래프를 구성하는 행렬 → 인접 리스트는 행렬이 아니라 리스트 자료 구조를 사용하는 방식입니다. "행렬"이라는 설명이 부정확합니다.
- 다음 설명으로 틀린 것은 무엇인가 ? → 두 정점쌍이 간선을 여러 개 가질 수 있는 그래프를 다면 그래프라 합니다. → 두 정점쌍이 간선을 여러 개 가질 수 있는 그래프를 다중 그래프라 합니다, 다중 그래프에서는 같은 정점쌍을 연결하는 간선이 여러 개 존재할 수 있는 경우를 말합니다.
- 그래프의 모든 정점을 포함하는 사이클이 없는 부분 그래프중에서 비용이 최소인 그래프를 무엇이라고 하는가 ? → 최소 비용 신장 트리
- 그래프 순회 알고리즘의 하나로 특정 점정에서 시작하여 자손을 먼저 방문 한 후 (더 이상 방문 할 자손이 없으면) 전 단계 형제를 방문하는 탐색 방법을 무엇이라고 하는가 ? → 깊이 우선 탐색
- n개의 정점을 갖는 연결 그래프에 대한 최소 비용 신장 트리를 구하는 알고리즘이 아닌 것은  ? → 그래프 복귀 알고리즘