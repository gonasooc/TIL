# 1강. 리눅스 소개

## 유닉스와 리눅스

- 다중 사용자, 다중 작업 지원, 뛰어난 이식성, 네트워킹 기능, 셸 스크립트, 단순하고 모듈화된 설계 등
- 리눅스는 UNIX의 무료 공개 버전 - 초기에 리눅스는 PC용 운영체제로 개발되었음
- 최초의 UNIX
    - Multics - 1969년 assembly 언어로 작성된 최초의 시분할 운영체제
    - Unics → Unix - 작고 심플한 운영체제로 다시 작성, 1973년 대부분이 c언어로 다시 작성
- BSD 계열의 Free BSD, SunOS, GNU/Linux, System V 계열의 HP-UX(HP), AIX(IBM), Solaris(Oracle), 리눅스
- 리눅스의 등장
    - 1983년 GNU 프로젝트 - 리처드 스톨만이 UNIX와 유사한 공개 운영체제를 개발하기 위해 시작
    - 1985년 GNU 선언문 발표, 1989년 GPL 발표
    - 1991년 리눅스 커널 - 리누스 토르발스가 커널을 작성하여 발표, 커널은 하드웨어를 제어하고 응용 프로그램과의 상호작용을 제공하는 운영체제의 핵심

## 리눅스 개요

- 다중사용자-다중작업 지원, 뛰어난 이식성, 모듈화, CUI&GUI 지원, 공개된 소스코드
- 여러 종류의 파일 시스템을 지원 e.g. Minix, ext 계열, FAT, FAT32, NTFS, NFS, ISO-9660 등
- 효율적 하드웨어 활용과 다양한 응용 프로그램과 소프트웨어 개발 환경 제공

## 오픈소스와 라이선스

- 반대 개념은 proprietary(closed) 소프트웨어라고 함
- 리눅스의 라이센스
    - 주로 GPL(GNU General Public License), 일부는 LGPL(GNU Lesser General Public License), X window는 MIT
    - GNU GPL - 자유롭게 사용 및 복제 및 배포, 수정 배포 시 소스 코드 공개 필수, 저작권자를 표시하고 똑같이 GPL 조건으로 배포해야 함
- 강력한 카피레프트 조건을 절충한 것이 LGPL(소스 공개 여부 조정), MPL 코드를 포함하지 않은 파일은 공개 의무 없음
- BSD, Apache, MIT 라이센스 - 배포 시 소스코드 비공개 허용, Permissive 라이선스, 코드의 재사용을 높이려는 목적

## 리눅스 배포판

- 리눅스 커널 외에 시스템 유틸리티, 응용프로그램, 설치 프로그램을 포함한 완전한 운영체제
- 리눅스 커널은 1991년 처음 개발
- Debian 계열 - Debian, Ubuntu 등
- Slackware 계열 - Slackware, SUSE 등
- Red Hat 계열 - Redhat, Fedora, CentOS, Rocky Linux 등
- Debian 리눅스 - GNU 정신에 가장 충실한 배포판, GNU의 유일한 공식적 후원
    - stable, testing, unstable - 숫자 버전 외에 코드명을 가지며 unstable 버전은 항상 코드명이 sid
- Red Hat 리눅스 - 무료 버전은 2003년 지원 중단되었으나 Fedora와 CentOS라는 오픈소스 프로젝트가 지원
    - RPM(Red Hat Package Manager) - 바이너리 및 라이브러리 등 일괄 관리, 특정 패키지나 파일 검색, 의존성 유무 확인
- CentOS 리눅스 - Red Hat Enterprise Linux(RHEL) 기반의 무료 버전, 서버용으로 많이 사용, 최근 RHEL의 업스트림 버전인 CentOS Stream만 지원
- Rocky 리눅스 - 기존 CentOS 리눅스의 대체 제품
    - CentOS의 릴리스 정책이 변경되어 기존 CentOS의 대안이 필요, 그레고리 커처가 Rocky Linux 프로젝트 시작
- SuSE 리눅스 - 독일에서 만든 배포판, 유럽에서 많이 사용, Novell 사에 의해 지원, 유료와 무료 버전 존재
- Slackware 리눅스 - 가장 먼저 대중화된, 현존하는 가장 오래된 배포판, 간결함이 설계 철학, 유닉스 자체 학습에 적합
- Ubuntu 리눅스 - Denian 리눅스에서 파생, 영국 기업 Canonical 지원, 개인 사용자에게 인기 있는 리눅스 배포판 중 하나

# 2강. 리눅스 설치

## 저장 장치 이름과 표준 디렉토리

- 파티션 - 하드디스크를 논리적으로 나눈 구역, 별도의 파일 시스템을 만들 수 있음
    - 윈도우 - 각 파티션마다 각각의 드라이브 지정
    - 리눅스는 오직 1개의 루트 디렉터리만 가짐, 여타 파티션은 루트 파일 시스템의 특정 디렉터리에 마운트(부착)
    - 리눅스는 하드디스크나 주변 장치를 파일로 취급 - 거의 모든 걸 파일로 취급하여 다룸, 파일 입출력과 비슷하게 처리
- 장치 이름
    - IDE 디스크 - prefix로 hd, SCSI 디스크 - sd를 붙임 e.g., /dev/hda, /dev/sdb
    - 물리적 하드디스크가 추가될 때 알파벳 순서대로 함
    - 파티션 번호는 숫자 1부터 차례대로 붙임 e.g., /dev/hda1
    - CD 또는 DVD e.g., /dev/sr0
- 리눅스 표준 디렉터리
    - 루트 디렉터리 - 최상위 디렉터리, 파일 시스템의 바탕을 이루는 중요 디렉터리
    - 바이너리 디렉터리 - /bin, /sbin
        - 기본적인 명령의 실행 파일을 포함(/bin), 부팅 과정이나 시스템 관리에 필요한 명령의 실행 파일 포함(/sbin)
    - 부트 디렉터리 - /boot - 커널 이미지와 부트 로더의 설정 파일을 포함
    - 디바이스 디렉터리 - /dev - 장치를 접근하는 데 사용되는 ‘디바이스 파일’이 위치
    - 시스템 설정 파일 디렉터리 - /etc - 시스템의 중요한 환경 설정 파일
    - 사용자 계정 디렉터리 - /home - 사용자 계정의 홈 디렉터리가 만들어짐 e.g., /home/gonasooc
    - 공유 라이브러리 디렉터리 - /lib - 프로그램들이 사용하는 시스템 라이브러리 파일
    - 미디어 디렉터리 - /media - 이동식 저장 장치가 마운트될 때 마운트 지점을 제공
    - 시스템 정보 디렉터리 - /proc - 커널이 사용하는 가상 파일 시스템
    - 루트 계정의 디렉터리 - /root - root 계정의 홈 디렉터리
    - 사용자 디렉터리 - /usr
        - /usr/bin, /usr/sbin - 여러 가지 실행 파일
        - /user/include - 라이브러리 헤더 파일
        - /usr/lib - 실행 파일을 위한 사용자 라이브러리
    - 가변 자료 저장 디렉터리 - /var - 시스템 운영 중 필요한 가변 자료 저장, 시스템 작동 로그, 인쇄용 스풀 영역, 사용자 메일박스 등 e.g., /var/spool/client-

# 3강. 셸 사용하기

## 셸 개요

- 셸(Shell) - 명령어 해석기, 또는 명령 행 인터페이스, 사용자와 커널 사이 명령어 해석 처리, GUI로 하기 힘든 다양한 기능 수행
- 셸 스크립트를 통해 반복적으로 수행되는 작업을 셸 스크립트로 작성 가능, 셸이 셸 스크립트 파일을 읽어 처리 가능
- 기본적으로 한 개의 명령 입력 후 엔터를 눌러 명령 수행, 한 라인에 여러 명령 수행하려면 세미콜론(;)을 사용해서 순차적 처리 가능
- 많은 리눅스 배포판에서 Bash를 기본 셸로 사용
- 명령 프롬프트로 일반 사용자는 $, root 사용자는 #을 사용
- 셸 종류에 따라 에일리어스 설정, 초기화 파일, 셸 스크립트 작성법, 명렁 행 완성 기능, 명령 행 편집 기능 등 차이가 있음
- Bash 셸 - Bourne Again Shell로 Bourne 셸의 개선된 버전 - 많은 셸 스크립트의 문법이 Bourne 셸에 기반을 둠
- 셀 선택 가능 - chsh -s /bin/sh - 기본 셸 변경 가능
- 터미널 창을 대화형 셸이라고 함
- 로그인 셸과 비로그인 셸을 구별해야 함

## 셸 명령

- 명령어 옵션 인수 - 옵션과 인수는 여럿일 수 있고 선택적 또는 필수적
- 대기 명령어는 프로그램의 이름, 관리자 명령 또는 일반 사용자 명령 구분, 가장 간단한 형태의 실행은 명령의 이름만 사용 e.g., who, date, ls, pwd
- chsh 명령 - 기본 셸을 바꾸는 명령
- chsh [options] [username] - 대괄호는 생략가능, 이탤릭체는 적당한 내용으로 대체해야 함을 의미, 복수는 여러 개가 가능하다는 의미
- 짧은 옵션(-) → ls -l, ls -lat와 ls -l -a -t는 같은 것
- 긴 옵션(—) → ls —all → 긴 옵션에는 제대로 된 하나의 단어가 나옴
- ps a 처럼 대쉬가 붙지 않는 옵션도 있음
- 인수는 명령 수행 대상을 지정 e.g., cat -n /etc/passwd
- 옵션 자체도 인수를 가질 수 있음, 옵션에 인수를 제공할 땐 빈칸을 줘선 안됨
- 명령어의 종류
    - 에일리어스 - alias 명령을 통해 별칭 설정
    - 셸 예약어 - 예약된 단어로 do, while, case 등
    - 함수 - 셸에서 수행되는 함수의 정의
    - 내장 명령 - 셰 내부에 존재하는 명령 cd, echo, pwd 등
    - 일반 명령 - 실행 파일이 존재하는 명령
- alias 명령
    - e.g., alias la=’ls -A’; alias rm=’rm -i’
    - 계속 유지하려면 config에 별도 기록
    - 별칭 해제하려면 unalias
- type 명령 - 명령이 어떻게 해석되는지 알려주는 명령어 e.g, type cd; type -a ls
- which 명령 - 실행 프로그램을 환경변수 PATH를 기초로 찾아 경로 출력 e.g., which rm → where is 비슷한 명령어
- man 명령 - 메뉴얼 페이지를 보여줌, 사용법 또는 설정 파일 등 온라인 도움말
    - ls —help 처럼 간단한 도움말 가능

## 명령 히스토리

- history 명령 - 이전 수행했던 명령 행 1000개 출력, history 10을 통해 행수 제어 가능
    - 히스토리 기능을 이용해서 !!엔터 - 직전 명령 실행, !n엔터 - 히스토리 목록에서 해당 명령 실행, !string엔터 - 지정된 문자열로 시작하는 최근 명령 실행
    - 방향키 위 아래 직전 또는 직후 명령 불러옴
- 명령 행 완성 기능 - 처음 몇 자 입력 후 tab키 누르면 실행
    - 정보가 충분하지 않은 경우 tab 한번 더 누르면 모든 가능한 경우 보여주고 원래의 명령 행 유지

## 명령의 연결과 확장

- 백슬래시 - 특수 문자의 기능을 제거하는 이스케이프(escape) 문자 또는 긴 명령 행 분리할 때 사용
- 틸드(~) - ~ 또는 ~username은 사용자의 홈 디렉터리 의미
- 도트(.) - 현재 작업 디렉터리 표시
- 더블도트(..) - 현재 디렉토리의 부모 디렉터리
- 파운드(#) - # 문자 뒤에 나타나는 문자를 주석 처리
- 달러($) - $변수는 변수의 값을 추출
- 앰퍼샌드(&) - 명령&는 명령을 백그라운드로 실행
- 애스터리스크(*) - 0개 이상의 임의 문자열 대응
- 물음표(?) - 파일 이름에서 사용할 때 1개 문자와 대응
- 파이프(|) - 앞 명령의 출력을 다음 명령의 입력으로 연결
    - 명령1 | 명령2 e.g., cat /etc/passwd | sort | more
- < 또는 > - 입출력 리다이렉션에서, 즉 파일로부터 입력받을 때 또는 파일로 출력할 때 사용
- >> - 표준 출력을 파일의 끝에 덧붙일 때 사용
- 느낌표(!) - 명령 히스토리 기능을 이용할 때 사용
- 명령치환 - 명령을 수행할 때 명령의 인수로서 다른 명령의 결과를 사용
    - 두 단계로 처리할 명령어를 명령치환을 통해 한번에 처리 가능
    - ls -l $(which passwd
- 인용 부호
    - 작은따옴표는 특수 문자의 명령어로서의 의미를 제거하고 텍스트화
    - 큰따옴표 안에서는 특수문자의 의미를 해석하여 확장
    - 백슬래시는 특수문자 앞에서 특수 문자의 의미를 제거
- 수식과 변수의 확장
    - 명령 수행 전에 수식의 결과를 계산하여 전달 가능
    - $[수식] 또는 $((수식))
    - 명령 수행 전에 변수의 값을 추출하여 전달
    - echo “I am $[2023-1979] years old.”

## 셸 변수

- 셸 변수(지역 변수) - 변수가 정의된 셸에서만 사용 가능, 서브 셸로는 전달되지 않음
    - unset을 통해 삭제 가능
- 환경 변수(전역 변수) - printenv 명령을 통해 이미 설정된 환경변수 확인 가능, 변수 이름은 대문자, export -p 현재 셸의 존재하는 모든 환경 변수 출력
- 변수 설정과 환경 변수로 만드는 방법 - 변수=값;export 변수 또는 export 변수=변수
- echo $변수 는 모든 변수값을 확인할 수 있음

# 4강. 파일과 디렉터리

## 파일 시스템 탐색

- 파일 시스템 - 파일과 디렉터리의 집합을 구조적으로 관리하는 체계, 리눅스는 전체 파일 시스템을 1개의 트리 구조로 관리, 1개의 루트(/) 디렉터리만 있음
- ls [options] [names]
    - ls directory or ls file
    - 일반적으로 현재 폴더에서 ls 입력했을 때 나오는 건 ls .
- 파일의 종류
    - 정규 파일 - 실행 파일이나 이미지 파일의 경우 바이너리 형태로 저장되어 바이너리 파일이라고 함
    - 디렉터리 - 저장된 파일이나 하위 디렉터리에 대한 정보가 저장
    - 심볼릭 링크 - 소프트 링크라고도 하는데, 윈도우의 ‘바로가기’와 비슷
    - 장치파일 - 프린터, 하드디스크 등 각종 장치를 파일로 취급, 블록 디바이스 파일과 문자 디바이스 파일로 구분

## 파일과 디렉터리 관리

- mkdir -p backup/java - backup이 존재하면 하위에 java 디렉터리를 만들고, 없으면 backup이라는 parent까지도 생성
- rmdir -p dir1/dir2 - 부모 디렉터리가 비게 되는 경우 같이 삭제
- cp [options] file1 file2 - 파일이나 디렉터리 복사, 대상 파일이 존재하면 덮어쓰기 수행됨 → cp -i file1 file2 같이 interaction 옵션을 줘서 덮어쓰기 전 확인할 수 있게 가능
- cp [options] files directory → 마지막 인자가 디렉터리인 경우 여러 파일을 지정된 디렉터리에 같은 이름으로 복사
- mv [options] source target
- rm [options] files 파일을 삭제할 때 조심해야 함, alias rm=’rm -i’을 수행하여 에일리어스 설정하는 게 안전
    - -r 옵션은 디렉터리(포함된 파일과 서브 디렉터리)를 모두 함께 삭제
    - -i 옵션은 삭제 전에 물어봄
    - -f 옵션은 물어보지 않고 무조건 삭제
- 파일의 접근권한 - 읽기/쓰기/실행
    - 소유자(u)/그룹(g)/기타(o) - 이렇게 3개씩 끊어서 읽으면 됨
    - 읽기(r)쓰기(w)실행(x)
    - e.g., -rw-rw-r— → 앞에 - 이건 정규파일 케이스
- 디렉터리의 접근권한
    - 디렉터리에서의 실행 권한은 해당 디렉터리로 이동하거나 디렉터리의 정보 조회까지 포함됨
    - 즉, 적어도 읽기와 실행 권한을 갖고 있어야 디렉터리로 이동하거나 ls -l 명령 수행 가능
- chmod(change mode) - 파일 소유자가 파일의 접근권한 변경
    - chmod [options] mode files - -R 옵션을 디렉터리에 적용하면 포함된 모든 파일과 서브 디렉터리까지 권한을 변경
    - 8진수 모드로 작성 - chmod -R 755 dir1
    - 기호 모드를 작성 - chmod [ugoa][+-+][rwx]
- umask - 파일이나 디렉터리 접근권한의 기본값을 출력하거나 설정 - 8진수 기준
    - touch 명령어를 통해서 umask 값을 확인할 수 있음
    - 참고로 touch file 명령은 파일의 접근/수정 시간을 현재 시간으로 변경하며 파일이 존재하지 않으면 파일을 생성
- chown - root 사용자가 파일이나 디렉터리의 소유자 또는 소유 그룹을 변경하는 명령
    - chown [options] newowner files
- ln(link) - ln [options] 원본파일명 [대상파일명] - 기본적으로 하드링크를 만들며 -s 옵션을 사용하면 심벌릭 링크가 만들어짐
    - 하드링크 - 하나의 파일에 다른 이름을 부여, 원본 파일의 링크 카운트가 존재함, 다른 파일 시스템에는 링크할 수 없고 디렉터리에도 만들 수 없음
    - 심벌릭 링크 - 윈도우의 ‘바로 가기’와 비슷, 다른 파일 시스템 및 디렉터리 생성 가능, 원본을 삭제하면 심벌릭 링크는 의미가 없어짐

## 파일의 내용 확인

- more [options] files - 파일의 내용을 화면 단위로 출력하는 명령
- less - more 명령의 개선된 버전
- head [options] [files] - 파일의 맨 앞 부분을 출력 → 옵션 -n 숫자 또는 -숫자를 사용하면 보고 싶은 라인 수 변경 가능 e.g., head -n 5 /etc/passwd
- tail [options] [files] - 파일의 마지막 부분을 출력
    - tail -f /var/log/messages → 수시로 변경되는 파일의 경우 -f 옵션을 통해 감시 가능
- cat [options] [files] - 하나의 파일 또는 여러 파일을 연결(concatenate)시켜 출력