# 1강. 컴퓨터와 데이터 (1)

## 컴퓨터

- 데이터 처리기라기하기엔 계산기도 포함되는 등 너무 포괄적, 프로그램이 가능한 데이터 처리기

## 컴퓨터과학

- 데이터의 획득, 표현, 처리, 저장, 통신, 접근 등을 위한 방법들의 실행 가능성, 구조화, 표현, 기계화에 관련된 내용을 다루는 분야
- 데이터 → 컴퓨터 → 알고리즘 → 프로그램을 통해 처리
- 컴퓨터공학 - 하드웨어와 소프트웨어 요소의 조립에 중점, 컴퓨터과학 - 주어진 문제에 대한 해결책의 효율성과 실현 가능성에 중점

## 컴퓨터 시스템

### 하드웨어

- 폰 노이만 모델에서 제시한 4개의 서브시스템
- 모든 컴퓨터는 폰 노이만 모델에 기반을 두고 있음
- 기억장치 - 주기억장치, 보조기억장치
- 산술논리연산장치
- 제어장치
- 입출력장치

### 폰 노이만 모델의 주요 개념

- 내장 프로그램 stored program
    - “실행될 프로그램은 메모리에 저장되어야 한다.” → 초기 컴퓨터에서는 데이터만 메모리에 저장되고 프로그램은 컴퓨터 외부에 표현되는 방식
    - 프로그램과 데이터가 동일한 비트 패턴으로 표현
- “프로그램은 유한 개의 명령어의 나열이다.”
    - 미리 정의된 기본 명령어의 유한 개의 조합, 제어장치가 메모리에서 하나씩 명령어를 가져와서  해석 및 실행, 명령어의 재사용 가능

### 소프트웨어

- 시스템 소프트웨어 - 운영체제, 컴파일러 등 컴퓨터 전체적인 운영을 담당
- 응용 소프트웨어 - 사용자가 요구하는 작업을 직접 수행하는 프로그램

### 데이터

- 모든 데이터는 유형과 관계 없이 비트 패턴 형태로 표현

# 2강. 컴퓨터와 데이터 (2)

## 데이터의 정보

- 데이터와 정보의 관계 - I = P(D)
- bit(binary digit) → byte → word

## 문자 표현

- 키보드에서 입력되는 문자는 내부적으로 2진수로 표현되어 처리
- 각 문자마다 유일한 값으로써 코드를 할당할 수 있는 약속된 문자 체계가 필요 e.g., ASCII, 유니코드 등
- ASCII - American Standard Code for Information Interchange
    - 미국표준협회(ANSI) - 7비트 코드 - 128개의 서로 다른 문자 표현, 확장된 아스키 → 1비트 + 7비트
- 유니코드 - 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 표준
    - 언어에 무관하게 16비트 코드 체계
- EBCDIC, BCD ..

# 3강. 자료구조 (1)

## 기본 개념

### 자료구조의 개념

- 추상화 - 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것
- 자료(데이터) 추상화 - 데이터의 구조에 대해서 공통의 특징만을 뽑아 정의한 것
- 정수, 실수, 문자와 같은 기본 자료구조와 리스트, 스택, 큐 같은 사용자 정의 자료구조

## 배열

### 배열

- 하나의 변수의 각각의 인덱스를 통해 접근하는 편의성 - 동일한 자료형을 갖는 여러 개의 데이터를 동일한 변수명의 방에 일렬로 저장하는 자료 집합체
- 1차원 배열, 2차원 배열, 3차원 배열, 희소 행렬 ..

## 리스트

### 선형 리스트

- 순서 리스트(ordered list)
- 단일 연결 리스트, 이중 연결 리스트

## 스택과 큐

### 스택

- 선입후출(FILO)의 특징을 가짐

### 스택의 연산

- 스택 오버플로 - 삽입 연산 시 발생, 스택을 위해 할당된 저장 공간을 초과해서 더 이상 데이터 삽입할 수 없는 현상
- 스택 언더플로 - 삭제 연산 시 발생, 스택에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상

### 큐

- 선형 리스트의 한쪽 끝에서만 데이터의 삭제만 이루어지고 다른 한쪽 끝에서는 데이터의 삽입만 이뤄어지는 자료 구조
- 선입선출(FIFO)의 특징을 가짐


# 출석수업

- 데이터 → 정보 → 지식 → 지혜, 그 과정의 프로그래밍과 알고리즘의 컴퓨터 / I = P(D)
- n진수 → 10진수 ⇒ 가중치로 계산
- 10진수 → n진수 ⇒ 정수 부분을 n으로 나눔, 소수 부분은 n으로 곱한 값의 정수 부분만 정리
- ASCII → 미국표준협회(ANSI), 7비트 코드 → 128개의 서로 다른 문자 표현, 확장된 extended ASCII로 1비트 + 7비트인데 1비트는 오류 검사하는 패러티 비트로 사용
- 유니코드 → 세계의 모든 문자를 컴퓨터에서 일관되게 표현
- EBCDIC → IBM 개발, 8비트 코드 체계, IBM 메인프레임에서만 사용
- BCD → 4비트로 구성된 열 개의 코드로 10진수로 표현
- 선형 자료구조 - 리스트, 스택, 큐 / 비선형 자료구조 - 트리, 그래프
- 배열 A의 크기를 k라고 가정하고 시작 주소를 a라고 가정하면, A[i]의 저장 주소는 a+i*k가 됨
- 선형 리슬트의 경우는 배열과 포인터
- 배열을 통한 선형 리스트 구현의 단점은 삽입할 위치에 있는 원소와 그 다음의 원소들을 모두 한 칸씩 뒤로 이동해야 함
- 노드 간의 포인트 연결을 통해 구현하는 연결 리스트 같은 경우는 원소 값을 저장하는 데이터 필드와 노드 연결을 위한 링크 필드로 구성, 논리적 순서만을 가짐(즉, 메모리 상에서는 들쑥날쑥)
- 단일 연결 리스트는 선행 노드의 대한 접근은 헤드 노드부터 새로 시작해야 하지만, 이중 연결 리스트는 첫 번째 링크가 후행 노드를 가리키고 두 번째 노드가 선행 노드를 가리키기 때문에 후행 노드 뿐만 아니라 선행 노드에 대한 접근을 쉽게 제공할 수 있음
- 스택은 선입후출이기 때문에 포인트가 top을 바라봄, 삽입(push)과 삭제(pop)이 해당 위치에서 발생
- 스택 오버플로 - 삽입 연산 시 발생, 더 이상 할당할 공간이 없을 때 발생
- 스택 언더플로 - 삭제 연산 시 발생, 스택에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상
- 큐는 front와 rear의 구조로 선입선출의 특징을 가짐, 한쪽 끝에서는 삽입만-다른 한쪽에서는 삭제만 이뤄짐

# 4강. 자료구조 (2)

## 트리

- 비선형 자료 구조, 노드(node)와 노드가 가지(branch)로 구분됨
- 노드 사이에는 계층적 관계성을 갖고, 검색에 용이한 구조
- 트리 용어
    - 노드: 정보 항목
    - 루트: 빈 트리가 아닌 경우 맨 꼭대기에 있는 하나의 노드
    - 차수: 각 노드의 가지의 수
    - 잎 노드 = 단말 노드: 노드의 차수가 0인 노드
    - 내부 노드 = 비단말 노드: 루트 노드와 단말 노드를 제외한 나머지 노드
    - 조상(선조) 노드: 어떤 노드 X에서 루트 노드까지의 모든 노드
    - 자손(후손) 노드: 어떤 노드 X에서 단말 노드까지 모든 노드
    - 레벨: 루트 노드로부터의 거리(가지의 수)를 의미
    - 깊이: 루트 노드에서 가장 긴 경로에 있는 단말 노드의 레벨에 1의 값을 더한 것
    - 서브 트리: 특정 노드를 루트 노드로 하고, 그 아래에 연결된 구조의 트리
    - 숲: n개의 서브 트리를 가진 트리에서 루트 노드를 제거해서 얻을 수 있는 분리된 서브 트리의 집합

## 이진 트리

- 트리 중 차수가 2인 트리, 모든 노드는 초대 2개의 서브 트리를 가짐
- 각 서브 트리는 왼쪽, 오른쪽 서브 트리로 ‘순서’의 의미를 부여하는 경우가 존재하기 때문에 탐색할 때 활용
- 이진 트리 순회 연산
    - 전위 순회, 중위 순회, 후위 순회
- DLR(전위 순회; preorder)
    - 루트 노드 → 왼쪽 서브 트리 → 오른쪽 서브 트리
- LDR(중위 순회; inorder)
    - 왼쪽 서브 트리 → 루트 노드 → 오른쪽 서브 트리
- LRD(후위 순회; postorder)
    - 왼쪽 서브 트리 → 오른쪽 서브 트리 → 루트 노드
- 포화 이진 트리: 모든 내부 노드들이 2개의 자식 노드를 가짐
- 경사 이진 트리: 한 쪽 방향으로만 가지가 뻗어 나간 이진 트리

## 그래프

- 무방향 그래프: 간선의 방향성이 없음
- 방향 그래프: 두 정점을 연결하는 간석이 방향성을 가짐
- 두 정점이 간선으로 직접 연결되면 인접, 해당 간선은 두 정점에 부수되었다고 함, 경로: 간선으로 연결된 정점들의 순차적 나열
- 사이클은 세 개 이상의 정점을 가진 경로 중 시작 정점과 끝 정점이 같은 경로이고, 단순 사이클은 시작 정점과 끝 정점을 제외하고 모든 정점이 다른 사이클

## 그래프의 표현

- 컴퓨터는 그림을 이해할 수 없기에 인접행렬과 인접리스트로 저장
- 그래프의 탐색은 깊이 우선 탐색과 너비 우선 탐색으로 구분

# 5강. 알고리즘

## 알고리즘의 개념

- 입출력, 명확성, 유한성, 유효성 + 실용적 측면 - 효율적이어야 함
- 설계 → 표현/기술 → 정확성 검증 → 효율성 분석

## 알고리즘의 설계

- 분할정복 방법 - 문제의 입력을 더 이상 나눌 수 없을 때까지 2개 이상의 작은 문제로 순환적으로 분할하고, 각각 해결한 후 이들의 해를 결합하여 접근, 분할 → 정복 -⇒ 결합
- 동적 프로그래밍 방법 - 최적화 문제의 해(최댓값, 최솟값)를 구하기 위한 상향식 접근, 문제의 크기가 작은 소문제에 대한 해를 구해서 테이블에 저장해 두고 이를 이용하여 큰 문제의 해를 점진적으로 만들어 가는 방법
- 욕심쟁이 방법 - 각 단계에서 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 최적해를 얻을 것이라 희망하는 방법

## 알고리즘의 분석

- 알고리즘에서 수행되는 단위 연산의 수행 횟수를 모두 더한 값
- 점근성능 - 입력 크기 n이 충분히 커짐에 따라 결정되는 성능
- 점근성능의 표기법 - Big-oh, Big-omega, Big-theta

## 정렬 알고리즘

- 선택 정렬 - 정렬되지 않은 데이터 중 최솟값 선택, 첫 번째 원소와 교환 및 정렬, 데이터의 입력 상태에 민감하지 않아 언제나 동일한 수행 시간
- 버블 정렬 - 왼쪽에서부터 모든 인접 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우 자리를 바꾸는 과정 반복, 입력 데이터의 영향을 받음, 선택 정렬에 비해 데이터 교환이 많이 발생-비효율적
- 삽입 정렬

# 6강. 알고리즘(2)

## 정렬 알고리즘: 퀵정렬, 합병정렬

- 퀵 정렬 - 특정 데이터를 기준으로 입력 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 독립적으로 퀵 정렬을 순환적으로 적용
    - 피벗 - 두 개의 부분배열로 분할할 때 기준이 되는 데이터
    - 왼쪽과 오른쪽에 또 다른 순환적으로 피벗하면 정렬이 가능, 분할 과정이 피벗의 핵심
    - 성능
        - 분할 과정의 수행 시간 → O(n)
        - 평균 수행 시간 → O(nlogn)
        - 최선 수행 시간 → O(nlogn) - 피벗을 중심으로 항상 동일한 크기의 두 개의 부분배열로 분할되는 경우
        - 최악 수행 시간 - 피벗만 제자리를 잡고 나머지 모든 데이터가 하나의 부분배열로 분할되는 경우
- 합병정렬 - 동일한 크기의 두 개의 부분배열로 분할하고, 각 부분배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병해서 하나의 정렬된 배열을 만드는 방식
    - 합병 과정 - 정렬된 두 부분배열을 하나의 정렬된 배열로 만드는 과정
    - 분할 → 정복 → 합병
    - 최선, 최악, 평균 수행 시간 → O(nlogn)

## 순차 탐색, 이진 탐색

- 순차 탐색 - 처음부터 하나씩 차례대로 비교하여 원하는 데이터를 찾는 방법
    - 탐색 성능 - O(n)
    - 모든 리스트(배열, 연결 리스트)에 적용 가능, 데이터가 적거나 정렬되지 않은 경우에 적합
- 이진 탐색 - 정렬된 입력 배열에 대해서 주어진 데이터를 절반씩 줄여가면서 원하는 데이터를 찾는 방법
    - 탐색 방법 - 입력 배열의 가운데 값 A[Mid]과 탐색키 key를 비교
    - 성능 → O(logn) - 한 번 탐색할 때마다 탐색 대상이 되는 데이터의 개수가 1/2씩 감소

## 이진 탐색 트리

- 해당 노드의 왼쪽 서브트리는 그 노드의 키값보다 작고, 오른쪽 서브트리는 크다
- 탐색 연산 - 루트 노드에서 키값과 비교를 통해 왼쪽이나 오른쪽을 따라 이동하면서 탐색
- 삽입 연산 - 탐색이 실패한 위치에 새로운 노드를 자식 노드로 추가
- 삭제 연산
    - 자식 노드가 없으면 바로 삭제
    - 자식 노드가 1개면 자식 노드를 삭제되는 위치로 올리고 서브트리 전체도 올림
    - 자식 노드가 2개면 후속자 노드를 삭제되는 위치로 올리고, 후속자 노드를 삭제되는 노드로 취급하고 자식 노드의 개수에 따라 동일하게 처리
- 성능 - 트리의 높이 h → O(h), 경사 이진 트리는 최악 수행 시간 O(n)

# 7강. 운영체제(1)

## 운영체제의 개념

- 프로세서 관리자, 주기억장치 관리자, 장치 관리자, 파일 관리자의 역할 수행
- 프로세서 관리자의 역할 - 프로세스에게 프로세서(중앙처리장치-CPU)를 할당함
- 주기억장치 관리자의 역할 - 프로세스에게 주기억장치를 할당하고 프로세스로부터 할당된 주기억장치를 회수함
- 그 외 장치 관리자, 파일 관리자의 역할

## 운영체제의 작업 처리방식

- 일괄처리 시스템 - 모아져 있는 작업을 한꺼번에 처리하는 방식(batch processing system)
    - 효율은 좋으나 작업 결과를 빠르게 확인 불가능
- 다중프로그래밍 시스템 - 여러 개의 프로그램을 효율적으로 실행시키기 위해 컴퓨터의 여러 자원 관리
    - 주기억장치에 여러 개의 작업이 동시에 존재하면서 주변장치가 사용되는 동안 CPU를 다른 작업에 할당
- 시분할 처리 시스템 - CPU의 시간을 일정 간격으로 작은 시간으로 쪼개서 각 사용자에게 시간 간격이 할당되고 그 동안 컴퓨터와 대화식으로 작업을 수행

## 기억장치의 구성

- 레지스터 - 캐시 - 주기억장치 - 보조 기억장치
- CP와 주기억장치 사이의 속도 차이로 인한 지연 문제를 방지하기 위해 CPU와 주기억장치 사이에 주기억장치보다 빠른 속도의 기억장치인 캐시를 이용

## 주기억장치의 할당

- 단일 사용자 연속 기억장치 할당
    - 하나의 사용자 프로그램만이 전체 주기억장치에 할당, 구현이 쉽지만 큰 프로그램 수행 불가능
    - 유휴 자원 낭비, 대기 시간 길어짐
- 고정 분할 다중 프로그래밍 기법 - 고정된 크기의 영역으로 분할하고 실행 중인 여러 개의 프로세스에게 각각 할당
    - 단편화 발생으로 공간 낭비 발생
- 동적 분할 다중 프로그래밍 기법
    - 외부 단편화
    - 통합, 집약

## 가상기억장치

- 이용 가능한 영역보다 큰 프로그램을 작은 단위로 쪼개서 실행
- 실행 중인 프로그램(프로세스)에 의해 참조되는 주소(가상 주소)를 변환하여 주기억장치에 사용하는 주소(실 주소, 물리적 주소)로 연결
- 페이징 기법 - 동일 크기의 블록
- 세그먼테이션 기법 - 일정하지 않은 서로 다른 크기로 분할