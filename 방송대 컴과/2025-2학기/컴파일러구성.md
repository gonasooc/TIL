# 1강. 컴파일러란?

## 컴파일러의 개념과 번역기의 종류

- 컴파일러는 번역 후 실행, 인터프리터는 번역과 실행(한줄 번역하고 실행)
- 기억장치의 차이, 사용자와 대화식 진행 가능 여부의 차이
- 어휘 분석, 구문 분석, 의미 분석
- 중간코드, 최적화, 목적 코드 - 중간 코드는 최적화를 위해

## 컴파일러의 논리적 구조

- 어휘 분석: 어휘 문법 맞는지 분석 → 어휘 토큰 변환 → 연산자, 식별자, 예약어, 구분자, 상수 → 어휘 분석
- 구문 분석: 구문 문법 맞는지 분석 → 분석 결과를 파스트리로 출력 → 구문 분석
- 의미 분석: 파스트리에 의미 부여
- 중간 코드: 최적화를 위한 중간단계

## 컴파일러의 물리적 구조

- 중간 코드 생성까지를 1패스, 최적화 이후부터 2패스
- 1-패스 컴파일러 - 효율적이고 실행 속도 빠름
- 2-패스 컴파일러 - 기계독립적, 이식성이 좋음, 최적화에 용이함

## 간단한 컴파일러 실행 예

-

## 최적화

-

# 2강. 형식언어와 형식문법

## 형식언어의 기초

- 알파벳 < 문자열 < 형식언어
- 공문자열: 기호들이 0개 나열

## 형식문법

-

## 문법의 4종류

- type 0 - 위축형 문법 포함
- type 1 - 비위축형 문법
- type 2 - Context Free Grammar 구문분석
- type 3 - 정규문법, 어휘분석

# 3강. 유한오토마타

## 유한 오토마타

- 어휘 분석기 역할을 하기 위한 수학적 모델 - 문자열이 올바른 언어의 문장인지 판단
- 첫 자는 영자, 다음 부터는 영자와 숫자의 조합

## 정규표현과 유한오토마타

- 클로저가 있는 a*는 앱실론의 존재 때문에 바로 종료될 수도
- 유한오토마타의 단순화

## NFA와 DFA의 동치관계

- DFA와 NFA는 서로 동등하다. NFA가 더 크기 때문에 NFA가 DFA임을 증명해주면 됨

## ε-전이 NFA → DFA 증명

- ε-closure

## 두 개 이상의 상태전이 NFA

-


# 6강. Context-free 문법의 효율화

## Context-free 언어

- -

## 유도트리

- 대문자 논터미널 기호가 유도될 수 있고 소문자 터미널 기호는 유도 불가능

## 모호성

-

## 불필요한 생성규칙 제거

- 터미널 기호를 생성할 수 없는 논터미널 기호
- 시작 기호로부터 도달 불가능한 기호

## ε- 생성규칙의 제거

-

## 단일 생성규칙 제거

-

## Backtracking과 Left-factoring

- 같은 prefix를 갖는 생성 규칙들이 존재
- 공통 prefix를 인수분해(LEeft-Factoring)

## Left-recursion 제거

-

# 7강. 구문분석 개요

- 최근엔 Bottom-up 구조를 가장 많이 사용
- FIRST - 논터미널을 제외한 첫번째 터미널 기호가 나올 때까지
- FOLLOW - A 뒤에 나오는 터미널 기호들, 시작 기호 $ 주의

# 8강. 순위관계에 의한 구문분석

- Shift-Reduce 구문분석
- 단순순위 구문분석
- LR구문분석