# 1강. 컴파일러란?

## 컴파일러의 개념과 번역기의 종류

- 컴파일러는 번역 후 실행, 인터프리터는 번역과 실행(한줄 번역하고 실행)
- 기억장치의 차이, 사용자와 대화식 진행 가능 여부의 차이
- 어휘 분석, 구문 분석, 의미 분석
- 중간코드, 최적화, 목적 코드 - 중간 코드는 최적화를 위해

## 컴파일러의 논리적 구조

- 어휘 분석: 어휘 문법 맞는지 분석 → 어휘 토큰 변환 → 연산자, 식별자, 예약어, 구분자, 상수 → 어휘 분석
- 구문 분석: 구문 문법 맞는지 분석 → 분석 결과를 파스트리로 출력 → 구문 분석
- 의미 분석: 파스트리에 의미 부여
- 중간 코드: 최적화를 위한 중간단계

## 컴파일러의 물리적 구조

- 중간 코드 생성까지를 1패스, 최적화 이후부터 2패스
- 1-패스 컴파일러 - 효율적이고 실행 속도 빠름
- 2-패스 컴파일러 - 기계독립적, 이식성이 좋음, 최적화에 용이함

## 간단한 컴파일러 실행 예

-

## 최적화

-

# 2강. 형식언어와 형식문법

## 형식언어의 기초

- 알파벳 < 문자열 < 형식언어
- 공문자열: 기호들이 0개 나열

## 형식문법

-

## 문법의 4종류

- type 0 - 위축형 문법 포함
- type 1 - 비위축형 문법
- type 2 - Context Free Grammar 구문분석
- type 3 - 정규문법, 어휘분석

# 3강. 유한오토마타

## 유한 오토마타

- 어휘 분석기 역할을 하기 위한 수학적 모델 - 문자열이 올바른 언어의 문장인지 판단
- 첫 자는 영자, 다음 부터는 영자와 숫자의 조합

## 정규표현과 유한오토마타

- 클로저가 있는 a*는 앱실론의 존재 때문에 바로 종료될 수도
- 유한오토마타의 단순화

## NFA와 DFA의 동치관계

- DFA와 NFA는 서로 동등하다. NFA가 더 크기 때문에 NFA가 DFA임을 증명해주면 됨

## ε-전이 NFA → DFA 증명

- ε-closure

## 두 개 이상의 상태전이 NFA

-