# 1강. 데이터베이스의 이해

## 01. 데이터베이스의 역할

### 데이터 관리의 필요

- 대량의 데이터를 저장 및 관리하고 필요한 데이터를 **신속히** 검색할 수 있도록 보조하는 장치

### 전통적 데이터 관리 방식

- 학적업무, 성적업무, 수강업무 개별로 관리 → 파일 처리 시스템

### 파일 처리 시스템(file processing system)

- 데이터베이스가 개발되기 전에 데이터 관리에 사용
- 업무별 애플리케이션이 개별 데이터를 데이터 파일에 저장, 관리하는 시스템
- 발생 가능한 문제
  - 데이터 종속의 문제
  - 데이터 중복의 문제
  - 무결성 훼손의 문제
  - 동시 접근의 문제

### 데이터 종속의 문제

- 물리적 데이터 종속
  - ex) 신규 디스크에 이어서 저장하려고 해도 기존 디스크에 종속성이 있어서 불가능
- 논리적 데이터 종속
  - 데이터를 표현하는 논리적 구조를 바꾸는 것이 어려움

### 데이터 중복의 문제

- 일관성 훼손 → 한 개의 데이터를 바꾸더라도 중복된 데이터까지 변경해줘야 하는 문제 있음
- 보안성 훼손 → 중복된 데이터를 같은 수준의 보안 유지하기 어려움, 중복
- 경제성 훼손 → 데이터 저장의 불필요한 리소스 생김

### 무결성 훼손의 문제

- 파일 처리 시스템은 데이터 범위를 지정하고 유지 관리할 기능이 없어서 무결성 훼손 가능성 높음

### 동시 접근의 문제

- 동일 데이터에 다수 사용자의 접근 허용 시 일관성 훼손(ex) 은행 잔고)

## 02. 데이터베이스의 특징

### 데이터베이스 사용의 의미

- 데이터 사용의 영역과 데이터 관리(디스크) 중간에 데이터베이스를 경유

### 데이터베이스 시스템의 구성

- 사용자나 프로그래머가 DBMS를 통해 접근했을 때 저장된 데이터베이스 정의(메타데이터)와 저장된 데이터베이스 별도로 접근

### 값, 데이터, 메타데이터

- 값이 설명과 함께 하나의 데이터가 만들어질 때 그 설명이 별도의 메타데이터가 될 수 있음 ex) 오늘, 12도, 낮 최고기온

### DBMS의 3단계 구조

- 뷰와 외부 스키마(외부 단계) - 개념 스키마(개념 단계) - 내부 스키마(내부 단계)
- 각 단계는 별도의 맵핑으로 연결되어 있음

### 다수 사용자 트랜잭션 처리

- 트랜잭션의 정의 - 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합 ex) Read(A) + Write(A) 묶어서 트랜잭션으로 처리하고 그 트랜잭션이 처리되기 전에는 데이터 접근 불가 처리

## 03. 데이터베이스의 구성요소

- DDL: Data Definition Language - 데이터베이스 객체를 생성, 수정. 삭제하기 위한 언어
- DML: Data Manipulation Language - 구조화된 데이터에 사용자가 접근 및 조작할 수 있도록 지원하는 언어(검색, 삽입, 삭제, 수정)

### 데이터베이스 시스템 아키텍처

- 중앙집중식 방식 - 단일 서버 + 클라이언트 장치를 대신해서 작동
  - 과부하로 전체적인 성능 저하 단점
- 분산 시스템 방식
  - 클라이언트 장치의 성능 향상으로 클라이언트 - 서버 데이터베이스 시스템 구조로 부하 분산
  - 2계층 구조 - 애플리케이션 클라이언트 - 데이터베이스 시스템
  - 3계층 구조 - 애플리케이션 클라이언트 - 애플리케이션 서버 - 데이터베이스 시스템

# 2강. 데이터베이스 모델링

## 01. 데이터베이스 모델링의 이해

### 데이터 모델

- 사용할 데이터를 선별하여 데이터베이스에 체계적으로 구주화하여 저장, 사용할 방법이 필요
- 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합

### 데이터베이스 모델링의 단계

- 개념적 데이터 모델링 → 비즈니스적인 관점에서 고민
- 논리적 데이터 모델링 → 기술적인 고민, 실제 기술 구현

## 02. 사용자 요구사항 분석

## 03. ER 모델

- 실세계의 속성들로 이루어진 개체(entity)와 개체 사이의 관계(relationship)를 정형화 시킨 모델
- 데이터 구조와 관계를 ER 다이어그램(ERD)으로 표현
- 개체(entity) → 개체 집합(entity set), 관계 집합(relationship set)

### 연습문제

- 사용할 데이터를 선별하고 데이터베이스에 체계적으로 구조화하여 저장·사용할 방법을 정의할 수 있도록 데이터의 의미, 데이터 타입, 연산 등을 명시하기 위한 개념들의 집합 → 데이터 모델
- 사용자 요구사항 분석 과정: 요구사항 도출 → 요구사항 분석 → 요구사항 기록

# 3강. 관계형 모델

## 관계형 모델

- 릴레이션의 구성 - 릴레이션, 컬럼, 속성, 필드, 스키마, 레코드, 투플, 컬럼값, 인스턴스 ..
- 릴레이션의 특징 - 레코드의 유일성, 레코드의 무순서성, 컬럼의 무순서성, 컬럼값의 원자성
- 키(key)의 역할 - 릴레이션의 레코드를 유일하게 식별하는 값
- 키의 속성 - 유일성(Uniqueness), 최소성(Irreducibility)
- 키의 종류
  - 수퍼키(super key): 유일성 만족
  - 후보키(candidate key): 유일성, 최소성 만족
  - 기본키(PK: primary key): 레코드의 구분을 위해 선택된 후보키
  - 외래키(FK: foreign key): 참조된 다른 릴레이션의 기본키
- 키의 참조 - 두 릴레이션에 포함된 레코드 간 연관성을 표현하고자 할 때 외래키가 사용됨
- 널(null)의 개념 - ‘없음’또는 ‘0’이 아닌 미지의 값에 대한 표현
  - 입력된 적이 없는 값
  - 적용 불가능한 값

## ERD의 변환

## 데이터 연산

- 관계 연산 - 관계형 모델을 기반으로 구성된 릴레이션을 사용하여 새로운 릴레이션을 생성하는 표현, 사용자의 관점에서 필요한 데이터를 릴레이션에서 추출하는 방법을 제공하는 도구
- 관계 대수(relational algebra)
  - 관계 연산을 정의하는 방법
  - 주어진 릴레이션에서 필요한 릴레이션을 만드는 연산자(∪, ∩, -, σ, π, x, ⋈, ÷, 집계함수 등)로 구성
  - 관계 대수 연산자는 새로운 임시 릴레이션을 생성
  - 연산자를 중첩하여 연산 처리 절차를 표현
- 레코드에 대한 연산 - 셀렉트 연산, 컬럼에 대한 릴레이션 구성 - 프로젝트 연산
- 카티시언 프로덕트 연산 - 서로 다른 두 릴레이션을 결합
- 조인 연산 - 무작위가 아니라 조건을 만족하는 레코드를 결합한 레코드로 구성된 릴레이션
- 집계 함수 연산

## 연습문제

- 관계형 모델에서 표와 유사하게 2차원 구조로 데이터를 표현하는 저장하는 것은? → 릴레이션
- 참조 무결성 제약조건 - 두 개의 릴레이션 사이에 명시되는 제약조건으로 한 릴레이션에 있는 레코드가 다른 릴레이션에 있는 레코드를 참조하려면 반드시 존재하는 릴레이션만 참조해야한다는 제약조건을 명시한다.

# 4강. SQL(1)

## 데이터베이스 언어

- 데이터 정의 언어(DDL: Data Definition Language) - CREATE, ALTER, DROP 문 등
- 데이터 조작 언어(DML: Data Manipulation Language) - INSERT, UPDATE, DELETE, SELECT 문 등

## 데이터 정의 언어

- 스키마 = 데이터베이스 = 한 조직의 데이터베이스 시스템 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합
- CHAR(10) vs VARCHAR(10) - 최대 길이가 N인 고정길이/가변길이 문자열 → 가변적으로 변경될 경우 쿼리 찾을 때 더 오래 걸릴 수 있음
- ENUM - 유한개의 문자열 집합 중 하나의 값을 선택, 다른 값이 들어가는 걸 방지

## 연습문제

- CRATE TABLE에 의해 생성된 테이블의 구조를 변경하기 위한 SQL문은 “ALTER TABLE 테이블이름”으로 시작된다. 새로운 컬럼이나 제약조건 등을 추가/제거/삭제할 수 있다.
- SQL은 데이터 일관성과 무결성을 위해 테이블 정의 시 데이터에 대한 조건을 제약조건으로 기술할 수 있으며 이 중 UNIQUE는 서로 다른 레코드가 UNIQUE로 지정된 컬럼에 대해 동일한 값을 가질 수 없는 조건을 생성한다.

# 5강. SQL(2)

## 데이터삽입, 수정, 삭제

### INSERT 문

- INSERT - 테이블에 새로운 레코드를 삽입하는 명령문
  ```sql
  INSERT INTO 테이블이름
  	VALUES(값, 값2, ..., 값n)
  ```
  ```sql
  INSERT INTO 테이블이름(컬럼1, 컬럼2, ..., 컬럼m)
  	VALUES(값, 값2, ..., 값n)
  ```
  - 특정 컬럼에 해당해서 INSERT를 처리할 때의 차이

### UPDATE 문

```sql
 UPDATE 테이블이름
	SET 컬럼1 = 값1
	WHERE 조건
```

- 단순 값 대신 수식을 넣어서 어떤 계산된 값을 넣을 수 있음

### DELETE 문

- UPDATE나 DELETE 같은 구문이 정상적으로 동작하지 않을 때는 특정 컬럼을 참조하는 다른 테이블이 있는지 확인해봐야 함(외래키를 통한 참조)

```sql
DELETE FROM 교수
	WHERE 소속학과 = '행정학과'
```

- SAFE UPDATES 모드 - WHERE 절이 없는 UPDATE/DELETE 문은 테이블의 전체 레코드를 변경/삭제되기 때문에 의도치 않은 변경/삭제 방지를 위해 MySQL은 SAFE UPDATES 모드를 지원
  ```sql
  SET SQL_SAFT_UPDATES = 0 또는 1
  ```

## 데이터검색(1)

### SELECT 문

- 한 개 이상의 테이블에서 주어진 주건에 만족하는 레코드를 출력하는 명령문

**단순질의문**

- 레코드를 제한하지 않고 전체 테이블을 검색하는 SELECT 문으로 WHERE 절이 없는 질의문
  ```sql
  SELECT 컬럼1, 컬럼2 …, 컬럼n
  	FROM 테이블
  ```
  ```sql
  SELECT 소속학과
  	FROM 교수
  ```
  ```sql
  SELECT DISTINCT 소속학과
  	FROM 교수
  ```
  - 중복 제거

**조건질의문**

- WHERE 절은 UPDATE, DELETE 문에서도 동일하게 적용

```sql
SELECT 과목명, 학점, 선수과목 FROM 과목
	WHERE 이수구분= '전공필수'
```

```sql
SELECT 학생번호, 학생이름, 전화번호, 나이 FROM 학생
	WHERE 성별= '남' AND 생년월일 < '2000-1-1'
```

**데이터 정렬**

- 검색 결과를 특정 컬럼에 대해 오름차순 또는 내림차순으로 정렬

```sql
SELECT 문형식
	ORDER BY 컬럼1 [ASC|DESC] ,
…,
	컬럼n [ASC|DESC]
```

```sql
SELECT * FROM 계좌
	ORDER BY 잔액 ASC
```

**특수연산자의 사용**

- 범위 포함 여부, 부분 일치 여부, 포함 여부 등 관계형 데이터베이스에서만 사용되도록 고안된 연산자
- 예시 1(BETWEEN)
  ```sql
  SELECT 계좌번호, 잔액, 학생번호 FROM 계좌
  	WHERE 잔액 >= 200000 AND 잔액 <= 400000
  ```
  ```sql
  SELECT 계좌번호, 잔액, 학생번호 FROM 계좌
  	WHERE 잔액 BETWEEN 200000 AND 400000
  ```
- 예시 2(IN)
  ```sql
  SELECT 교수이름, 직위, 소속학과 FROM 교수
  	WHERE 소속학과 = '컴퓨터과학과' OR 소속학과 = '행정학과' OR 소속학과 = '법학과'
  ```
  ```sql
  SELECT 교수이름, 직위, 소속학과 FROM 교수
  	WHERE 소속학과 IN('컴퓨터과학과', '행정학과' , '법학과')
  ```
- 예시 3(LIKE) - 부분 일치 검색
  ```sql
  SELECT 과목코드, 과목명, 이수구분 FROM 과목
  	WHERE 과목코드 = 'COM'
  ```
  ```sql
  SELECT 과목코드, 과목명, 이수구분 FROM 과목
  	WHERE 과목코드 LIKE 'COM%'
  ```
  ```sql
  SELECT 과목코드, 과목명, 이수구분 FROM 과목
  	WHERE 과목코드 LIKE '%COM'
  ```
  - 게시판 검색, 구글 검색, 네이버 검색 등 검색에 주로 사용되는 쿼리문

**함수 - 문자함수, 숫자함수, 날짜 및 시간 함수**

```sql
SELECT SUBSTRING(학생번호, 1, 6), 학생이름,
	CONCAT(성별, '성')
	FROM 학생
```

# 6강. SQL(3)

## 데이터 검색 (2)

### 집계 함수

**집계 함수의 사용**

```sql
SELECT COUNT(DISTINCT 단과대학)
	FROM 학과
```

**별칭 부여**

```sql
SELECT COUNT(DISTINCT 단과대학) AS 단과대학수
	FROM 학과
```

### 그룹 질의

**[주의] SELECT 절에 그룹의 기준과 집계 함수 이외의 컬럼은 포함될 수 없음**

```sql
SELECT 소속학과, COUNT(*) AS 교수수
	FROM 교수
	GROUP BY 소속학과
```

### HAVING 절

- 그룹 질의의 결과 레코드에 대해 출력 조건을 기술하기 위한 절 - GROUP BY를 한 후에 별도의 조건을 추가로 줄 때 사용

```sql
SELECT 학생번호, COUNT(*) AS 신청_전공수
	FROM 전공
	GROUP BY 학생번호
		HAVING 신청_전공수 >= 2
```

### 중첩 질의

- SELECT 문의 중첩 - 내부 질의의 처리 결과를 외부 질의에서 재사용

### 조인 질의

- 관계형 데이터베이스는 하나의 테이블로 결과를 내야 하는데, 테이블 간의 관련성을 이용하여 두 개 이상의 테이블에서 데이터를 검색하는 질의 기법

### 외부 조인

**외부 조인의 종류**

- 왼쪽 외부 조인(left outer join)
- 오른쪽 외부 조인(right outer join)
- 완전 외부 조인(full outer join)

### 셀프 조인

- 한 테이블이 자기 자신과 조인되는 형태
- 동일한 이름의 테이블에 대한 조인이므로 반드시 테이블 이름에 대한 별칭이 의무적으로 사용

## 뷰의 사용

- 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블(virtual table)
  - 데이터 독립성
  - 데이터 보안
  - 다양한 구조의 테이블 삳용
  - 작업의 단순화
  - 데이터 무결성
- 뷰의 수정은 생성과 동일하게 새로운 SELECT 문의 결과로 변경

# 7강. 정규화

## 좋은 릴레이션과 나쁜 릴레이션

- 잘못된 데이터베이스 모델링
  - 데이터의 중복 - 일관성 유지 어려움, 저장 공간 낭비
  - 갱신 이상 - 삽입, 삭제, 수정 이상
- 좋은 릴레이션의 개념
  - 프로그래머적 관점에서의 모델링 - 어떻게 데이터를 저장해야 하는가
  - 릴레이션의 스키마가 효율적으로 실세계를 반영하는가
  - 고려사항
    - 한 릴레이션 내 컬럼 간 관계 분석, 원치 않는 데이터의 종속과 중복 제거, 새로운 컬럼들이 추가될 때 가존 컬럼과의 관계 수정 최소화
- 좋은 릴레이션
  - 중복되거나 중복과 일관성을 고려해야 하는 컬럼은 별도의 외래키로 릴레이션을 나누는 것

## 함수적 종속성

- 정의
  - 릴레이션 인스턴스를 분석하여 속성들 간의 연관관계를 표현한 것
  - 좋은 릴레이션으로 변환하는 데에 이용
- 함수적 종속성의 판별
  - {동급}(결정자) → {할인율}(종속자)
- 함수적 종속성의 확장
  - 릴레이션의 인스턴스만으로는 모든 함수적 종속성을 찾기 어려움
  - 추론 규칙을 사용하여 함수적 종속성을 확장
  - 클로저 - 판별된 함수적 종속성 집합으로부터 유추할 수 있는 모든 함수적 종속성 집합
- 암스트롱 공리
- 카노니컬 커버
  - 함수적 종속성 추론 규칙으로 확장된 클로저에는 자명한 종속성과 중복된 종속성을 포함
  - 불필요한 함수적 종속성을 제거한 표준형으로 변환 후 정규화 수행(불필요한 가지 치기)

## 정규화

- 정규형
  - 이상 현상을 최소화하도록 특정 조건을 갖춘 릴레이션의 형식
- 정규화의 목적
  - 릴레이션의 효과적 표현, 검색 알고리즘을 효과적으로 작성할 수 있게끔 지원, 바람직하지 않은 삽입/수정/삭제 등의 이상 발생 방지, 새로운 형태의 데이터가 삽입될 때 릴레이션 재구성의 필요성 축소
- 제1정규형
  - 관계형 모델에 조건에 따라 자동 적용되는 정규형 - 릴레이션 스키마에서 정의된 모든 속성의 도메인이 원자값을 갖는 상태
  - 콤마나 파이프를 통해 여러 의미를 갖는 속성은 권장하지 않음 - 제1정규화가 필요한 릴레이션
- 함수적 종속성 다이어그램(FDD)
- 제2정규형
  - 제1정규형 + 기본키의 부분집합이 특정 속성을 종속하고 있지 않은 상태 → 기본키에 완전히 종속되도록 릴레이션을 분해
- 릴레이션의 무손실 분해
- 제2정규화의 적용
  - 기본키에 중속되도록 릴레이션 분리
- 제3정규화
  - 제2정규화 + 기본키가 아닌 속성들이 어떤 키에도 이행적으로 종속되지 않은 상태
- BC정규형
  - 제3정규형 + X→Y 형태의 모든 함수적 종속성에 대하여 X가 수퍼키인 상태
- 역정규화의 개념
  - 정규화 - 중복성을 최소화하는 과정 → 단, 사용 과정에서 많은 조인연산을 유발
  - 역정규화 - 정규화를 통해 분리되었던 릴레이션을 통합하는 재조정을 수행하고 정보의 부분적 중복을 허용하는 기법
  - 정규화되지 않은 스키마와 역정규화 스키마는 효율적 측면, 구조 측면에서도 다르기 떄문에 구별

# 8강. 연습문제 풀이 1

- DBMS 사용 이전의 데이터 관리 방식으로 운영체제의 지원으로 여러 파일에 나누어 데이터를 영구 저장하고 운영하는 시스템을 무엇이라고 하는가? → 파일 처리 시스템
- 다음 중 파일 처리 방식의 데이터 관리가 갖는 문제점으로 볼 수 없는 것은? → 데이터의 독립
- DBMS가 데이터베이스 자체 뿐만 아니라 데이터에 대한 정의나 설명에 대한 것까지 포함하고 있는 특성을 무엇이라 하는가? → 자기 기술성
- 데이터베이스 언어의 한 영역으로 데이터베이스에 의해 구조화된 데이터에 사용자가 접근 및 사용 할 수 있도록 지원하는 언어를 무엇이라고 하는가? → 데이터 조작 언어
- DBMS를 외부, 개념, 내부 스키마로 분리하고 각 단계 간 사상을 통해 구조화하는 방식을 무엇이라고 하는가? → 3단계 구조
- 클라이언트와 서버 사이에 데이터에 접근하는데 사용되는 비즈니스 규칙을 저장한 중간 계층을 삽입하여 운용하는 데이터베이스 시스템 아키텍처는? → 3계층 클라이언트-서버 구조
- 다음 중 데이터베이스 모델링 단계가 순서대로 나열된 것은? → 요구 분석 - 개념 - 논리 - 물리
- 사용자 요구사항 분석 과정에서 데이터베이스를 구축하기 위한 목표와 조사 범위를 결정하고 필요한 자료를 수집하는 등을 수행하는 세부 단계는? → 사용자 요구사항 도출
- ER 모델의 구성요소 중 실세계에 존재하는 다른 모든 객체와 구별되는 유ㆍ무형의 대상의 모임을 무엇이라고 하는가? → 개체 집합
- 개체 집합의 각 개체마다 서로 다른 값을 갖는 속성을 뜻한다. 즉, 어떤 개체의 이 값은 각각의 개체들을 서로 구별하는 데 사용되는 개체 집합에서 유일한 값이다. → 키 속성
- 학생은 이름, 학번, 학과명, 주소로 구성된다. 학번은 입학 년도, 학과코드 및 일련번호로 이루어지고, 학과명은 학과 코드를 통해 알 수 있다.
  ```sql
  이름
  학번
  	입학년도
  	학과코드
  	일련번호
  학과명()
  주소
  ```
- ER 다이어그램 참고(2.3.4절)
- 릴레이션 용어 참고(3.1.2절)
- 한 릴레이션을 구성하는 컬럼 사이에는 순서가 없고 이름과 값의 쌍으로 구성된다. → 컬럼의 무순서성
- 두 개의 릴레이션 사이에 명시되는 제약조건으로 한 릴레이션에 있는 레코드가 다른 릴레이션에 있는 레코드를 참조하려면 반드시 존재하는 릴레이션만 참조해야하는 제약조건을 명시한다. → 참조 무결성 제약조건
- ER 다이어그램을 관계형 모델로 변환(3.2.1절)
- “강좌명이 ‘요가’인 강좌의 강좌번호, 강좌명, 강사번호를 출력하시오.”에 대한 관계 대수 연산식으로 올바른 것은? → σ강좌명 = ‘요가’(강좌)
- “ ‘홍길동’ 강사의 종목을 출력하시오.”에 대한 관계 대수 연산식은? → Π종목(σ이름 = ‘홍길동’(강사 ▷◁강사.강사번호=종목.강사번호 종목))
- 테이블 스키마 정의, 테이블 삭제, 테이블 스키마 변경 및 제약조건을 명시하는 기능을 하는 SQL 언어 영역을 무엇이라고 하는가? → 데이터 정의 언어
- 다음 중 데이터베이스 언어의 영역이 나머지 셋과 다른 SQL 명령어는 무엇인가? → 검색, 삽입, 수정(데이터 조작)을 하는 것과 다르게 DROP은 데이터 삭제에 대한 것이므로 데이터 정의 언어
- 다음 중 테이블의 컬럼을 삭제하는 데 사용하는 SQL 명령어는? → ALTER
- “교수의 교수번호, 소속학과, 교수이름, 입사일을 입사일의 내림차순으로 정렬하여 출력하시오.”를 수행하기 위한 SQL 문은?
  ```sql
  SELECT 교수번호, 소속학과, 교수이름, 입사일
  FROM 교수 ORDER BY 입사일 DESC
  ```
- 다음 중 정규화에 대한 설명으로 올바르지 않은 것은? → 릴레이션 간 공통부분을 도출하고 유사 릴레이션을 통합하여 스키마의 구조를 간략화 한다(X) → 정규화의 과정은 쪼개는 과정이지 통합이 아님, 통합은 오히려 역정규화
- 이것은 릴레이션 인스턴스를 분석하여 속성들 간의 연관관계를 표현한 것으로 , 주어진 릴 레 이 션 인스턴스에서 서로 다른 두 레코드와 속성 집합 X와 Y에 대해, 두 레코드의 X 속성값이 같을 때, Y의 속성값이 같으면 성립하는 특성을 말한다. → 함수적 종속성
- 함수적 종속성 참고(6.2.1절)
- 제약조건이 강한 순으로 정규형 간의 관계가 올바른 것은? → 제1정규형 < 제2정규형 < 제3정규형 < 제4정규형 < 제5정규형
- 릴레이션의 정규형(2.1.1절)

# 9강. 데이터 저장과 파일

## 물리적 저장장치

- 휘발성
  - 캐시 - 고비용 저장장치로 빠른 접근 속도를 보장
  - 메인 메모리 - 실제 프로그램과 데이터 적재 공간
- 비휘발성
  - 플래시 메모리 - 메인 메모리와 유사하나 비휘발성
  - 자기 디스크, 광학 디스크, 테이프

## 파일

- 파일 - 데이터를 영구적으로 저장하기 위해 사용되는 가장 기초 논리적 구조
- 블럭 - 파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음, 일반적으로 메모리와 디스크간 데이터 전송 단위로 결정
- 레코드 - 블럭을 구성하는 요소, 더 이상 분할할 수 없는 단위
- 고정 길이 레코드
  - 하나의 블럭에 여러 개의 레코드가 들어가는데, 하나의 레코드를 고정 길이 레코드로 가져가면 i번째 레코드 접근할 때 (i - 1) \* 42 + 1번째 바이트부터 42개의 바이트로 읽어 접근 가능
- 잔여 고정 길이 레코드 할당 - 블럭의 길이가 레코드 길이로 정확히 나뉘지지 않아 진여 공간을 비워두는 방법 → 단, 블럭 내 남은 공간이 낭비됨
- 고정 길이 레코드 할당 - 효율적으로 저장 공간 사용 가능 → 단, 레코드 접근 시 두 블럭을 접근해야(연산해야) 하기에 느려질 수 있음
- 고정 길이 레코드 할당의 문제
  - 레코드 삭제 시 → 장시간 레코드 삽입 및 삭제 발생 시(중간중간 삭제된 빈 공간), 저장 공간에 많은 낭비가 발생
- 레코드 삭제 대처
  - 마지막 레코드로 공백 대체 - 마지막 레코드를 끌어올려서 공백 대체하기 때문에 레코드의 순서가 달라짐
  - 삭제 레코드 이후의 레코드를 이동 - 검색의 효율은 그대로 가져갈 수 있는 반면, 전체 레코드의 이동이 있어야 하기 때문에 오버헤드가 생길 수 있음
  - 가용 리스트 관리 - 공백 레코드 포인터를 통해 가리키고 있음
- 가변 길이 레코드
  - 블럭에 저장되는 레코드의 길이가 서로 다른(가변적) 레코드를 할당
  - 한 블럭 내 저장되는 레코드 유형이 둘 이상, 길이가 고정되지 않은 컬럼의 개수가 하나 이상, 레코드가 멀티셋을 허용한 컬럼을 가질 때
- 슬롯페이지 구조
  - 블럭 헤더에 레코드 개수, 레코드 요약 정보
  - 레코드를 뒤부터 저장
- 파일 구조화 방법 - 파일 수준에서 레코드를 관리(순서 등)하는 방법
- 파일 구조화 방법의 종류
  - 힙 파일 구조 - 저장순서 고려없이 파일 내 임의의 위치에 배치(무작위 저장, 저장속도 빠름, 사용 효율은 떨어짐)
  - 순차 파일 구조 - 레코드들이 탐색키 기준으로 정렬 및 저장(힙 파일에 비해 저장속도 증가하지만 검색 속도가 상대적으로 빠름)
  - 해시 파일구조 - 해시 함수를 사용하여 블럭 주소를 계산
- 순차 파일 구조
  - 장점
    - 이진 탐색을 사용하면 더 빠르게 레코드를 검색
  - 단점
    - 레코드 삽입, 삭제에 많은 비용 소요
- 오버플로우 블럭
  - 순차 파일 구조에서 레코드의 정렬 유지를 위해 삽입된 신규 블럭 - 저장 속도를 조금 더 빠르게 처리 가능

## 저장장치 관리

- 저장장치 접근
  - 블럭은 메모리와 디스크 간 데이터 전송 단위
  - 일반적으로 2kb ~ 32kb 사용
  - 사용 중인 블럭을 지속적으로 메모리에 적재, 한정적인 공간으로 인해 특정 블럭 해제 등
- 버퍼 관리자
  - 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭 요청
- 버퍼 교체 전략
  - 가용 공간 확보를 위해 적재된 블럭의 할당을 특정 기준에 의해서 해지
  - 미래에 가장 적게 사용될 블럭을 선택하여 디스크로 보내는 것이 이상적인 버퍼 교체 전략
  - 버퍼 교체 전략 기법
    - LRU(Least Recently Used): 최근 가장 적게 참조된 블럭
    - MFU(Most Frequently Used): 특정 기간 동안 가장 여러번 사용된 블럭을 선택하여 블럭 교체
- 고정 블럭과 블럭 강제 출력
- 버퍼 관리자의 기능
  - 고정 블럭 - 중단된 작업의 결과물이 디스크에 기록되는 것을 방지, 디스크 블럭이 교체되는 것을 제한
  - 블럭 강제 출력 - 시스템 로그와 같이 중요한 데이터는 디스크에 영구적으로 기록되어야 함, 비퍼 공간이 필요 없어도 강제로 디스크에 기록

# 10강. 인덱싱

## 인덱스의 이해

- 인덱스의 필요
  - ex) 디스크에서 COM12의 과목명을 찾는다면 그에 해당되는 레코드를 메모리에 담고, 해당되는 COM12를 찾음
- 인덱스의 개념
  - 데이터 검색에서의 비효율적인 I/O 문제를 해결하기 위한 목적
  - 인덱스의 탐색키를 이용해서 해당 레코드가 저장된 블럭을 디스크 저장장치 또는 메모리에서 파악하여 해당 블럭을 빠르게 적재
- 인덱스 기반의 검색 과정
  - 해당 레코드 블럭을 올리는 게 아니라 인덱스 블럭을 먼저 올림
- 인덱싱의 종류
  - 인덱스의 종류
    - 순서 인덱스 - 특정 값에 대해서 정렬된 순서 구조
    - 해시 인덱스 - 버킷의 범위 안에서 값의 균일한 분포에 기초한 구조로 해시 함수가 어떤 값이 어느 버킷에 할당되는지 결정
  - 인덱스의 평가 기준 - 접근 시간, 유지 비용, 공간 비용

## 순서 인덱스

- 순서 인덱스의 특징
  - 탐색키를 정렬하여 해당 탐색키와 탐색키에 대한 레코드와의 연계를 통해 인덱스 생성
  - 순서 인덱스의 종류 - 밀집, 희소, 다단계
- 인덱스 엔트리의 구조
  - 탐색키값에는 포인터가 있고 → 포인터는 블럭ID와 오프셋
- 밀집 인덱스
  - 모든 레코드에 대해 탐색키값-포인트 쌍으로 유지
- 희소 인덱스
  - 인덱스의 엔트리가 일부의 탐색키 값만을 유지 - 찾으려는 인덱스보다 작은 인덱스를 찾아서 순차 검색
- 다단계 인덱스
  - 내부 인덱스와 외부 인덱스로 구성
  - 전체의 인덱스 구조가 트리 형태
  - ex) 내부 인덱스는 1,000,000개의 블럭이라면 외부 인덱스는 100개의 블럭만 사용

## B+-트리 인덱스

- 이진 탐색 트리(binary search tree) - 이진 탐색 + 다단계 인덱스
- 𝐵 +-트리의 구조 - 루트노드 > 중간노드 > 단말노드
- 인덱스 세트 - 루트노드와 중간노드로 구성
- 순차 세트 - 단말노드로 구성, 순차 세트만이 실제 레코드를 가리키는 포인터를 제공
- B+-트리 상에서의 재구조화 - 레코드 삽입, 삭제 시
  - 레코드 삽입 - 노드에서 유지해야 할 탐색키와 포인터 수 증가로 인해 노드를 분할해야 하는 경우 발생
  - 레코드 삭제 - 노드에서 유지해야 할 탐색키 값과 포인터 수 감소로 형제 노드와 키를 재분배 또는 병합해야 하는 경우가 발생
  - 높이 균형 유지 - 노드가 분할되거나 병합되면서 높이의 균형이 맞지않는 경우 발생
  - 삽입은 분할, 삭제는 병합
- 노드가 분할되는 삽입
  - 삽입 대상 노드에 추가적인 저장 공간 부족 - 노드 분할

# 11강. 해싱과 특수 인덱스

## 정적 해싱

- 해싱의 개념
  - 해시 - 탐색키에 산술 연산으로 버킷의 주소를 계산하는 해시 함수를 사용해서 데이터 배분 및 접근 기법
  - 탐색키를 버킷에 바로 넣는 게 아니라 해시 함수를 통해 해싱 후 버킷에 넣음
  - 버킷 - 한 개 이상의 레코드를 저장할 수 있는 저장공간의 단위
  - 크기는 일반적으로 디스크 블록과 크기가 일치
- 해시 함수의 역할
  - 되도록 균등하게 배분되도록 설계 - 일반적으로 어느 정도만 분배되도록 가능
- 정적 해싱의 특징 - 버킷의 개수가 고정된 해싱 기법
- 충돌과 동거자
  - 충돌 - 서로 다른 두 레코드가 동일한 버킷에 대응
  - 동거자 - 충돌에 의해 같은 버킷 주소를 갖는 레코드
- 오버플로(overflow)
  - 버킷에 레코드를 할당할 공간이 없을 때 → 추가 버킷을 할당하거나 다음 버킷에 할당하여 처리
  - 오버플로우가 늘어날수록 접근 시간이 길어지고 성능 저하
- 해시 인덱스
  - 해시 파일 구조와 동작 방식을 레코드가 아닌 인덱스 엔트리에 적용
- 정적 해싱의 문제
  - 데이터베이스의 크기가 커짐에 따라 성능 감소, 미리 큰 공간을 잡는 경우 초기 공간 낭비, 재구성 시 재계산 및 버킷에 할당하는 대량의 비용 발생

## 동적 해싱

- 동적 해싱의 개념
  - 동적 해싱의 정의 - 버킷의 개수가 가변적으로 조절할 수 있는 해싱 기법
  - 데이터베이스 크기에 따라 버킷 크기가 바례
  - 디렉터리를 거쳐서 디스크에 저장
- 확장성 해싱
  - 모조키(pseudo key) - 탐색키 값이 해시 함수에 의해 일정 길이의 비트 스트링으로 변환된 키
  - 모조키의 첫 d 비트를 사용하여 디렉토리에 접근

## 비트맵 인덱스

- 비트맵 인덱스의 개념 - 탐색키의 중복 비율이 높은 경우 질의를 효율적으로 처리하기 위해 고안된 특수 형태의 인덱스
- 비트맵의 활용 - 컬럼에 대한 값이 범위가 유한하고 비교적 개수가 적은 규모일 때 용이
  - 적용 - 직책, 학과, 혈액형 등

# 12강. 트랜잭션

## 트랜잭션의 이해

- 트랜잭션의 개념
  - 데이터베이스를 조작하기 위한 하나의 논리적 단위를 이루는 일련의 연산의 집합
  - 작업 단위: 예금 1000원 인출
  - 일련의 연산: Read(A), A-1000, Write(A)
  - 작업을 하나의 묶음으로 인식해서 묶음 단위로 실행되도록 - 트랜잭션
- 트랜잭션의 특징
  - 트랜잭션은 ACID 특징을 준수
  - ACID 특성
    - 원자성(atomicity) - 완전히 수행되거나 전혀 수행되지 않음
    - 일관성(consistency) - 트랜잭션 수행 전 후로 여전히 일관된 상태를 유지(ex) 총금액)
    - 고립성(isolation) - 다른 트랜잭션에 의해 방해받지 않음
    - 지속성(durability) - 완료된 트랙잭션은 시스템 장애 등 어떤 문제에도 데이터베이스에 반영되어야 함
- ACID 특성 유지
  - 트랜잭션 중 하드웨어가 망가졌다 하더라도 원자성에 의해 중간까지 수행된 것이 반영되지 않음
  - 총금액은 트랜잭션 중 일관성이 훼손됐지만 수행 후에 다시 복구
- 트랜잭션 연산자
  - 트랜잭션의 연산 - Read(X), Write(X)
  - 트랜잭션 실행의 연산
    - Commit - 트랜잭션 연산으로 데이터베이스 반영하고 지속성을 확보하는 연산
    - Rollback - 갱신된 모든 데이터 항목의 값을 무효화하여 일관성을 확보하는 연산
- 트랜잭션의 5가지 상태 변화
  - 동작 → 부분 커밋 → 커밋
  - 동작 → 실패 → 중단
  - 동작: 트랜잭션이 시작을 준비 또는 실행 중인 상태
  - 부분 커밋: 마지막 연산을 실행한 직후의 상태(DBMS에 반영 전)
  - 커밋: 모든 실행이 성공적으로 완료된 후에 상태(DBMS에 반영 완료)
  - 실패: 실행이 정상적으로 진행될 수 없는 상태
  - 중단: 실행 실패로 롤백되고 시작 이전 상태로 환원된 상태

## 트랜잭션의 동시성

- 동시성 고려
  - DBMS는 다수의 사용자가 공용 사용을 목적으로 도입
  - 트랜잭션 동시 실행으로 트랜잭션 처리율과 자원 이용률 향상, 대기 시간 감소
  - 일관성 훼손 문제가 발생할 수 있음
  - 동시성 제어(concurrency control) - 다수의 트랜잭션이 성공적으로 동시에 실행되어도 일관성이 유지될 수 있도록 하는 기법
- 적용 트랜잭션
  - 스케줄 - 다수의 트랜잭션에 포함된 연산의 실행 순서를 명시한 것
- 직렬 스케줄 - 각 트랜잭션에 속한 모든 연산이 순차적으로 실행 → 일관성에 문제 없음
- 병렬 스케줄 - 하나의 트랜잭션에 완료되기 전에 다른 트랜잭션이 실행 → 종종 일관성 훼손
- 적렬 가능 스케줄 - 복수개의 트랜잭션이 동시에 수행된 결과가 직렬 스케줄과 결과와 동일한 스케줄
- 직렬 가능 스케줄의 정의
  - 연산 순서를 교환해 직렬 스케줄과 동등하게 변환이 가능한 스케줄
  - 연산 교환 시 일관성이 훼손되는 충돌이 발생될 수 있는데, 충돌이 발생하지 않도록 교환하는 것
- 충돌 동등으로 충돌 직렬성 확보

## 트랜잭션의 회복

- 회복의 개념
  - 원자성을 보장하기 위해 트랜잭션 실패 시 실행된 모든 연산을 실행 이전 상태로 복원하는 기법
- 회복 가능한 스케줄 - 연쇄적 롤백 유발 가능성
- 비연쇄적 스케줄 - 연쇄적 롤백 방지를 위해 연쇄적이지 않은 스케줄로 구성
