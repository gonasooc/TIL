# 1강. 데이터베이스의 이해

## 01. 데이터베이스의 역할

### 데이터 관리의 필요

- 대량의 데이터를 저장 및 관리하고 필요한 데이터를 **신속히** 검색할 수 있도록 보조하는 장치

### 전통적 데이터 관리 방식

- 학적업무, 성적업무, 수강업무 개별로 관리 → 파일 처리 시스템

### 파일 처리 시스템(file processing system)

- 데이터베이스가 개발되기 전에 데이터 관리에 사용
- 업무별 애플리케이션이 개별 데이터를 데이터 파일에 저장, 관리하는 시스템
- 발생 가능한 문제
  - 데이터 종속의 문제
  - 데이터 중복의 문제
  - 무결성 훼손의 문제
  - 동시 접근의 문제

### 데이터 종속의 문제

- 물리적 데이터 종속
  - ex) 신규 디스크에 이어서 저장하려고 해도 기존 디스크에 종속성이 있어서 불가능
- 논리적 데이터 종속
  - 데이터를 표현하는 논리적 구조를 바꾸는 것이 어려움

### 데이터 중복의 문제

- 일관성 훼손 → 한 개의 데이터를 바꾸더라도 중복된 데이터까지 변경해줘야 하는 문제 있음
- 보안성 훼손 → 중복된 데이터를 같은 수준의 보안 유지하기 어려움, 중복
- 경제성 훼손 → 데이터 저장의 불필요한 리소스 생김

### 무결성 훼손의 문제

- 파일 처리 시스템은 데이터 범위를 지정하고 유지 관리할 기능이 없어서 무결성 훼손 가능성 높음

### 동시 접근의 문제

- 동일 데이터에 다수 사용자의 접근 허용 시 일관성 훼손(ex) 은행 잔고)

## 02. 데이터베이스의 특징

### 데이터베이스 사용의 의미

- 데이터 사용의 영역과 데이터 관리(디스크) 중간에 데이터베이스를 경유

### 데이터베이스 시스템의 구성

- 사용자나 프로그래머가 DBMS를 통해 접근했을 때 저장된 데이터베이스 정의(메타데이터)와 저장된 데이터베이스 별도로 접근

### 값, 데이터, 메타데이터

- 값이 설명과 함께 하나의 데이터가 만들어질 때 그 설명이 별도의 메타데이터가 될 수 있음 ex) 오늘, 12도, 낮 최고기온

### DBMS의 3단계 구조

- 뷰와 외부 스키마(외부 단계) - 개념 스키마(개념 단계) - 내부 스키마(내부 단계)
- 각 단계는 별도의 맵핑으로 연결되어 있음

### 다수 사용자 트랜잭션 처리

- 트랜잭션의 정의 - 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합 ex) Read(A) + Write(A) 묶어서 트랜잭션으로 처리하고 그 트랜잭션이 처리되기 전에는 데이터 접근 불가 처리

## 03. 데이터베이스의 구성요소

- DDL: Data Definition Language - 데이터베이스 객체를 생성, 수정. 삭제하기 위한 언어
- DML: Data Manipulation Language - 구조화된 데이터에 사용자가 접근 및 조작할 수 있도록 지원하는 언어(검색, 삽입, 삭제, 수정)

### 데이터베이스 시스템 아키텍처

- 중앙집중식 방식 - 단일 서버 + 클라이언트 장치를 대신해서 작동
  - 과부하로 전체적인 성능 저하 단점
- 분산 시스템 방식
  - 클라이언트 장치의 성능 향상으로 클라이언트 - 서버 데이터베이스 시스템 구조로 부하 분산
  - 2계층 구조 - 애플리케이션 클라이언트 - 데이터베이스 시스템
  - 3계층 구조 - 애플리케이션 클라이언트 - 애플리케이션 서버 - 데이터베이스 시스템

# 2강. 데이터베이스 모델링

## 01. 데이터베이스 모델링의 이해

### 데이터 모델

- 사용할 데이터를 선별하여 데이터베이스에 체계적으로 구주화하여 저장, 사용할 방법이 필요
- 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합

### 데이터베이스 모델링의 단계

- 개념적 데이터 모델링 → 비즈니스적인 관점에서 고민
- 논리적 데이터 모델링 → 기술적인 고민, 실제 기술 구현

## 02. 사용자 요구사항 분석

## 03. ER 모델

- 실세계의 속성들로 이루어진 개체(entity)와 개체 사이의 관계(relationship)를 정형화 시킨 모델
- 데이터 구조와 관계를 ER 다이어그램(ERD)으로 표현
- 개체(entity) → 개체 집합(entity set), 관계 집합(relationship set)

### 연습문제

- 사용할 데이터를 선별하고 데이터베이스에 체계적으로 구조화하여 저장·사용할 방법을 정의할 수 있도록 데이터의 의미, 데이터 타입, 연산 등을 명시하기 위한 개념들의 집합 → 데이터 모델
- 사용자 요구사항 분석 과정: 요구사항 도출 → 요구사항 분석 → 요구사항 기록

# 3강. 관계형 모델

## 관계형 모델

- 릴레이션의 구성 - 릴레이션, 컬럼, 속성, 필드, 스키마, 레코드, 투플, 컬럼값, 인스턴스 ..
- 릴레이션의 특징 - 레코드의 유일성, 레코드의 무순서성, 컬럼의 무순서성, 컬럼값의 원자성
- 키(key)의 역할 - 릴레이션의 레코드를 유일하게 식별하는 값
- 키의 속성 - 유일성(Uniqueness), 최소성(Irreducibility)
- 키의 종류
  - 수퍼키(super key): 유일성 만족
  - 후보키(candidate key): 유일성, 최소성 만족
  - 기본키(PK: primary key): 레코드의 구분을 위해 선택된 후보키
  - 외래키(FK: foreign key): 참조된 다른 릴레이션의 기본키
- 키의 참조 - 두 릴레이션에 포함된 레코드 간 연관성을 표현하고자 할 때 외래키가 사용됨
- 널(null)의 개념 - ‘없음’또는 ‘0’이 아닌 미지의 값에 대한 표현
  - 입력된 적이 없는 값
  - 적용 불가능한 값

## ERD의 변환

## 데이터 연산

- 관계 연산 - 관계형 모델을 기반으로 구성된 릴레이션을 사용하여 새로운 릴레이션을 생성하는 표현, 사용자의 관점에서 필요한 데이터를 릴레이션에서 추출하는 방법을 제공하는 도구
- 관계 대수(relational algebra)
  - 관계 연산을 정의하는 방법
  - 주어진 릴레이션에서 필요한 릴레이션을 만드는 연산자(∪, ∩, -, σ, π, x, ⋈, ÷, 집계함수 등)로 구성
  - 관계 대수 연산자는 새로운 임시 릴레이션을 생성
  - 연산자를 중첩하여 연산 처리 절차를 표현
- 레코드에 대한 연산 - 셀렉트 연산, 컬럼에 대한 릴레이션 구성 - 프로젝트 연산
- 카티시언 프로덕트 연산 - 서로 다른 두 릴레이션을 결합
- 조인 연산 - 무작위가 아니라 조건을 만족하는 레코드를 결합한 레코드로 구성된 릴레이션
- 집계 함수 연산

## 연습문제

- 관계형 모델에서 표와 유사하게 2차원 구조로 데이터를 표현하는 저장하는 것은? → 릴레이션
- 참조 무결성 제약조건 - 두 개의 릴레이션 사이에 명시되는 제약조건으로 한 릴레이션에 있는 레코드가 다른 릴레이션에 있는 레코드를 참조하려면 반드시 존재하는 릴레이션만 참조해야한다는 제약조건을 명시한다.

# 4강. SQL(1)

## 데이터베이스 언어

- 데이터 정의 언어(DDL: Data Definition Language) - CREATE, ALTER, DROP 문 등
- 데이터 조작 언어(DML: Data Manipulation Language) - INSERT, UPDATE, DELETE, SELECT 문 등

## 데이터 정의 언어

- 스키마 = 데이터베이스 = 한 조직의 데이터베이스 시스템 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합
- CHAR(10) vs VARCHAR(10) - 최대 길이가 N인 고정길이/가변길이 문자열 → 가변적으로 변경될 경우 쿼리 찾을 때 더 오래 걸릴 수 있음
- ENUM - 유한개의 문자열 집합 중 하나의 값을 선택, 다른 값이 들어가는 걸 방지

## 연습문제

- CRATE TABLE에 의해 생성된 테이블의 구조를 변경하기 위한 SQL문은 “ALTER TABLE 테이블이름”으로 시작된다. 새로운 컬럼이나 제약조건 등을 추가/제거/삭제할 수 있다.
- SQL은 데이터 일관성과 무결성을 위해 테이블 정의 시 데이터에 대한 조건을 제약조건으로 기술할 수 있으며 이 중 UNIQUE는 서로 다른 레코드가 UNIQUE로 지정된 컬럼에 대해 동일한 값을 가질 수 없는 조건을 생성한다.

# 5강. SQL(2)

## 데이터삽입, 수정, 삭제

### INSERT 문

- INSERT - 테이블에 새로운 레코드를 삽입하는 명령문
  ```sql
  INSERT INTO 테이블이름
  	VALUES(값, 값2, ..., 값n)
  ```
  ```sql
  INSERT INTO 테이블이름(컬럼1, 컬럼2, ..., 컬럼m)
  	VALUES(값, 값2, ..., 값n)
  ```
  - 특정 컬럼에 해당해서 INSERT를 처리할 때의 차이

### UPDATE 문

```sql
 UPDATE 테이블이름
	SET 컬럼1 = 값1
	WHERE 조건
```

- 단순 값 대신 수식을 넣어서 어떤 계산된 값을 넣을 수 있음

### DELETE 문

- UPDATE나 DELETE 같은 구문이 정상적으로 동작하지 않을 때는 특정 컬럼을 참조하는 다른 테이블이 있는지 확인해봐야 함(외래키를 통한 참조)

```sql
DELETE FROM 교수
	WHERE 소속학과 = '행정학과'
```

- SAFE UPDATES 모드 - WHERE 절이 없는 UPDATE/DELETE 문은 테이블의 전체 레코드를 변경/삭제되기 때문에 의도치 않은 변경/삭제 방지를 위해 MySQL은 SAFE UPDATES 모드를 지원
  ```sql
  SET SQL_SAFT_UPDATES = 0 또는 1
  ```

## 데이터검색(1)

### SELECT 문

- 한 개 이상의 테이블에서 주어진 주건에 만족하는 레코드를 출력하는 명령문

**단순질의문**

- 레코드를 제한하지 않고 전체 테이블을 검색하는 SELECT 문으로 WHERE 절이 없는 질의문
  ```sql
  SELECT 컬럼1, 컬럼2 …, 컬럼n
  	FROM 테이블
  ```
  ```sql
  SELECT 소속학과
  	FROM 교수
  ```
  ```sql
  SELECT DISTINCT 소속학과
  	FROM 교수
  ```
  - 중복 제거

**조건질의문**

- WHERE 절은 UPDATE, DELETE 문에서도 동일하게 적용

```sql
SELECT 과목명, 학점, 선수과목 FROM 과목
	WHERE 이수구분= '전공필수'
```

```sql
SELECT 학생번호, 학생이름, 전화번호, 나이 FROM 학생
	WHERE 성별= '남' AND 생년월일 < '2000-1-1'
```

**데이터 정렬**

- 검색 결과를 특정 컬럼에 대해 오름차순 또는 내림차순으로 정렬

```sql
SELECT 문형식
	ORDER BY 컬럼1 [ASC|DESC] ,
…,
	컬럼n [ASC|DESC]
```

```sql
SELECT * FROM 계좌
	ORDER BY 잔액 ASC
```

**특수연산자의 사용**

- 범위 포함 여부, 부분 일치 여부, 포함 여부 등 관계형 데이터베이스에서만 사용되도록 고안된 연산자
- 예시 1(BETWEEN)
  ```sql
  SELECT 계좌번호, 잔액, 학생번호 FROM 계좌
  	WHERE 잔액 >= 200000 AND 잔액 <= 400000
  ```
  ```sql
  SELECT 계좌번호, 잔액, 학생번호 FROM 계좌
  	WHERE 잔액 BETWEEN 200000 AND 400000
  ```
- 예시 2(IN)
  ```sql
  SELECT 교수이름, 직위, 소속학과 FROM 교수
  	WHERE 소속학과 = '컴퓨터과학과' OR 소속학과 = '행정학과' OR 소속학과 = '법학과'
  ```
  ```sql
  SELECT 교수이름, 직위, 소속학과 FROM 교수
  	WHERE 소속학과 IN('컴퓨터과학과', '행정학과' , '법학과')
  ```
- 예시 3(LIKE) - 부분 일치 검색
  ```sql
  SELECT 과목코드, 과목명, 이수구분 FROM 과목
  	WHERE 과목코드 = 'COM'
  ```
  ```sql
  SELECT 과목코드, 과목명, 이수구분 FROM 과목
  	WHERE 과목코드 LIKE 'COM%'
  ```
  ```sql
  SELECT 과목코드, 과목명, 이수구분 FROM 과목
  	WHERE 과목코드 LIKE '%COM'
  ```
  - 게시판 검색, 구글 검색, 네이버 검색 등 검색에 주로 사용되는 쿼리문

**함수 - 문자함수, 숫자함수, 날짜 및 시간 함수**

```sql
SELECT SUBSTRING(학생번호, 1, 6), 학생이름,
	CONCAT(성별, '성')
	FROM 학생
```

# 6강. SQL(3)

## 데이터 검색 (2)

### 집계 함수

**집계 함수의 사용**

```sql
SELECT COUNT(DISTINCT 단과대학)
	FROM 학과
```

**별칭 부여**

```sql
SELECT COUNT(DISTINCT 단과대학) AS 단과대학수
	FROM 학과
```

### 그룹 질의

**[주의] SELECT 절에 그룹의 기준과 집계 함수 이외의 컬럼은 포함될 수 없음**

```sql
SELECT 소속학과, COUNT(*) AS 교수수
	FROM 교수
	GROUP BY 소속학과
```

### HAVING 절

- 그룹 질의의 결과 레코드에 대해 출력 조건을 기술하기 위한 절 - GROUP BY를 한 후에 별도의 조건을 추가로 줄 때 사용

```sql
SELECT 학생번호, COUNT(*) AS 신청_전공수
	FROM 전공
	GROUP BY 학생번호
		HAVING 신청_전공수 >= 2
```

### 중첩 질의

- SELECT 문의 중첩 - 내부 질의의 처리 결과를 외부 질의에서 재사용

### 조인 질의

- 관계형 데이터베이스는 하나의 테이블로 결과를 내야 하는데, 테이블 간의 관련성을 이용하여 두 개 이상의 테이블에서 데이터를 검색하는 질의 기법

### 외부 조인

**외부 조인의 종류**

- 왼쪽 외부 조인(left outer join)
- 오른쪽 외부 조인(right outer join)
- 완전 외부 조인(full outer join)

### 셀프 조인

- 한 테이블이 자기 자신과 조인되는 형태
- 동일한 이름의 테이블에 대한 조인이므로 반드시 테이블 이름에 대한 별칭이 의무적으로 사용

## 뷰의 사용

- 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블(virtual table)
  - 데이터 독립성
  - 데이터 보안
  - 다양한 구조의 테이블 삳용
  - 작업의 단순화
  - 데이터 무결성
- 뷰의 수정은 생성과 동일하게 새로운 SELECT 문의 결과로 변경
