## \***\*설치와 실행\*\***

- `npx create-next-app@lastest .`

## 샘플앱 세탁

- `layout.js`에 `children`에는 `page.js`에서 return 값을 뿌려주는 구조

## 빌드와 배포

- 크롬 개발자도구의 Network 탭을 보면 해당 페이지를 로드할 때 가져오는 resources가 확인 가능함 (ex) 7.0 MB resources)
- 실서버에 사용할 코드는 좀 더 용량을 줄이고 최적화된 코드가 필요함 → 배포 버전
- `npm run build`를 통해 build하고 `npm run start`를 통해서 build된 결과물을 실행해보면 용량이 줄어들고 최적화됐다는 걸 확인 가능함(7.0 MB resources → 906 KB resources)

## 뼈대 만들기

![Untitled](../assets/36a2bd2bc49a.png)

- Next.js 13의 App router 구조에서는 라우팅 path에 따라서 해당 페이지를 찾는 구조로 되어 있음
  - 예컨대 ‘create’라는 segment가 있다면 app 폴더 밑에 ‘create’ 폴더가 있는지 찾음
  - ‘create’ 폴더 안에 약속된 page.js 파일을 찾음
  - 같은 경로에 약속된 layout.js 파일을 찾아서 children으로 랜더링
  - 같은 경로에 약속된 layout.js가 없다면 그 부모 요소에 layout.js를 찾아서 children으로 랜더링

## Single Page Application

- SSR의 단점이라고 할 수 있는데, 페이지의 일부 영역만 바뀌거나 이미 방문한 페이지를 다시 방문하더라도 전체 페이지를 다시 ssr을 통해 클라이언트로 가져옴 → 사용자 입장에선 느리다고 느낄 것이고 서비스를 제공하는 입장에선 돈이 많이 듬
- a tag 대신 <Link />를 사용함으로 SPA처럼 구성할 수 있음 → <Link />를 사용하면 사용자가 클릭하기도 전에 fetch를 하고, 이미 방문했던 페이지를 다시 방문하려고 하면 서버와 통신하지 않음
- 아래 3가지를 충족시켜줌
  - 링크를 클릭하면 페이지 전체 리로딩이 일어나지 않고 필요한 콘텐츠만 로딩하고 싶다.
  - 이미 방문한 페이지는 캐슁을 해서 다시 다운로드 하지 않도록 하고 싶다.
  - 미리 페이지를 로드했다가 실제 요청이 있을 때 클라이언트 측에서 즉시 응답한다.
- Link는 Next.js에서 SPA를 매우 쉽게 구현하도록 도와주는 도구

## **backend**

- json-server를 활용한 실습

  - `npx json-server --port 9999 --watch db.json`
  - db.json에 활용하고 싶으면 json data를 작성하고 저장하면 watch 때문에 재시작함

    ```json
    {
      "topics": [
        {
          "id": 1,
          "title": "html",
          "body": "html is ..."
        },
        {
          "id": 2,
          "title": "css",
          "body": "css is ..."
        }
      ],

      "posts": [
        {
          "id": 1,
          "title": "json-server",
          "author": "typicode"
        }
      ],
      "comments": [
        {
          "id": 1,
          "body": "some comment",
          "postId": 1
        }
      ],
      "profile": {
        "name": "typicode"
      }
    }
    ```

  - `fetch('http://localhost:9999/topics').then((response) => {return response.json()}).then(result => {console.log(result)});`

## **글 목록 가져오기**

- 사용자와 상호작용하는 영역은 클라이언트 컴포넌트, 단순히 보여주는 역할을 하는 영역은 서버 컴포넌트 구현이 유리함

  ![Untitled](../assets/63aeddd33e80.png)

- 서버 컴포넌트는 아래와 같은 경우에 사용합니다.
  - 사용자와 상호작용하지 않는 경우
  - 백엔드에 엑세스하면서 보안적으로 위험한 정보를 주고 받는 경우
- 클라이언트 컴포넌트는 아래와 같은 경우 사용합니다.

  - 서버 컴포넌트로 해결되지 않는 경우
  - 사용자와 상호작용하는 경우
  - useEffect, useState, onClick, onChange와 같은 API를 사용해야 하는 경우
  - useRouter, useParams와 같은 nextjs의 client component API를 사용하는 경우

- 클라이언트 컴포넌트 사용 사례

  - 최상단 `"use client";` 를 통한 클라이언트 컴포넌트 사용 선언
  - `metadata`는 서버 컴포넌트에서 사용하기에 주석 처리

    ```jsx
    "use client";

    import Link from "next/link";
    import "./globals.css";
    import { useEffect, useState } from "react";

    // export const metadata = {
    //   title: "Web tutorials",
    //   description: "Generated by gonasooc",
    // };

    export default function RootLayout({ children }) {
      const [topics, setTopics] = useState([]);

      useEffect(() => {
        fetch("http://localhost:9999/topics")
          .then((resp) => {
            return resp.json();
          })
          .then((result) => {
            setTopics(result);
          });
      }, []);
      return (
        <html>
          <body>
            <h1>
              <a href="/">WEB</a>
            </h1>
            <ol>
              {topics.map((topic) => {
                return (
                  <li key={topic.id}>
                    <Link href={`/read/${topic.id}`}>{topic.title}</Link>
                  </li>
                );
              })}

              {/* <li>
                <Link href="/read/2">css</Link>
              </li> */}
            </ol>
            {children}
            <ul>
              <li>
                <Link href="/create">Create</Link>
              </li>
              <li>
                <Link href="/update/1">Update</Link>
              </li>
              <li>
                <input type="button" value="delete" />
              </li>
            </ul>
          </body>
        </html>
      );
    }
    ```

- 서버 컴포넌트 전환

  - 함수 자체를 비동기로 처리하기 위해 `async` 선언

    ```jsx
    import Link from "next/link";
    import "./globals.css";

    export const metadata = {
      title: "Web tutorials",
      description: "Generated by gonasooc",
    };

    export default async function RootLayout({ children }) {
      const resp = await fetch("http://localhost:9999/topics");
      const topics = await resp.json();
      return (
        <html>
          <body>
            <h1>
              <a href="/">WEB</a>
            </h1>
            <ol>
              {topics.map((topic) => {
                return (
                  <li key={topic.id}>
                    <Link href={`/read/${topic.id}`}>{topic.title}</Link>
                  </li>
                );
              })}

              {/* <li>
                <Link href="/read/2">css</Link>
              </li> */}
            </ol>
            {children}
            <ul>
              <li>
                <Link href="/create">Create</Link>
              </li>
              <li>
                <Link href="/update/1">Update</Link>
              </li>
              <li>
                <input type="button" value="delete" />
              </li>
            </ul>
          </body>
        </html>
      );
    }
    ```

- 서버 컴포넌트 사용의 장점
  - 간결한 코드: useEffect와 useState와 같은 훅을 사용하지 않아도 되므로, 코드가 더 간결하고 이해하기 쉬워집니다. 이로 인해 코드 유지 관리가 쉬워지고, 버그 발생 확률이 줄어들 수 있습니다.
  - 빠른 데이터 엑세스: 데이터베이스와 같은 자원에 접근해야 하는 경우, 서버 컴포넌트는 서버와 데이터베이스가 가까운 위치에서 작동하므로, 더 빠른 속도로 필요한 데이터에 접근할 수 있습니다.
  - 보안: 서버 컴포넌트는 클라이언트에 민감한 정보(예: 데이터베이스 비밀번호)를 전송하지 않습니다. 이로 인해, 필요한 작업을 안전하게 처리하면서 동시에 클라이언트의 보안을 유지할 수 있습니다.
  - 향상된 성능: 서버 컴포넌트는 클라이언트로 JavaScript 코드를 전송하지 않습니다. 이는 전송되는 데이터의 양을 줄이고, 클라이언트의 부하를 줄임으로써 웹사이트의 전반적인 성능을 향상시키는데 도움이 됩니다.
