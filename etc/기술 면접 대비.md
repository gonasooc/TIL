# 클로저에 대해 설명해주세요.

## 내용 정리

- 함수의 호출 위치에 따라 scope 범위가 달라진다면 dynamic scope라고 할 수 있겠지만 자바스크립트는 dynamic scope가 아닌 static scope를 채택하고 있습니다. 자바스크립트의 함수의 유효 범위는 그 함수가 어디서 실행됐느냐가 아니라 어디서 정의됐느냐에 따라서 달라집니다. static scope는 lexical scope라고도 부르는데, 함수를 함수 안에 정의하면 그 함수의 부모 함수의 scope에 접근할 수 있습니다. 즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말합니다.
- 자바스크립트는 기본적으로 어휘적 환경(Lexical environment)을 갖고, 코드가 실행되면 스크립트 내에서 선언한 변수들이 어휘적 환경에 올라갑니다. 코드에서 변수를 찾을 때 유효 범위 안의 내부에서 찾고, 없으면 외부, 거기에도 없으면 전역 Lexical까지 범위를 넓혀서 찾습니다. 클로저는 결국 함수와 렉시컬 환경의 조합입니다. 함수가 생성될 당시의 외부 변수를 기억해서 사용할 수 있으며, 생성 이후에도 계속 접근 가능합니다. 식별자에 대한 직접적인 접근을 막을 수 있기 때문에 캡슐화 및 은닉화가 가능하지만, 역으로 무분별하게 사용한다면 쓸데없이 메모리를 낭비할 수 있기 때문에 해제를 통해 메모리 소모를 줄여야 합니다.
- 클로저는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다. 자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 꼭 그것 때문이라고는 할 수 없지만 다양한 문헌에서 제각각 클로저를 다르게 정의하거나 설명하는 경우가 많습니다.

## 꼬리 질문

### ECMAScript는 무엇인가요?

- ECMA International이라는 비영리 국제 표준화 기구에서 JS 발전이나 변화 등을 관리
- 규칙이나 준수사항 등을 ECMA-262이라는 문서로 관리하게 되는데 이 문서의 내용을 ECMAScript
- 변화가 있을 때마다 ES1, ES2 형식으로 부르다가 6 버전이 등장한 2015년부터는 1년마다 출시하기로 결정하면서 편의상 ES6라고 부르지만 정식 명칭은 뒤에 연호를 달아서 ES2015, ES2016의 형식
- ES6 버전은 JavaScript의 많은 부분을 보완한 버전 → ES5가 가지고 있던 문제점들을 보완하고(Arrow function, let, for of 등), 코드를 더 간결하게 작성할 유용한 문법들이 등장
- 현시점에 사용하기 적합한 범위 내에서 최신 버전의 표준을 준수하는 자바스크립트를 모던 자바스크립트라고 부름

### 가비지 컬렉션

- https://ko.javascript.info/closure#ref-220

## 참고자료

- 코어 자바스크립트(정재남)
- https://poiemaweb.com/js-closure
- https://ko.javascript.info/closure
- https://youtu.be/4_WLS9Lj6n4?t=4699
- https://youtu.be/bwwaSwf7vkE

꼬리질문

- 클로저를 남발했을 때 퍼포먼스가 저하된다고 했는데 혹시 그런 경험이 있나요?
- 클로저는 함수에서만 일어나는 현상?
- 클로저와 커링과의 차이
- 클로저를 사용한 예시 → useState의 set함수
- **실행 컨텍스트**의 개념..? → 함수가 실행되는 시점에 자바스크립트 엔진에 스택이 쌓이고 실행 컨테스트 ..?
- 리액트의 클로저 개념
- 클로저와 가비지컬렉션의 관계
- https://dkje.github.io/2020/09/18/Closure/
- React의 useState와 클로저와의 관계
- https://kyoung-jnn.com/posts/react-useState
- 어휘적 환경 → 함수가 선언이 될 때 환경 → 레코드..? 스코프 체이닝을 관장하는 영역
- 사용 예시 → useState, styledComponents 커링함수?
- 커링 → 함수가 여러 개 뭉쳐 있는..? 함수형 프로그래밍
- 내부 슬롯 Environment → Prototype 안에 ..
- dynamic scope에서는 lexical scope가 없는지

# 호이스팅에 대해 설명해주세요.

## 내용 정리

- 변수를 예로 들자면, 변수 선언이 나중에 되었음에도 마치 선언이 위에서 된 것처럼 작동하는데, scope 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동하는 걸 hoisting이라고 할 수 있습니다. 단, 할당된 value 자체는 hoisting되지 않는데, 선언은 hoisting되지만 할당은 hoisting되지 않기 때문입니다.
- TDZ(Temporal Dead Zone) 영역에 있는 변수들은 사용할 수 없는데, let과 const는 TDZ의 영향을 받기 때문에 할당을 하기 전에는 사용할 수 없습니다. 이는 코드를 예측 가능하게 하고 잠재적인 버그를 줄일 수 있습니다.
- 함수에서도 hoisting이 발생하는데, 함수 선언식의 경우 hoisting에 따라서 실제 컴파일할 때 끌어올려지기 때문에 선언된 위치와 별개로 사용이 가능합니다. 다만 함수 표현식의 경우 hoisting이 일어나기 않기 때문에 좀 더 엄격하게 작동한다고 볼 수 있습니다.
- 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있습니다. 함수 hoisting이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적하기도 했습니다.

## 꼬리 질문

### TDZ(Temporal Dead Zone)

## 참고자료

- https://youtu.be/4_WLS9Lj6n4?t=128
- [https://velog.io/@jangwonyoon/호이스팅과-TDZ는-무엇이고-어떤-연관이-있을까요](https://velog.io/@jangwonyoon/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EA%B3%BC-TDZ%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%96%B4%EB%96%A4-%EC%97%B0%EA%B4%80%EC%9D%B4-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94)
- https://deftkang.tistory.com/17
- https://poiemaweb.com/js-function

꼬리질문

- **호이스팅 → 호이스팅은 식별자의 선언문이 스코프의 맨 위로 끌어 올려진 것처럼 동작하는 현상을 의미합니다. 이는 자바스크립트 엔진이 컴파일 과정에서 모든 스코프를 탐색하며 각 스코프의 식별자를 수집하여 선언된 식별자 정보를 이미 알고 있기 때문에 발생하는 현상입니다.**
- 호이스팅이 자바스크립트에서만 일어나는 현상일까요? → 왜 그럴까요?
- 다른 언어에는 호이스팅이 개념이 없는지?
- var로 선언한 함수표현식은 호이스팅이 되는지?
- TDZ →
- 호이스팅은 장점인가요 단점인가요
- 자바스크립트가 싱글 스레드 → 멀티 스레드

# 스코프에 대해 설명해주세요.

## 내용 정리

- scope는 참조의 대상이 되는 식별자(identifier)를 찾기 위한 유효한 범위라고 볼 수 있습니다. 자바스크립트는 이 규칙대로 식별자를 찾게 됩니다. 크게 전역 스코프(Global scope)와 지역 스코프(Local scope or Function-level scope)로 나눌 수 있는데, 전역 스코프는 코드 어디에서든지 참조할 수 있고 지역 스코프는 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조가 가능합니다.
- 대부분의 C-family language는 블록 레벨 스코프(block-level scope)를 따르지만 자바스크립트는 함수 레벨 스코프(function-level scope)를 따릅니다. 단, ES6에서 도입된 let을 사용하면 블록 레벨 스코프를 사용할 수 있고, 상황에 따라 let 사용을 권고하는 경우가 많습니다.
- 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 꼭 필요한 경우에만 사용하는 것이 좋습니다.

## 꼬리 질문

### 함수 레벨 스코프(Function-level scope)

- 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.

### 블록 레벨 스코프(Block-level scope)

- 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.

### C-family language

- "C-family language"는 주로 C 프로그래밍 언어와 그와 관련된 언어들을 일컫는 용어입니다. C 프로그래밍 언어는 1970년대에 처음 개발된 프로그래밍 언어로, 컴퓨터 과학 및 소프트웨어 개발 분야에서 널리 사용되는 중요한 언어 중 하나입니다. C 언어는 단순하면서도 강력한 기능을 제공하여 시스템 프로그래밍, 응용 프로그래밍, 임베디드 시스템 등 다양한 분야에서 사용됩니다. 또한 C 언어는 많은 다른 프로그래밍 언어의 기반이 되었고, 많은 프로그래밍 언어가 C 언어의 문법과 구조를 모방하거나 확장하여 개발되었습니다. 이런 언어들을 통틀어 "C-family language"라고 부르는 것입니다. 예를 들어, C++는 C 언어의 기능을 확장하여 객체 지향 프로그래밍을 지원하는 언어로, C 언어의 특징을 계승하면서도 더 많은 기능을 추가하였습니다. 또한 C#(C Sharp)은 Microsoft에서 개발한 언어로, C++과 Java 등의 영향을 받아 개발된 언어입니다. 이런 언어들이 C-family language의 일부로 간주됩니다.

## 참고자료

- https://poiemaweb.com/js-scope
- https://poiemaweb.com/es6-block-scope

꼬리질문

- 블록 레벨 스코프에서 var를 사용하는 경우 →
- 스코프의 중첩

# var, const, let 차이점을 설명해주세요.

## 내용 정리

- var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프입니다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능합니다. var는 변수의 중복 선언을 허용합니다. hoisting이 적용되기 때문에 선언하기 전부터 사용이 가능합니다.
- var에서 적용되는 내용 모두 불가능합니다. 블록 스코프로 작동되고 중복 선언이 불가능하며, let은 생성 시 TDZ(Temporal Dead Zone) 구간에 들어가게 되어 선언하기 전에는 reference error가 발생합니다.
- const는 재할당 및 재선언 자체가 금지됩니다.

## 꼬리 질문

## 참고자료

- https://ko.javascript.info/var
- https://ko.javascript.info/variables
- https://taenami.tistory.com/87

꼬리질문

- 선언문
- const는 재할당이 안 된다고 했는데.. → 원시타입은 재할당 자체가 불가능하다, 객체나 배열은 참조타입의 경우 주소 자체는 .. 힙에 저장된 값을 변경할 수 있다 매서드나 프로퍼티로 접근해서 변경 가능하다
- 런타임과 컴파일타임

# callback, promise, async/await의 차이점을 설명해주세요.

## 내용 정리

- 콜백 함수는 쉽게 말해서 다른 코드의 인자로 넘겨주는 함수라고 볼 수 있습니다. 콜백 함수를 넘겨 받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행합니다. 말 그대로 콜백 함수는 다른 함수에게 인자로 넘겨줌으로써 그 제어권도함께 위임한 함수입니다. 다만 비동기 작업을 수행하기 위해 함수를 전달하는 과정이 반복되면서 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 콜백 지옥(callback hell) 현상이 생길 수 있는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 어렵습니다.
- 그런 일련의 과정 속에서 자바스크립트 진영은 비동기적인 일련의 작업을 동기적으로, 혹은 동기적인 것처럼 보이게끔 처리해주는 장치를 마련하게 되는데, 그게 ES6에서는 Promise Generator, ES2017에서는 async/await라고 볼 수 있습니다.
- new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve나 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 오류 구문(catch)으로 넘어가지 않습니다.
- 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고, 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve된 이후에야 다음으로 진행합니다. Promise 문법을 사용하면서도 동시에 가독성이 뛰어나고 작성법도 간단하다고 볼 수 있습니다.

## 꼬리 질문

## 참고자료

- 코어 자바스크립트(정재남)

# 이벤트 버블링, 캡쳐링에 대해 설명해주세요.

## 내용 정리

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는데, 이런 흐름을 물 속 거품과 닮았다고 해서 이벤트 버블링이라고 부릅니다. focus 이벤트와 같이 버블링 되지 않는 이벤트도 있지만, 거의 모든 이벤트는 버블링이 된다고 볼 수 있습니다. 이벤트 버블링과 반대 방향으로 탐색하는 걸 이벤트 캡쳐링이라고 합니다.
- 프레임워크의 별도의 내장함수나 JavaScript 자체의 stopPropagation()이라는 웹API를 통해서 해당 이벤트가 전파되는 걸 막을 수 있으나 버블링은 사용자의 행동 패턴을 분석하는 등 유용하게 사용될 여지가 있기 때문에 아니텍처를 잘 고려해서 정말 막아야 하는 상황에서만 막는 편이 좋습니다.

## 꼬리 질문

## 참고자료

- https://ko.javascript.info/bubbling-and-capturing
- https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/

# 브라우저 렌더링 원리에 대해 설명해주세요.

## 내용 정리

- 우선 브라우저는 사용자의 요청에 따라 서버로부터 HTML, CSS, JavaScript, 그리고 이미지 파일을 포함한 에셋들을 응답 받습니다. HTML, CSS 파일은 랜더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 랜더 트리로 결합됩니다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 출력하게 됩니다.
- 다만 자바스크립트는 랜더링 엔진이 아닌 자바스크립트 엔진이 처리합니다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해서 진행 중이던 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘깁니다. 자바스크립트 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 다시 DOM 생성을 재개합니다.
- 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, JavaScript를 처리하기 때문에 script 태그의 위치에 따라 블로킹이 발생하여 DOM 생성 자체를 지연시킬 수도 있습니다. 따라서 떄에 따라 script 태그의 위치가 중요하게 작용합니다.
- 보편적으로 body 요소 아래에 자바스크립트를 위치하는 것이 좋은 것으로 알고 있습니다. HTML 요소들이 스크립트 로딩 지연으로 인해 랜더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축되고, DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수밖에 없는데 그런 부분을 미연에 방지할 수 있습니다.

## 꼬리 질문

## 참고자료

- https://poiemaweb.com/js-browser
- https://youtu.be/-CATiyw2-Ns
- https://youtu.be/sJ14cWjrNis

# 이벤트 루프에 대해 설명해주세요.

## 내용 정리

- 브라우저는 싱글쓰레드에서 특정 이벤트에 반응해서 동작을 변경하는 방식(event-driven)으로 작동합니다. 하지만 실제로 동작하는 웹 애플리케이션은 많은 태스크가 동시에 처리되는 것처럼 느껴지는데, 이러한 동시성(Concurrency)을 지원하는 것이 이벤트 루프입니다.
- 이벤트 루프는 태스크가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없으면 잠드는 방식을 반복하는 자바스크립트 내의 루프입니다. 이 이벤트 루프를 기반으로 자바스크립트 엔진은 대부분의 시간 동안 별도의 작업 없이 쉬고 있다가 스크립트나 핸들러, 이벤트가 활성화될 때만 돌아갑니다.

## 꼬리 질문

## 참고자료

- https://poiemaweb.com/js-event
- https://ko.javascript.info/event-loop
