# 클로저에 대해 설명해주세요.

## 내용 정리

- 함수의 호출 위치에 따라 scope 범위가 달라진다면 dynamic scope라고 할 수 있겠지만 자바스크립트는 dynamic scope가 아닌 static scope를 채택하고 있습니다. 자바스크립트의 함수의 유효 범위는 그 함수가 어디서 실행됐느냐가 아니라 어디서 정의됐느냐에 따라서 달라집니다. static scope는 lexical scope라고도 부르는데, 함수를 함수 안에 정의하면 그 함수의 부모 함수의 scope에 접근할 수 있습니다. 즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말합니다.
- 자바스크립트는 기본적으로 어휘적 환경(Lexical environment)을 갖고, 코드가 실행되면 스크립트 내에서 선언한 변수들이 어휘적 환경에 올라갑니다. 코드에서 변수를 찾을 때 유효 범위 안의 내부에서 찾고, 없으면 외부, 거기에도 없으면 전역 Lexical까지 범위를 넓혀서 찾습니다. 클로저는 결국 함수와 렉시컬 환경의 조합입니다. 함수가 생성될 당시의 외부 변수를 기억해서 사용할 수 있으며, 생성 이후에도 계속 접근 가능합니다. 식별자에 대한 직접적인 접근을 막을 수 있기 때문에 캡슐화 및 은닉화가 가능하지만, 역으로 무분별하게 사용한다면 쓸데없이 메모리를 낭비할 수 있기 때문에 해제를 통해 메모리 소모를 줄여야 합니다.
- 클로저는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다. 자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 꼭 그것 때문이라고는 할 수 없지만 다양한 문헌에서 제각각 클로저를 다르게 정의하거나 설명하는 경우가 많습니다.
- ES3까지는 실행 컨텍스트 없이 dynamic scope였는데, ES5 이후 (2009년~)부터는 어디에 선언되어 있느냐에 따라 정적으로 결정되어 하나의 실행 컨테스트 개념으로 묶였습니다.

## 꼬리 질문

- ECMAScript는 무엇인가요?
  - ECMA International이라는 비영리 국제 표준화 기구에서 JS 발전이나 변화 등을 관리
  - 규칙이나 준수사항 등을 ECMA-262이라는 문서로 관리하게 되는데 이 문서의 내용을 ECMAScript
  - 변화가 있을 때마다 ES1, ES2 형식으로 부르다가 6 버전이 등장한 2015년부터는 1년마다 출시하기로 결정하면서 편의상 ES6라고 부르지만 정식 명칭은 뒤에 연호를 달아서 ES2015, ES2016의 형식
  - ES6 버전은 JavaScript의 많은 부분을 보완한 버전 → ES5가 가지고 있던 문제점들을 보완하고(Arrow function, let, for of 등), 코드를 더 간결하게 작성할 유용한 문법들이 등장
  - 현시점에 사용하기 적합한 범위 내에서 최신 버전의 표준을 준수하는 자바스크립트를 모던 자바스크립트라고 부름
- 가비지 컬렉션은 무엇인가요?
  - https://ko.javascript.info/closure#ref-220
- 클로저의 장점과 단점은 무엇인가요? 어느 때에 사용해야 더 좋을까요?
- 클로저는 왜 사용하나요?
- 클로저가 상태 유지에 도움되는 이유가 무엇인가요?
- 클로저가 useState와 차이점은 무엇인가요?
- 클로저는 함수 내에서만 일어나는 현상인가요?
- 클로저와 비슷한 개념으로 커링에 대해서도 알고 계신가요?
- 클로저를 사용하는 상황은 어떤 상황이 있을지 예시를 들어 설명해주세요!
- 실행 컨텍스트에 대해 설명해주세요!

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://poiemaweb.com/js-closure
- https://ko.javascript.info/closure
- https://youtu.be/4_WLS9Lj6n4?t=4699
- https://youtu.be/bwwaSwf7vkE

## 스터디 메모

- https://kyoung-jnn.com/posts/react-useState

# 호이스팅에 대해 설명해주세요.

## 내용 정리

- 변수를 예로 들자면, 변수 선언이 나중에 되었음에도 마치 선언이 위에서 된 것처럼 작동하는데, scope 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동하는 걸 hoisting이라고 할 수 있습니다. 단, 할당된 value 자체는 hoisting되지 않는데, 선언은 hoisting되지만 할당은 hoisting되지 않기 때문입니다.
- TDZ(Temporal Dead Zone) 영역에 있는 변수들은 사용할 수 없는데, let과 const는 TDZ의 영향을 받기 때문에 할당을 하기 전에는 사용할 수 없습니다. 이는 코드를 예측 가능하게 하고 잠재적인 버그를 줄일 수 있습니다.
- 함수에서도 hoisting이 발생하는데, 함수 선언식의 경우 hoisting에 따라서 실제 컴파일할 때 끌어올려지기 때문에 선언된 위치와 별개로 사용이 가능합니다. 다만 함수 표현식의 경우 hoisting이 일어나기 않기 때문에 좀 더 엄격하게 작동한다고 볼 수 있습니다.
- 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있습니다. 함수 hoisting이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적하기도 했습니다.
- 함수 표현식의 경우 변수(var / let, const)의 호이스팅과 동일하게 동작하는 반면, 함수 선언식은 자바스크립트 엔진이 해당 함수의 선언과 동시에 완성된 함수 객체를 생성해서 환경 레코드에 기록해둡니다. 따라서 호이스팅되어 선언이 되기 전에도 실행이 가능하다고 볼 수 있습니다.

## 꼬리 질문

- TDZ(Temporal Dead Zone)가 무엇인가요?
- 왜 let과 const만 TDZ가 적용되나요?
- 호이스팅은 자바스크립트만의 특징인가요?
- 호이스팅이 끌어 올려지는 것 처럼 동작한다고 말씀해주셨는데, 조금 추가적으로 설명 가능하실까요?
  - 자바스크립트 엔진이 컴파일 과정에서 모든 스코프를 탐색하며 각 스코프의 식별자를 수집하여 선언된 식별자 정보를 이미 알고 있기 때문에 발생하는 현상입니다. 실행 컨텍스트와 관련이 있습니다.
- 호이스팅은 장점인가요 단점인가요?

## 참고자료

- https://youtu.be/4_WLS9Lj6n4?t=128
- [https://velog.io/@jangwonyoon/호이스팅과-TDZ는-무엇이고-어떤-연관이-있을까요](https://velog.io/@jangwonyoon/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EA%B3%BC-TDZ%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%96%B4%EB%96%A4-%EC%97%B0%EA%B4%80%EC%9D%B4-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94)
- https://deftkang.tistory.com/17
- https://poiemaweb.com/js-function

# 스코프에 대해 설명해주세요.

## 내용 정리

- scope는 참조의 대상이 되는 식별자(identifier)를 찾기 위한 유효한 범위라고 볼 수 있습니다. 자바스크립트는 이 규칙대로 식별자를 찾게 됩니다. 크게 전역 스코프(Global scope)와 지역 스코프(Local scope or Function-level scope)로 나눌 수 있는데, 전역 스코프는 코드 어디에서든지 참조할 수 있고 지역 스코프는 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조가 가능합니다.
- 대부분의 C-family language는 블록 레벨 스코프(block-level scope)를 따르지만 자바스크립트는 함수 레벨 스코프(function-level scope)를 따릅니다. 단, ES6에서 도입된 let을 사용하면 블록 레벨 스코프를 사용할 수 있고, 상황에 따라 let 사용을 권고하는 경우가 많습니다.
- 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 꼭 필요한 경우에만 사용하는 것이 좋습니다.

## 꼬리 질문

- 함수 레벨 스코프(Function-level scope)
  - 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 블록 레벨 스코프(Block-level scope)
  - 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.
- C-family language
  - "C-family language"는 주로 C 프로그래밍 언어와 그와 관련된 언어들을 일컫는 용어입니다. C 프로그래밍 언어는 1970년대에 처음 개발된 프로그래밍 언어로, 컴퓨터 과학 및 소프트웨어 개발 분야에서 널리 사용되는 중요한 언어 중 하나입니다. C 언어는 단순하면서도 강력한 기능을 제공하여 시스템 프로그래밍, 응용 프로그래밍, 임베디드 시스템 등 다양한 분야에서 사용됩니다. 또한 C 언어는 많은 다른 프로그래밍 언어의 기반이 되었고, 많은 프로그래밍 언어가 C 언어의 문법과 구조를 모방하거나 확장하여 개발되었습니다. 이런 언어들을 통틀어 "C-family language"라고 부르는 것입니다. 예를 들어, C++는 C 언어의 기능을 확장하여 객체 지향 프로그래밍을 지원하는 언어로, C 언어의 특징을 계승하면서도 더 많은 기능을 추가하였습니다. 또한 C#(C Sharp)은 Microsoft에서 개발한 언어로, C++과 Java 등의 영향을 받아 개발된 언어입니다. 이런 언어들이 C-family language의 일부로 간주됩니다.
- 스코프를 중첩해서 사용한 사례가 있나요?

## 참고자료

- https://poiemaweb.com/js-scope
- https://poiemaweb.com/es6-block-scope

# var, const, let 차이점을 설명해주세요.

## 내용 정리

- var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프입니다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능합니다. var는 변수의 중복 선언을 허용합니다. hoisting이 적용되기 때문에 선언하기 전부터 사용이 가능합니다.
- var에서 적용되는 내용 모두 불가능합니다. 블록 스코프로 작동되고 중복 선언이 불가능하며, let은 생성 시 TDZ(Temporal Dead Zone) 구간에 들어가게 되어 선언하기 전에는 reference error가 발생합니다.
- const는 재할당 및 재선언 자체가 금지됩니다.
- 요약하자면, var는 생성 단계에서 실행 컨텍스트를 생성하면서 초기화를 하기 때문에 undefined로 접근이 가능하고, let과 const는 실행 컨텍스트를 생성하면서 별도의 초기화를 하지 않기 때문에 reference error가 발생한다고 볼 수 있습니다. let 또는 const로 선언했을 때 선언 이전에 식별자를 참조할 수 없는데, 이 구역을 일시적 사각지대(Temporal Dead Zone)라고 부릅니다.
- var는 메모리 공간을 확보하고 식별자와 연결하는 선언과 식별자에 암묵적으로 undefined 값을 바인딩하는 초기화를 동시에 진행하지만, var나 const는 초기화는 하지 않기 때문에 선언 라인 전에는 변수를 참조할 수 없습니다.

## 꼬리 질문

- const는 재선언 및 재할당이 안 되지만 메서드나 프로퍼티로 접근해서 변경이 가능한데 그 부분을 자세하게 설명해주실 수 있을까요?
  - 원시타입은 재할당 자체가 불가능합니다, 다만 객체나 배열 같은 참조타입의 경우 주소 자체는 변동이 없으나 힙에 저장된 값은 매서드나 프로퍼티로 접근해서 변경 가능합니다. 하지만 직접적으로 재할당을 하고자 하면 에러가 발생합니다.

## 참고자료

- https://ko.javascript.info/var
- https://ko.javascript.info/variables
- https://taenami.tistory.com/87

# callback, promise, async/await의 차이점을 설명해주세요.

## 내용 정리

- 콜백 함수는 쉽게 말해서 다른 코드의 인자로 넘겨주는 함수라고 볼 수 있습니다. 콜백 함수를 넘겨 받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행합니다. 말 그대로 콜백 함수는 다른 함수에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수입니다. 다만 비동기 작업을 수행하기 위해 함수를 전달하는 과정이 반복되면서 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 콜백 지옥(callback hell) 현상이 생길 수 있는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 어렵습니다.
- 그런 일련의 과정 속에서 자바스크립트 진영은 비동기적인 작업을 동기적으로, 혹은 동기적인 것처럼 보이게끔 처리해주는 장치를 마련하게 되는데, 그게 ES6에서는 Promise, ES2017에서는 async/await라고 볼 수 있습니다.
- new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve나 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 오류 구문(catch)으로 넘어가지 않습니다. (pending 상태)
- 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고, 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve된 이후에야 다음으로 진행합니다. Promise 문법을 사용하면서도 단순 Promise chaining보다 가독성이 뛰어나고 작성법도 간단하다고 볼 수 있습니다.
- promise() 객체는 콜백 함수의 인자로 resolve와 reject를 가질 수 있는데, 콜백 함수의 인자로 resolve가 실행되면 fullfilled 상태가 되어 then 구문 안쪽의 프로세스로 넘어 가는 반면, reject가 실행되면 rejected 상태가 되어 catch 안쪽의 프로세스를 실행합니다.

## 꼬리 질문

- Promise 객체를 사용할 때 then 메소드를 사용해서 Promise Chaining을 사용하는데, 여기서 then 메소드의 역할이 뭔가요?
  - then 메소드는 새로운 promise 객체를 return 합니다.
- Promise 객체는 크게 3가지 중 하나의 상태를 가지게 되는데, 이 상태에 대해서 간략하게 설명해주실 수 있을까요?
  - pending(진행중) / fulfilled(성공) / rejected(실패), 작업 성공/실패 여부에 따라 promise 객체가 fulfilled나 rejected 각각의 정보를 갖게 됩니다.
- 작업하실 때 catch와 finally를 사용하신 사례가 있다면 말씀해주실 수 있으실까요?
  - catch는 해당 에러의 내용이나 별도의 router 이동을 하게 만들기 위해서 작성했었고, finally는 말 그대로 promise 객체가 fullfilled가 되든 rejected가 되든 항상 마지막에 실행하고자 하는 callback이 있을 때 사용했습니다. 예컨대 promise chaining에서 사용한 어떤 값을 지워줘야 한다거나 최종적으로 별도의 log를 남겨야 할 때 정도가 될 거 같습니다.
- promise에서 resolve와 reject는 어떤걸 의미하는지 알고계신가요?
- try, catch 외 finally를 사용해보신 적이 있으신지 설명해주세요.
- promise의 resolve, reject의 처리 결과는 어떻게 얻을 수 있나요?
- promise와 다른 async/await의 차이는 무엇인가요?
- Promise.all()

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- JS중급 - 자바스크립트 웹 개발 기본기 by 코드잇

# 이벤트 버블링, 캡쳐링에 대해 설명해주세요.

## 내용 정리

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는데, 이런 흐름을 물 속 거품과 닮았다고 해서 이벤트 버블링이라고 부릅니다. focus 이벤트와 같이 버블링 되지 않는 이벤트도 있지만, 거의 모든 이벤트는 버블링이 된다고 볼 수 있습니다. 이벤트 버블링과 반대 방향으로 탐색하는 걸 이벤트 캡쳐링이라고 합니다.
- 프레임워크에 별도의 내장함수나 JavaScript 자체의 stopPropagation()이라는 웹API를 통해서 해당 이벤트가 전파되는 걸 막을 수 있으나 버블링은 이벤트 위임을 통해 사용자의 행동 패턴을 분석하는 등 유용하게 사용될 여지가 있기 때문에 아키텍처를 잘 고려해서 정말 막아야 하는 상황에서만 막는 편이 좋습니다.

## 꼬리 질문

- 이벤트 버블링을 막지 않고 이벤트 위임을 유용하게 사용될 여지가 있다고 했는데, 혹시 어떤 사례가 있을까요?
  - 실제로 분석에 이용해본 경험은 없지만 예컨대 GA 같은 사용자 패턴 분석 툴이 적용되어 있는 경우 depth가 깊은 메뉴에 있어서 사용자가 하위 메뉴를 클릭했을 때 상위 메뉴까지의 이벤트 위임을 통해서 분석에 활용된다는 사례를 본 적이 있긴 합니다.
- 이벤트 캡처링과 버블링 중에 어떤 것이 우선 동작하나요?
- 이벤트 핸들링을 캡쳐링이 아니라 버블링에서 하는 이유가 무엇인가요?
- 이벤트리스너의 DOM 요소를 찾을 때 캡쳐링의 동작 방식에 대해 설명해주실 수 있을까요?
  - 자바스크립트의 이벤트 모델은 기본적으로 캡쳐링과 버블링 두 단계로 이루어지는데, 이 중 캡쳐링 단계는 이벤트가 최상위 요소에서부터 하위 요소로 향하는 단계입니다. 따라서 특별한 설정을 하지 않아도 이벤트가 발생하면 캡쳐링 단계도 일어납니다. 이벤트 리스너를 등록할 때 addEventListener 함수의 세 번째 매개변수로 전달하는 useCapture 매개변수를 true로 설정하면, 해당 이벤트 리스너는 캡쳐링 단계에서 호출됩니다. 그러나 useCapture 매개변수를 생략하거나 false로 설정하면, 기본적으로는 이벤트 리스너가 버블링 단계에서 호출됩니다. 다시 말해, 캡쳐링이 발생하지 않는다는 것이 아니라, useCapture 매개변수를 명시적으로 true로 설정하지 않으면 기본적으로는 버블링 단계에서 이벤트가 처리된다는 것이 맞습니다.

## 참고자료

- https://ko.javascript.info/bubbling-and-capturing
- https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/
- JS중급 - 자바스크립트 웹 개발 기본기 by 코드잇

# 브라우저 렌더링 원리에 대해 설명해주세요.

## 내용 정리

- 우선 브라우저는 사용자의 요청에 따라 서버로부터 HTML, CSS, JavaScript, 그리고 이미지 파일을 포함한 에셋들을 응답 받습니다. HTML, CSS 파일은 랜더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 랜더 트리로 결합됩니다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 출력하게 됩니다.
- 다만 자바스크립트는 랜더링 엔진이 아닌 자바스크립트 엔진이 처리합니다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해서 진행 중이던 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘깁니다. 자바스크립트 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 다시 DOM 생성을 재개합니다.
- 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, JavaScript를 처리하기 때문에 script 태그의 위치에 따라 블로킹이 발생하여 DOM 생성 자체를 지연시킬 수도 있습니다. 따라서 떄에 따라 script 태그의 위치가 중요하게 작용합니다.
- 보편적으로 body 요소 아래에 자바스크립트를 위치하는 것이 좋은 것으로 알고 있습니다. HTML 요소들이 스크립트 로딩 지연으로 인해 랜더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축되고, DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수밖에 없는데 그런 부분을 미연에 방지할 수 있습니다.

## 꼬리 질문

- body 태그를 기준으로 script 태그는 어디에 위치하는 편이 좋을까요? 만약 상단에 script 태그가 위치해야 하는 상황이라면 어떻게 제어해야 할까요?
  - 보편적으로 body 태그 아래에 스크립트 태그를 위치하는 편이 좋고, 만약 상단에 위치해야 한다면 defer, async 문법을 통해서 비동기적으로 처리가 가능합니다.
- DOM 생성 중에 style이나 link 태그를 만나게 되면 어떻게 처리되게 되나요?
  - script 태그와 동일하게 DOM 생성을 일시 중단하고 CSSOM을 생성합니다.
- inline style 사용을 지양해야 하는 이유에 대해서 설명해주실 수 있나요?
  - 성능 최적화와 관련이 있는데, React의 경우 변화 감지 메커니즘을 사용하기 때문에 매번 스타일 객체를 생성할 경우 해당 style 객체의 비교가 항상 false로 나오게 됩니다. 그 과정에서 불필요한 리랜더링이 발생할 가능성이 높아집니다. 그리고 일반적인 개발 환경에서도 reflow가 발생하기 때문에 최적화가 적합하지 못합니다.
- repaint, reflow란?
  - [https://velog.io/@young_pallete/Reflow-Repaint을-알아보자](https://velog.io/@young_pallete/Reflow-Repaint%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

## 참고자료

- https://poiemaweb.com/js-browser
- https://youtu.be/-CATiyw2-Ns
- https://youtu.be/sJ14cWjrNis
- https://ko.javascript.info/script-async-defer

# 이벤트 루프에 대해 설명해주세요.

## 내용 정리

- 브라우저는 싱글쓰레드에서 특정 이벤트에 반응해서 동작을 변경하는 방식(event-driven)으로 작동합니다. 하지만 실제로 동작하는 웹 애플리케이션은 많은 태스크가 동시에 처리되는 것처럼 느껴지는데, 이러한 동시성(Concurrency)을 지원하는 것이 이벤트 루프입니다.
- 이벤트 루프는 태스크가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없으면 잠드는 방식을 반복하는 자바스크립트 내의 루프입니다. 이 이벤트 루프를 기반으로 자바스크립트 엔진은 대부분의 시간 동안 별도의 작업 없이 쉬고 있다가 스크립트나 핸들러, 이벤트가 활성화될 때만 돌아갑니다.

## 꼬리 질문

- promise와 setTimeout의 우선순위는 어떻게 되나요?
  - [https://velog.io/@dbfudgudals/자바스크립트-실행순서를-뜯어보자](https://velog.io/@dbfudgudals/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89%EC%88%9C%EC%84%9C%EB%A5%BC-%EB%9C%AF%EC%96%B4%EB%B3%B4%EC%9E%90)
- 자바스크립트에게 동시성을 지원하는 것이 구체적으로 어떤 의미인가요?
- 콜스택과 콜백큐를 감시한다는 의미가 무엇인가요?
- 콜백큐에는 어떻게 작업이 쌓이게 되나요?
- 멀티스레드처럼 동작하는 이유가 무엇인가요?

## 참고자료

- https://poiemaweb.com/js-event
- https://ko.javascript.info/event-loop

## 스터디 메모

# 실행 컨텍스트에 대해 설명해주세요.

## 내용 정리

- 실행 컨텍스트는 코드를 실행하는데 필요한 환경을 제공하는 객체라고 할 수 있습니다. 여기서 환경이라고 하면 코드를 실행에 영향을 주는 조건이나 상태를 말하는데, 식별자 결정을 더욱 효율적으로 하기 위한 수단으로 필요한 정보를 한데 모아 제공하는 객체가 실행 컨텍스트입니다.
- 예컨대 var를 선언하고 최상단에 var를 console.log로 찍어봤을 때 에러가 나지 않고 undefined 찍히는 호이스팅이 발생하는데, 이런 호이스팅이 생기는 이유는 자바스크립트 엔진이 먼저 전체 코드를 스캔하면서 변수 같은 정보를 실행컨텍스트에 기록해놓기 때문입니다. 이때 나오는 개념이 실행 컨텍스트입니다. (물론 console.log 또한 내장함수이기 때문에 이 함수의 실행 컨텍스트 또한 생기는 게 맞습니다)
- 이때 var를 기록해놓는 곳이 바로 환경 레코드(Environment Record)로 식별자와 식별자에 바인딩된 값을 기록해두는 객체입니다.
- 또한 스코프 체이닝을 위해 외부 환경 정보를 구성하는데, 외부 환경 참조(Outer Environment Reference)는 선언되었을 당시의 상위 Lexical Environment를 참조합니다. 그래서 자바스크립트 엔진은 새로 생성된 실행 컨텍스트에 바깥 렉시컬 환경으로 돌아갈 수 있는 outer를 남겨 놓습니다. 그래서 필요한 경우에 이전 실행 컨텍스트의 환경레코드에 저장된 식별자로 참조할 수 있게 됩니다.
- 식별자 결정(Identifier Resolution - 코드에서 변수나 함수의 값을 결정하는 것)을 하고자 할 때 현재 활성화된 실행 컨텍스트의 환경 레코드를 찾고, 바깥 렉시컬 환경에서 찾아보고, 끝내 없으면 전역 실행 컨텍스트까지 찾게 됩니다. 이러한 과정에서 사용되는 개념이 실행 컨텍스트라고 할 수 있습니다.
- 식별자 결정을 진행할 때 변수 섀도잉(Variable Shadowing)이 발생하는데, 동일한 식별자로 인해 상위 스코프에서 선언된 식별자의 값이 가려지는 현상을 말합니다.
- 식별자를 결정할 때 활용하는 스코프들의 연결리스트를 스코프 체인(Scope Chain)이라고 하고, 이러한 과정 자체를 스코프 체이닝이라고 합니다.

## 꼬리 질문

- 렉시컬 환경에 대해 설명해주세요.
- this binding에 대해 설명해주세요.
- 클로저와 호이스팅에 대해 설명해주세요.

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://www.zerocho.com/category/JavaScript/post/5741d96d094da4986bc950a0
- https://youtu.be/EWfujNzSUmw

# this에 대해 설명해주세요.

## 내용 정리

- 실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장됩니다. 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체(브라우저 환경에서는 window, Node.js 환경에서는 global)가 저장됩니다. 그 외에는 함수를 호출하는 방법에 따라서 this에 저장되는 객체가 달라집니다.
- 객체 내 메소드가 호출되는 경우 그 안에 있는 this는 해당 객체를 가리키지만, 해당 메소드를 별도의 변수에 담아서 전역에서 호출하는 경우에는 다시 window를 가리키게 됩니다. new를 붙여서 생성자 함수를 호출하게 되면 this는 생성자를 통해 생성된 인스턴스, 그 자신이 됩니다. 다만 이벤트 리스너를 사용하는 경우 window가 아닌 이벤트가 발생하는 해당 객체를 가리키게 됩니다. 때문에 이벤트 리스너를 사용하는 경우엔 내부의 this가 바꼈음을 명시적으로 알리거나 ES6의 arrow function을 사용하는 편이 좋습니다. arrow function 사용 시 해당 함수 안에 this는 window가 아닌 상위 함수의 this를 가리키게 됩니다.

## 꼬리 질문

- 화살표 함수와 일반적인 함수 선언문(function 키워드로 정의한 함수)에서 this를 사용할 때 중요한 차이점은 무엇인가요?
- this는 왜 사용하나요?
- this를 명시적으로 binding하는 방법도 있을까요?
- 암시적 binding에 대해 설명해주세요.
- 객체의 내부 메서드 안에 메서드를 작성하게 되면 해당 메서드 안의 this는 무엇을 가리키나요?

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://www.zerocho.com/category/JavaScript/post/5b0645cc7e3e36001bf676eb

# prototype에 대해 설명해주세요.

## 내용 정리

- 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있습니다. 이건 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티나 메소드를 상속 받아서 사용할 수 있게 됩니다. 이러한 부모 객체를 프로토타입(Prototype) 객체 또는 줄여서 프로토타입이라고 합니다.
- 예컨대 하나의 배열을 만들면 new Array() 의 디폴트 생성자가 내부에서 동작해서 해당 Array.prototype이 해당 배열의 프로토타입이 되고, 우리는 그걸 통해 length나 map과 같은 배열과 관련된 내장함수를 사용할 수 있게 됩니다. 이런 내부 동작은 메모리 효율을 높여주는 장점으로 작용합니다.
- 이와 같이 어떤 객체에 특정 프로퍼티나 메서드에 접근할 때 특정 프로퍼티나 메서드가 없다면 내부 링크를 통해 상위 프로토타입으로 접근하는 행위를 프로토타입 체인이라고 하는데, 이런 과정에서 볼 수 있듯이 자바스크립트는 프로토타입 객체지향을 사용하고 있습니다.

## 꼬리 질문

-

## 참고자료

- https://poiemaweb.com/js-prototype
- https://ko.javascript.info/native-prototypes
- https://youtu.be/wT1Bl5uV27Y?si=24PIg3EQBdHu_fOO

# oop와 특징에 대해 설명해주세요.

## 내용 정리

- 객체 지향 프로그래밍은 프로퍼티와 메소드로 이루어진 각 객체들의 상호 작용을 중심으로 코드를 작성하는 것을 말합니다. 객체 지향 프로그래밍은 크게 추상화, 캡슐화, 상속, 다형성 이렇게 네 가지의 특징을 갖고 있습니다. 우선 추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미합니다. 추상화는 React 같은 컴포넌트 기반의 라이브러리에서도 사용하는 개념인데 재사용성과 범용성 이 두 가지에 밀접한 관계가 있겠습니다. 캡슐화는 서로 연관되어 있는 속성과 기능들을 하나의 캡슐로 만들어 객체의 특정 프로퍼티에 직접 접근하지 못하도록 막고 외부로부터 보호하는 것을 뜻합니다. 핵심 키워드는 데이터의 보호와 은닉입니다. getter, setter를 통해 캡슐화를 구현할 수 있습니다. 그 다음엔 상속이 있습니다. 상속은 하나의 객체가 다른 객체의 프로퍼티와 메소드를 물려받는 경우입니다. 예컨대 생성자 메소드를 사용할 때 일반 유저와 프리미엄 유저로 나눠서 생성한다고 했을 때 extends 키워드를 사용해서 일반 유저의 프로퍼티를 상속 받고 프리미엄 유저는 레벨 프로퍼티만 재설정하는 방식으로 선언이 가능합니다. 자연스럽게 코드의 재사용성이 좋아지고 공통 유저의 프로퍼티를 상속 받기 때문에 반복적인 코드의 수정 작업 시 휴먼 에러를 방지할 수 있습니다. 마지막으로는 다형성이 있는데, 다형성이라는 말 그대로 상속을 통해 기능을 확장하거나 변경하는 것이 가능합니다. OOP에서 다형성의 개념을 녹여내는 방법은 두 가지가 있는데, 오버라이딩(Overriding)과 오버로딩(Overloading)입니다. 다만 자바스크립트에서는 문법적으로 오버로딩을 제공하진 않습니다.

## 꼬리 질문

- 그럼 절차 지향 프로그래밍에 대해서도 아시나요? 간략하게 설명 가능하실까요?
  - 쉽게 말해서 변수와 함수를 가지고 작업의 순서에 맞게 코드를 작성하는 것을 뜻하는데, 순차적인 처리가 핵심이고 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다.
- 오버라이딩과 오버로딩에 대해서 설명해주세요.
  - 자식 클래스에서 부모 클래스와 동일한 method 이름을 짓고 재정의해서 사용하는 것을 오버라이딩이라고 합니다.

## 참고자료

- JS 중급 - 자바스크립트 객체 지향 기본기 by 코드잇
- [https://velog.io/@zzangzzong/객체지향-프로그래밍Object-Oriented-Programming](https://velog.io/@zzangzzong/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DObject-Oriented-Programming) - Java 기준 설명
- [https://www.codestates.com/blog/content/객체-지향-프로그래밍-특징](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95) - Java 기준 설명
- https://www.zerocho.com/category/JavaScript/post/59c17a58f40d2800197c65d6

# AJAX에 대해 설명해주세요.

## 내용 정리

- Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미합니다. 일반적으로 서버로부터 웹페이지를 받으면 브라우저 화면 전체를 갱신해야 하는데 AJAX를 사용함으로서 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있습니다. 갱신이 필요한 일부만 변경하기 때문에 빠른 퍼포먼스와 상대적으로 부드럽게 웹페이지를 그려낼 수 있습니다. 서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 JSON(JavaScript Object Notation)을 사용하는 것이 일반적입니다.
- 초창기에는 XMLHttpRequest 객체를 이용해서 요청하는 방식으로 처리하곤 했지만 코드가 복잡하고 가독성이 좋지 않다는 단점이 있었습니다. 그래서 최근에는 fetch 함수와 then, catch 메소드 등과 함께 체이닝으로 작성하는 것이 일반적입니다. 물론 axios와 같은 외부 라이브러리를 사용하기도 합니다.

## 꼬리 질문

-

## 참고자료

- https://poiemaweb.com/jquery-ajax-json
- [https://inpa.tistory.com/entry/JS-📚-AJAX-서버-요청-및-응답-fetch-api-방식](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-AJAX-%EC%84%9C%EB%B2%84-%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%9D%91%EB%8B%B5-fetch-api-%EB%B0%A9%EC%8B%9D)

# CORS에 대해 설명해주세요.

## 내용 정리

- 우선 CORS를 말하기 전에 SOP에 대해 먼저 알 필요성이 있습니다. SOP는 Same-Origin Policy로 말 그대로 동일 출처 정책인데, 동일한 출처 사이에서만 리소스를 공유할 수 있다는 보안 규칙입니다. 동일 출처의 기준은 프로토콜, 도메인, 포트 이 3가지를 기준으로 합니다. 애초에 서로 다른 출처끼리 요청을 주고 받는 건 안 되는 게 기본값이었습니다. 오래 전에는 대부분의 처리가 같은 도메인 내에서 일어났고, 오히려 그 당시에는 다른 출처로 요청을 보내는 것을 악의적인 행위(CSRF, XSS 등)로 간주되기도 했습니다. 따라서 SOP는 보안을 위한 정책이었고 브라우저 차원에서 막는 것이 당연한 일이었습니다. 하지만 웹 생태계가 다양해지면서 여러 서비스들간에 데이터를 주고 받아질 필요가 생겼습니다. 그래서 별도의 기준이 충족되면 리소스 공유가 되도록 생겨난 개념이 CORS, 교차 출처 자원 공유 방식입니다. CORS는 Cross-Origin Resource Sharing의 약자인데, CORS는 다른 출처간에 리소스를 공유할 수 있도록 하는 걸 말합니다.

## 꼬리 질문

- CORS가 허용되는 조건이 무엇인가요?
  - 요청을 받는 백엔드쪽에서 이걸 허락할 다른 출처들을 명시해두면 됩니다. CORS 옵션을 넣어서 허용할 사이트들을 명시적으로 적어주면 CORS가 가능해집니다.
- Preflight는 무엇인가요?
  - Preflight는 실제 요청이 CORS를 위반하지 않았는지를 미리 확인하고, 부작용으로부터 서버를 보호하기 위해 전송한다.

## 참고자료

- https://www.youtube.com/watch?v=bW31xiNB8Nc
- https://hudi.blog/sop-and-cors/
