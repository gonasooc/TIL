# 클로저에 대해 설명해주세요.

## 내용 정리

- 함수의 호출 위치에 따라 scope 범위가 달라진다면 dynamic scope라고 할 수 있겠지만 자바스크립트는 dynamic scope가 아닌 static scope를 채택하고 있습니다. 자바스크립트의 함수의 유효 범위는 그 함수가 어디서 실행됐느냐가 아니라 어디서 정의됐느냐에 따라서 달라집니다. static scope는 lexical scope라고도 부르는데, 함수를 함수 안에 정의하면 그 함수의 부모 함수의 scope에 접근할 수 있습니다. 즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말합니다.
- 자바스크립트는 기본적으로 어휘적 환경(Lexical environment)을 갖고, 코드가 실행되면 스크립트 내에서 선언한 변수들이 어휘적 환경에 올라갑니다. 코드에서 변수를 찾을 때 유효 범위 안의 내부에서 찾고, 없으면 외부, 거기에도 없으면 전역 Lexical까지 범위를 넓혀서 찾습니다. 클로저는 결국 함수와 렉시컬 환경의 조합입니다. 함수가 생성될 당시의 외부 변수를 기억해서 사용할 수 있으며, 생성 이후에도 계속 접근 가능합니다. 식별자에 대한 직접적인 접근을 막을 수 있기 때문에 캡슐화 및 은닉화가 가능하지만, 역으로 무분별하게 사용한다면 쓸데없이 메모리를 낭비할 수 있기 때문에 해제를 통해 메모리 소모를 줄여야 합니다.
- 클로저는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다. 자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 꼭 그것 때문이라고는 할 수 없지만 다양한 문헌에서 제각각 클로저를 다르게 정의하거나 설명하는 경우가 많습니다.
- ES3까지는 실행 컨텍스트 없이 dynamic scope였는데, ES5 이후 (2009년~)부터는 어디에 선언되어 있느냐에 따라 정적으로 결정되어 하나의 실행 컨테스트 개념으로 묶였습니다.

## 꼬리 질문

- ECMAScript는 무엇인가요?
  - ECMA International이라는 비영리 국제 표준화 기구에서 JS 발전이나 변화 등을 관리
  - 규칙이나 준수사항 등을 ECMA-262이라는 문서로 관리하게 되는데 이 문서의 내용을 ECMAScript
  - 변화가 있을 때마다 ES1, ES2 형식으로 부르다가 6 버전이 등장한 2015년부터는 1년마다 출시하기로 결정하면서 편의상 ES6라고 부르지만 정식 명칭은 뒤에 연호를 달아서 ES2015, ES2016의 형식
  - ES6 버전은 JavaScript의 많은 부분을 보완한 버전 → ES5가 가지고 있던 문제점들을 보완하고(Arrow function, let, for of 등), 코드를 더 간결하게 작성할 유용한 문법들이 등장
  - 현시점에 사용하기 적합한 범위 내에서 최신 버전의 표준을 준수하는 자바스크립트를 모던 자바스크립트라고 부름
- 가비지 컬렉션은 무엇인가요?
  - https://ko.javascript.info/closure#ref-220
- 클로저의 장점과 단점은 무엇인가요? 어느 때에 사용해야 더 좋을까요?
- 클로저는 왜 사용하나요?
- 클로저가 상태 유지에 도움되는 이유가 무엇인가요?
- 클로저가 useState와 차이점은 무엇인가요?
- 클로저는 함수 내에서만 일어나는 현상인가요?
- 클로저와 비슷한 개념으로 커링에 대해서도 알고 계신가요?
- 클로저를 사용하는 상황은 어떤 상황이 있을지 예시를 들어 설명해주세요!
- 실행 컨텍스트에 대해 설명해주세요!

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://poiemaweb.com/js-closure
- https://ko.javascript.info/closure
- https://youtu.be/4_WLS9Lj6n4?t=4699
- https://youtu.be/bwwaSwf7vkE

## 스터디 메모

- https://kyoung-jnn.com/posts/react-useState

# 호이스팅에 대해 설명해주세요.

## 내용 정리

- 변수를 예로 들자면, 변수 선언이 나중에 되었음에도 마치 선언이 위에서 된 것처럼 작동하는데, scope 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동하는 걸 hoisting이라고 할 수 있습니다. 단, 할당된 value 자체는 hoisting되지 않는데, 선언은 hoisting되지만 할당은 hoisting되지 않기 때문입니다.
- TDZ(Temporal Dead Zone) 영역에 있는 변수들은 사용할 수 없는데, let과 const는 TDZ의 영향을 받기 때문에 할당을 하기 전에는 사용할 수 없습니다. 이는 코드를 예측 가능하게 하고 잠재적인 버그를 줄일 수 있습니다.
- 함수에서도 hoisting이 발생하는데, 함수 선언식의 경우 hoisting에 따라서 실제 컴파일할 때 끌어올려지기 때문에 선언된 위치와 별개로 사용이 가능합니다. 다만 함수 표현식의 경우 hoisting이 일어나기 않기 때문에 좀 더 엄격하게 작동한다고 볼 수 있습니다.
- 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있습니다. 함수 hoisting이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적하기도 했습니다.
- 함수 표현식의 경우 변수(var / let, const)의 호이스팅과 동일하게 동작하는 반면, 함수 선언식은 자바스크립트 엔진이 해당 함수의 선언과 동시에 완성된 함수 객체를 생성해서 환경 레코드에 기록해둡니다. 따라서 호이스팅되어 선언이 되기 전에도 실행이 가능하다고 볼 수 있습니다.

## 꼬리 질문

- TDZ(Temporal Dead Zone)가 무엇인가요?
- 왜 let과 const만 TDZ가 적용되나요?
- 호이스팅은 자바스크립트만의 특징인가요?
- 호이스팅이 끌어 올려지는 것 처럼 동작한다고 말씀해주셨는데, 조금 추가적으로 설명 가능하실까요?
  - 자바스크립트 엔진이 컴파일 과정에서 모든 스코프를 탐색하며 각 스코프의 식별자를 수집하여 선언된 식별자 정보를 이미 알고 있기 때문에 발생하는 현상입니다. 실행 컨텍스트와 관련이 있습니다.
- 호이스팅은 장점인가요 단점인가요?

## 참고자료

- https://youtu.be/4_WLS9Lj6n4?t=128
- [https://velog.io/@jangwonyoon/호이스팅과-TDZ는-무엇이고-어떤-연관이-있을까요](https://velog.io/@jangwonyoon/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EA%B3%BC-TDZ%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%96%B4%EB%96%A4-%EC%97%B0%EA%B4%80%EC%9D%B4-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94)
- https://deftkang.tistory.com/17
- https://poiemaweb.com/js-function

# 스코프에 대해 설명해주세요.

## 내용 정리

- scope는 참조의 대상이 되는 식별자(identifier)를 찾기 위한 유효한 범위라고 볼 수 있습니다. 자바스크립트는 이 규칙대로 식별자를 찾게 됩니다. 크게 전역 스코프(Global scope)와 지역 스코프(Local scope or Function-level scope)로 나눌 수 있는데, 전역 스코프는 코드 어디에서든지 참조할 수 있고 지역 스코프는 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조가 가능합니다.
- 대부분의 C-family language는 블록 레벨 스코프(block-level scope)를 따르지만 자바스크립트는 함수 레벨 스코프(function-level scope)를 따릅니다. 단, ES6에서 도입된 let을 사용하면 블록 레벨 스코프를 사용할 수 있고, 상황에 따라 let 사용을 권고하는 경우가 많습니다.
- 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 꼭 필요한 경우에만 사용하는 것이 좋습니다.

## 꼬리 질문

- 함수 레벨 스코프(Function-level scope)
  - 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 블록 레벨 스코프(Block-level scope)
  - 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.
- C-family language
  - "C-family language"는 주로 C 프로그래밍 언어와 그와 관련된 언어들을 일컫는 용어입니다. C 프로그래밍 언어는 1970년대에 처음 개발된 프로그래밍 언어로, 컴퓨터 과학 및 소프트웨어 개발 분야에서 널리 사용되는 중요한 언어 중 하나입니다. C 언어는 단순하면서도 강력한 기능을 제공하여 시스템 프로그래밍, 응용 프로그래밍, 임베디드 시스템 등 다양한 분야에서 사용됩니다. 또한 C 언어는 많은 다른 프로그래밍 언어의 기반이 되었고, 많은 프로그래밍 언어가 C 언어의 문법과 구조를 모방하거나 확장하여 개발되었습니다. 이런 언어들을 통틀어 "C-family language"라고 부르는 것입니다. 예를 들어, C++는 C 언어의 기능을 확장하여 객체 지향 프로그래밍을 지원하는 언어로, C 언어의 특징을 계승하면서도 더 많은 기능을 추가하였습니다. 또한 C#(C Sharp)은 Microsoft에서 개발한 언어로, C++과 Java 등의 영향을 받아 개발된 언어입니다. 이런 언어들이 C-family language의 일부로 간주됩니다.
- 스코프를 중첩해서 사용한 사례가 있나요?

## 참고자료

- https://poiemaweb.com/js-scope
- https://poiemaweb.com/es6-block-scope

# var, const, let 차이점을 설명해주세요.

## 내용 정리

- var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프입니다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능합니다. var는 변수의 중복 선언을 허용합니다. hoisting이 적용되기 때문에 선언하기 전부터 사용이 가능합니다.
- var에서 적용되는 내용 모두 불가능합니다. 블록 스코프로 작동되고 중복 선언이 불가능하며, let은 생성 시 TDZ(Temporal Dead Zone) 구간에 들어가게 되어 선언하기 전에는 reference error가 발생합니다.
- const는 재할당 및 재선언 자체가 금지됩니다.
- 요약하자면, var는 생성 단계에서 실행 컨텍스트를 생성하면서 초기화를 하기 때문에 undefined로 접근이 가능하고, let과 const는 실행 컨텍스트를 생성하면서 별도의 초기화를 하지 않기 때문에 reference error가 발생한다고 볼 수 있습니다. let 또는 const로 선언했을 때 선언 이전에 식별자를 참조할 수 없는데, 이 구역을 일시적 사각지대(Temporal Dead Zone)라고 부릅니다.
- var는 메모리 공간을 확보하고 식별자와 연결하는 선언과 식별자에 암묵적으로 undefined 값을 바인딩하는 초기화를 동시에 진행하지만, var나 const는 초기화는 하지 않기 때문에 선언 라인 전에는 변수를 참조할 수 없습니다.

## 꼬리 질문

- const는 재선언 및 재할당이 안 되지만 메서드나 프로퍼티로 접근해서 변경이 가능한데 그 부분을 자세하게 설명해주실 수 있을까요?
  - 원시타입은 재할당 자체가 불가능합니다, 다만 객체나 배열 같은 참조타입의 경우 주소 자체는 변동이 없으나 힙에 저장된 값은 매서드나 프로퍼티로 접근해서 변경 가능합니다. 하지만 직접적으로 재할당을 하고자 하면 에러가 발생합니다.

## 참고자료

- https://ko.javascript.info/var
- https://ko.javascript.info/variables
- https://taenami.tistory.com/87

# callback, promise, async/await의 차이점을 설명해주세요.

## 내용 정리

- 콜백 함수는 쉽게 말해서 다른 코드의 인자로 넘겨주는 함수라고 볼 수 있습니다. 콜백 함수를 넘겨 받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행합니다. 말 그대로 콜백 함수는 다른 함수에게 인자로 넘겨줌으로써 그 제어권도함께 위임한 함수입니다. 다만 비동기 작업을 수행하기 위해 함수를 전달하는 과정이 반복되면서 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 콜백 지옥(callback hell) 현상이 생길 수 있는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 어렵습니다.
- 그런 일련의 과정 속에서 자바스크립트 진영은 비동기적인 일련의 작업을 동기적으로, 혹은 동기적인 것처럼 보이게끔 처리해주는 장치를 마련하게 되는데, 그게 ES6에서는 Promise, ES2017에서는 async/await라고 볼 수 있습니다.
- new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve나 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 오류 구문(catch)으로 넘어가지 않습니다.
- 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고, 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve된 이후에야 다음으로 진행합니다. Promise 문법을 사용하면서도 단순 Promise chaining보다 가독성이 뛰어나고 작성법도 간단하다고 볼 수 있습니다.

## 꼬리 질문

- Promise 객체를 사용할 때 then 메소드를 사용해서 Promise Chaining을 사용하는데, 여기서 then 메소드의 역할이 뭔가요?
  - then 메소드는 새로운 promise 객체를 return 합니다.
- Promise 객체는 크게 3가지 중 하나의 상태를 가지게 되는데, 이 상태에 대해서 간략하게 설명해주실 수 있을까요?
  - pending(진행중) / fulfilled(성공) / rejected(실패), 작업 성공/실패 여부에 따라 promise 객체가 fulfilled나 rejected 각각의 정보를 갖게 됩니다.
- 작업하실 때 catch와 finally를 사용하신 사례가 있다면 말씀해주실 수 있으실까요?
  - catch는 해당 에러의 내용이나 별도의 router 이동을 하게 만들기 위해서 작성했었고, finally는 말 그대로 promise 객체가 fullfilled가 되든 rejected가 되든 항상 마지막에 실행하고자 하는 callback이 있을 때 사용했습니다. 예컨대 promise chaining에서 사용한 어떤 값을 지워줘야 한다거나 최종적으로 별도의 log를 남겨야 할 때 정도가 될 거 같습니다.

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- JS중급 - 자바스크립트 웹 개발 기본기 by 코드잇

# 이벤트 버블링, 캡쳐링에 대해 설명해주세요.

## 내용 정리

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는데, 이런 흐름을 물 속 거품과 닮았다고 해서 이벤트 버블링이라고 부릅니다. focus 이벤트와 같이 버블링 되지 않는 이벤트도 있지만, 거의 모든 이벤트는 버블링이 된다고 볼 수 있습니다. 이벤트 버블링과 반대 방향으로 탐색하는 걸 이벤트 캡쳐링이라고 합니다.
- 프레임워크에 별도의 내장함수나 JavaScript 자체의 stopPropagation()이라는 웹API를 통해서 해당 이벤트가 전파되는 걸 막을 수 있으나 버블링은 이벤트 위임을 통해 사용자의 행동 패턴을 분석하는 등 유용하게 사용될 여지가 있기 때문에 아키텍처를 잘 고려해서 정말 막아야 하는 상황에서만 막는 편이 좋습니다.

## 꼬리 질문

- 이벤트 버블링을 막지 않고 이벤트 위임을 유용하게 사용될 여지가 있다고 했는데, 혹시 어떤 사례가 있을까요?
  - 실제로 분석에 이용해본 경험은 없지만 예컨대 GA 같은 사용자 패턴 분석 툴이 적용되어 있는 경우 depth가 깊은 메뉴에 있어서 사용자가 하위 메뉴를 클릭했을 때 상위 메뉴까지의 이벤트 위임을 통해서 분석에 활용된다는 사례를 본 적이 있긴 합니다.

## 참고자료

- https://ko.javascript.info/bubbling-and-capturing
- https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/
- JS중급 - 자바스크립트 웹 개발 기본기 by 코드잇

# 브라우저 렌더링 원리에 대해 설명해주세요.

## 내용 정리

- 우선 브라우저는 사용자의 요청에 따라 서버로부터 HTML, CSS, JavaScript, 그리고 이미지 파일을 포함한 에셋들을 응답 받습니다. HTML, CSS 파일은 랜더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 랜더 트리로 결합됩니다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 출력하게 됩니다.
- 다만 자바스크립트는 랜더링 엔진이 아닌 자바스크립트 엔진이 처리합니다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해서 진행 중이던 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘깁니다. 자바스크립트 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 다시 DOM 생성을 재개합니다.
- 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, JavaScript를 처리하기 때문에 script 태그의 위치에 따라 블로킹이 발생하여 DOM 생성 자체를 지연시킬 수도 있습니다. 따라서 떄에 따라 script 태그의 위치가 중요하게 작용합니다.
- 보편적으로 body 요소 아래에 자바스크립트를 위치하는 것이 좋은 것으로 알고 있습니다. HTML 요소들이 스크립트 로딩 지연으로 인해 랜더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축되고, DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수밖에 없는데 그런 부분을 미연에 방지할 수 있습니다.

## 꼬리 질문

## 참고자료

- https://poiemaweb.com/js-browser
- https://youtu.be/-CATiyw2-Ns
- https://youtu.be/sJ14cWjrNis

# 이벤트 루프에 대해 설명해주세요.

## 내용 정리

- 브라우저는 싱글쓰레드에서 특정 이벤트에 반응해서 동작을 변경하는 방식(event-driven)으로 작동합니다. 하지만 실제로 동작하는 웹 애플리케이션은 많은 태스크가 동시에 처리되는 것처럼 느껴지는데, 이러한 동시성(Concurrency)을 지원하는 것이 이벤트 루프입니다.
- 이벤트 루프는 태스크가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없으면 잠드는 방식을 반복하는 자바스크립트 내의 루프입니다. 이 이벤트 루프를 기반으로 자바스크립트 엔진은 대부분의 시간 동안 별도의 작업 없이 쉬고 있다가 스크립트나 핸들러, 이벤트가 활성화될 때만 돌아갑니다.

## 꼬리 질문

## 참고자료

- https://poiemaweb.com/js-event
- https://ko.javascript.info/event-loop

# 실행 컨텍스트에 대해 설명해주세요.

## 내용 정리

- 실행 컨텍스트는 코드를 실행하는데 필요한 환경을 제공하는 객체라고 할 수 있습니다. 여기서 환경이라고 하면 코드를 실행에 영향을 주는 조건이나 상태를 말하는데, 식별자 결정을 더욱 효율적으로 하기 위한 수단으로 필요한 정보를 한데 모아 제공하는 객체가 실행 컨텍스트입니다.
- 예컨대 var를 선언하고 최상단에 var를 console.log로 찍어봤을 때 에러가 나지 않고 undefined 찍히는 호이스팅이 발생하는데, 이런 호이스팅이 생기는 이유는 자바스크립트 엔진이 먼저 전체 코드를 스캔하면서 변수 같은 정보를 실행컨텍스트에 기록해놓기 때문입니다. 이때 나오는 개념이 실행 컨텍스트입니다. (물론 console.log 또한 내장함수이기 때문에 이 함수의 실행 컨텍스트 또한 생기는 게 맞습니다)
- 이때 var를 기록해놓는 곳이 바로 환경 레코드(Environment Record)로 식별자와 식별자에 바인딩된 값을 기록해두는 객체입니다.
- 또한 스코프 체이닝을 위해 외부 환경 정보를 구성하는데, 외부 환경 참조(Outer Environment Reference)는 선언되었을 당시의 상위 Lexical Environment를 참조합니다. 그래서 자바스크립트 엔진은 새로 생성된 실행 컨텍스트에 바깥 렉시컬 환경으로 돌아갈 수 있는 outer를 남겨 놓습니다. 그래서 필요한 경우에 이전 실행 컨텍스트의 환경레코드에 저장된 식별자로 참조할 수 있게 됩니다.
- 식별자 결정(Identifier Resolution - 코드에서 변수나 함수의 값을 결정하는 것)을 하고자 할 때 현재 활성화된 실행 컨텍스트의 환경 레코드를 찾고, 바깥 렉시컬 환경에서 찾아보고, 끝내 없으면 전역 실행 컨텍스트까지 찾게 됩니다. 이러한 과정에서 사용되는 개념이 실행 컨텍스트라고 할 수 있습니다.
- 식별자 결정을 진행할 때 변수 섀도잉(Variable Shadowing)이 발생하는데, 동일한 식별자로 인해 상위 스코프에서 선언된 식별자의 값이 가려지는 현상을 말합니다.
- 식별자를 결정할 때 활용하는 스코프들의 연결리스트를 스코프 체인(Scope Chain)이라고 하고, 이러한 과정 자체를 스코프 체이닝이라고 합니다.

## 꼬리 질문

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://www.zerocho.com/category/JavaScript/post/5741d96d094da4986bc950a0
- https://youtu.be/EWfujNzSUmw

# this에 대해 설명해주세요.

## 내용 정리

- 실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장됩니다. 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체(브라우저 환경에서는 window, Node.js 환경에서는 global)가 저장됩니다. 그 외에는 함수를 호출하는 방법에 따라서 this에 저장되는 객체가 달라집니다.
- 객체 내 메소드가 호출되는 경우 그 안에 있는 this는 해당 객체를 가리키지만, 해당 메소드를 별도의 변수에 담아서 전역에서 호출하는 경우에는 다시 window를 가리키게 됩니다. new를 붙여서 생성자 함수를 호출하게 되면 this는 생성자를 통해 생성된 인스턴스, 그 자신이 됩니다. 다만 이벤트 리스너를 사용하는 경우 window가 아닌 이벤트가 발생하는 해당 객체를 가리키게 됩니다. 때문에 이벤트 리스너를 사용하는 경우엔 내부의 this가 바꼈음을 명시적으로 알리거나 ES6의 arrow function을 사용하는 편이 좋습니다. arrow function 사용 시 해당 함수 안에 this는 window가 아닌 상위 함수의 this를 가리키게 됩니다.

## 꼬리 질문

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://www.zerocho.com/category/JavaScript/post/5b0645cc7e3e36001bf676eb
