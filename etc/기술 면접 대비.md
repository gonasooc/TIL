# 클로저에 대해 설명해주세요.

## 내용 정리

- 함수의 호출 위치에 따라 scope 범위가 달라진다면 dynamic scope라고 할 수 있겠지만 자바스크립트는 dynamic scope가 아닌 static scope를 채택하고 있습니다. 자바스크립트의 함수의 유효 범위는 그 함수가 어디서 실행됐느냐가 아니라 어디서 정의됐느냐에 따라서 달라집니다. static scope는 lexical scope라고도 부르는데, 함수를 함수 안에 정의하면 그 함수의 부모 함수의 scope에 접근할 수 있습니다. 즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말합니다.
- 자바스크립트는 기본적으로 어휘적 환경(Lexical environment)을 갖고, 코드가 실행되면 스크립트 내에서 선언한 변수들이 어휘적 환경에 올라갑니다. 코드에서 변수를 찾을 때 유효 범위 안의 내부에서 찾고, 없으면 외부, 거기에도 없으면 전역 Lexical까지 범위를 넓혀서 찾습니다. 클로저는 결국 함수와 렉시컬 환경의 조합입니다. 함수가 생성될 당시의 외부 변수를 기억해서 사용할 수 있으며, 생성 이후에도 계속 접근 가능합니다. 식별자에 대한 직접적인 접근을 막을 수 있기 때문에 캡슐화 및 은닉화가 가능하지만, 역으로 무분별하게 사용한다면 쓸데없이 메모리를 낭비할 수 있기 때문에 해제를 통해 메모리 소모를 줄여야 합니다.
- 클로저는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다. 자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 꼭 그것 때문이라고는 할 수 없지만 다양한 문헌에서 제각각 클로저를 다르게 정의하거나 설명하는 경우가 많습니다.
- ES3까지는 실행 컨텍스트 없이 dynamic scope였는데, ES5 이후 (2009년~)부터는 어디에 선언되어 있느냐에 따라 정적으로 결정되어 하나의 실행 컨테스트 개념으로 묶였습니다.

## 꼬리 질문

- ECMAScript는 무엇인가요?
  - ECMA International이라는 비영리 국제 표준화 기구에서 JS 발전이나 변화 등을 관리
  - 규칙이나 준수사항 등을 ECMA-262이라는 문서로 관리하게 되는데 이 문서의 내용을 ECMAScript
  - 변화가 있을 때마다 ES1, ES2 형식으로 부르다가 6 버전이 등장한 2015년부터는 1년마다 출시하기로 결정하면서 편의상 ES6라고 부르지만 정식 명칭은 뒤에 연호를 달아서 ES2015, ES2016의 형식
  - ES6 버전은 JavaScript의 많은 부분을 보완한 버전 → ES5가 가지고 있던 문제점들을 보완하고(Arrow function, let, for of 등), 코드를 더 간결하게 작성할 유용한 문법들이 등장
  - 현시점에 사용하기 적합한 범위 내에서 최신 버전의 표준을 준수하는 자바스크립트를 모던 자바스크립트라고 부름
- 가비지 컬렉션은 무엇인가요?
  - https://ko.javascript.info/closure#ref-220
- 클로저의 장점과 단점은 무엇인가요? 어느 때에 사용해야 더 좋을까요?
- 클로저는 왜 사용하나요?
- 클로저가 상태 유지에 도움되는 이유가 무엇인가요?
- 클로저가 useState와 차이점은 무엇인가요?
- 클로저는 함수 내에서만 일어나는 현상인가요?
- 클로저와 비슷한 개념으로 커링에 대해서도 알고 계신가요?
- 클로저를 사용하는 상황은 어떤 상황이 있을지 예시를 들어 설명해주세요!
- 실행 컨텍스트에 대해 설명해주세요!

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://poiemaweb.com/js-closure
- https://ko.javascript.info/closure
- https://youtu.be/4_WLS9Lj6n4?t=4699
- https://youtu.be/bwwaSwf7vkE

## 스터디 메모

- https://kyoung-jnn.com/posts/react-useState

# 호이스팅에 대해 설명해주세요.

## 내용 정리

- 변수를 예로 들자면, 변수 선언이 나중에 되었음에도 마치 선언이 위에서 된 것처럼 작동하는데, scope 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동하는 걸 hoisting이라고 할 수 있습니다. 단, 할당된 value 자체는 hoisting되지 않는데, 선언은 hoisting되지만 할당은 hoisting되지 않기 때문입니다.
- TDZ(Temporal Dead Zone) 영역에 있는 변수들은 사용할 수 없는데, let과 const는 TDZ의 영향을 받기 때문에 할당을 하기 전에는 사용할 수 없습니다. 이는 코드를 예측 가능하게 하고 잠재적인 버그를 줄일 수 있습니다.
- 함수에서도 hoisting이 발생하는데, 함수 선언식의 경우 hoisting에 따라서 실제 컴파일할 때 끌어올려지기 때문에 선언된 위치와 별개로 사용이 가능합니다. 다만 함수 표현식의 경우 hoisting이 일어나기 않기 때문에 좀 더 엄격하게 작동한다고 볼 수 있습니다.
- 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있습니다. 함수 hoisting이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적하기도 했습니다.
- 함수 표현식의 경우 변수(var / let, const)의 호이스팅과 동일하게 동작하는 반면, 함수 선언식은 자바스크립트 엔진이 해당 함수의 선언과 동시에 완성된 함수 객체를 생성해서 환경 레코드에 기록해둡니다. 따라서 호이스팅되어 선언이 되기 전에도 실행이 가능하다고 볼 수 있습니다.

## 꼬리 질문

- TDZ(Temporal Dead Zone)가 무엇인가요?
- 왜 let과 const만 TDZ가 적용되나요?
- 호이스팅은 자바스크립트만의 특징인가요?
- 호이스팅이 끌어 올려지는 것 처럼 동작한다고 말씀해주셨는데, 조금 추가적으로 설명 가능하실까요?
  - 자바스크립트 엔진이 컴파일 과정에서 모든 스코프를 탐색하며 각 스코프의 식별자를 수집하여 선언된 식별자 정보를 이미 알고 있기 때문에 발생하는 현상입니다. 실행 컨텍스트와 관련이 있습니다.
- 호이스팅은 장점인가요 단점인가요?

## 참고자료

- https://youtu.be/4_WLS9Lj6n4?t=128
- [https://velog.io/@jangwonyoon/호이스팅과-TDZ는-무엇이고-어떤-연관이-있을까요](https://velog.io/@jangwonyoon/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EA%B3%BC-TDZ%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%96%B4%EB%96%A4-%EC%97%B0%EA%B4%80%EC%9D%B4-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94)
- https://deftkang.tistory.com/17
- https://poiemaweb.com/js-function

# 스코프에 대해 설명해주세요.

## 내용 정리

- scope는 참조의 대상이 되는 식별자(identifier)를 찾기 위한 유효한 범위라고 볼 수 있습니다. 자바스크립트는 이 규칙대로 식별자를 찾게 됩니다. 크게 전역 스코프(Global scope)와 지역 스코프(Local scope or Function-level scope)로 나눌 수 있는데, 전역 스코프는 코드 어디에서든지 참조할 수 있고 지역 스코프는 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조가 가능합니다.
- 대부분의 C-family language는 블록 레벨 스코프(block-level scope)를 따르지만 자바스크립트는 함수 레벨 스코프(function-level scope)를 따릅니다. 단, ES6에서 도입된 let을 사용하면 블록 레벨 스코프를 사용할 수 있고, 상황에 따라 let 사용을 권고하는 경우가 많습니다.
- 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 꼭 필요한 경우에만 사용하는 것이 좋습니다.

## 꼬리 질문

- 함수 레벨 스코프(Function-level scope)
  - 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 블록 레벨 스코프(Block-level scope)
  - 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.
- C-family language
  - "C-family language"는 주로 C 프로그래밍 언어와 그와 관련된 언어들을 일컫는 용어입니다. C 프로그래밍 언어는 1970년대에 처음 개발된 프로그래밍 언어로, 컴퓨터 과학 및 소프트웨어 개발 분야에서 널리 사용되는 중요한 언어 중 하나입니다. C 언어는 단순하면서도 강력한 기능을 제공하여 시스템 프로그래밍, 응용 프로그래밍, 임베디드 시스템 등 다양한 분야에서 사용됩니다. 또한 C 언어는 많은 다른 프로그래밍 언어의 기반이 되었고, 많은 프로그래밍 언어가 C 언어의 문법과 구조를 모방하거나 확장하여 개발되었습니다. 이런 언어들을 통틀어 "C-family language"라고 부르는 것입니다. 예를 들어, C++는 C 언어의 기능을 확장하여 객체 지향 프로그래밍을 지원하는 언어로, C 언어의 특징을 계승하면서도 더 많은 기능을 추가하였습니다. 또한 C#(C Sharp)은 Microsoft에서 개발한 언어로, C++과 Java 등의 영향을 받아 개발된 언어입니다. 이런 언어들이 C-family language의 일부로 간주됩니다.
- 스코프를 중첩해서 사용한 사례가 있나요?

## 참고자료

- https://poiemaweb.com/js-scope
- https://poiemaweb.com/es6-block-scope

# var, const, let 차이점을 설명해주세요.

## 내용 정리

- var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프입니다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능합니다. var는 변수의 중복 선언을 허용합니다. hoisting이 적용되기 때문에 선언하기 전부터 사용이 가능합니다.
- var에서 적용되는 내용 모두 불가능합니다. 블록 스코프로 작동되고 중복 선언이 불가능하며, let은 생성 시 TDZ(Temporal Dead Zone) 구간에 들어가게 되어 선언하기 전에는 reference error가 발생합니다.
- const는 재할당 및 재선언 자체가 금지됩니다.
- 요약하자면, var는 생성 단계에서 실행 컨텍스트를 생성하면서 초기화를 하기 때문에 undefined로 접근이 가능하고, let과 const는 실행 컨텍스트를 생성하면서 별도의 초기화를 하지 않기 때문에 reference error가 발생한다고 볼 수 있습니다. let 또는 const로 선언했을 때 선언 이전에 식별자를 참조할 수 없는데, 이 구역을 일시적 사각지대(Temporal Dead Zone)라고 부릅니다.
- var는 메모리 공간을 확보하고 식별자와 연결하는 선언과 식별자에 암묵적으로 undefined 값을 바인딩하는 초기화를 동시에 진행하지만, var나 const는 초기화는 하지 않기 때문에 선언 라인 전에는 변수를 참조할 수 없습니다.

## 꼬리 질문

- const는 재선언 및 재할당이 안 되지만 메서드나 프로퍼티로 접근해서 변경이 가능한데 그 부분을 자세하게 설명해주실 수 있을까요?
  - 원시타입은 재할당 자체가 불가능합니다, 다만 객체나 배열 같은 참조타입의 경우 주소 자체는 변동이 없으나 힙에 저장된 값은 매서드나 프로퍼티로 접근해서 변경 가능합니다. 하지만 직접적으로 재할당을 하고자 하면 에러가 발생합니다.

## 참고자료

- https://ko.javascript.info/var
- https://ko.javascript.info/variables
- https://taenami.tistory.com/87

# callback, promise, async/await의 차이점을 설명해주세요.

## 내용 정리

- 콜백 함수는 쉽게 말해서 다른 코드의 인자로 넘겨주는 함수라고 볼 수 있습니다. 콜백 함수를 넘겨 받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행합니다. 말 그대로 콜백 함수는 다른 함수에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수입니다. 다만 비동기 작업을 수행하기 위해 함수를 전달하는 과정이 반복되면서 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 콜백 지옥(callback hell) 현상이 생길 수 있는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 어렵습니다.
- 그런 일련의 과정 속에서 자바스크립트 진영은 비동기적인 작업을 동기적으로, 혹은 동기적인 것처럼 보이게끔 처리해주는 장치를 마련하게 되는데, 그게 ES6에서는 Promise, ES2017에서는 async/await라고 볼 수 있습니다.
- new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve나 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 오류 구문(catch)으로 넘어가지 않습니다. (pending 상태)
- 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고, 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve된 이후에야 다음으로 진행합니다. Promise 문법을 사용하면서도 단순 Promise chaining보다 가독성이 뛰어나고 작성법도 간단하다고 볼 수 있습니다.
- promise() 객체는 콜백 함수의 인자로 resolve와 reject를 가질 수 있는데, 콜백 함수의 인자로 resolve가 실행되면 fullfilled 상태가 되어 then 구문 안쪽의 프로세스로 넘어 가는 반면, reject가 실행되면 rejected 상태가 되어 catch 안쪽의 프로세스를 실행합니다.

## 꼬리 질문

- Promise 객체를 사용할 때 then 메소드를 사용해서 Promise Chaining을 사용하는데, 여기서 then 메소드의 역할이 뭔가요?
  - then 메소드는 새로운 promise 객체를 return 합니다.
- Promise 객체는 크게 3가지 중 하나의 상태를 가지게 되는데, 이 상태에 대해서 간략하게 설명해주실 수 있을까요?
  - pending(진행중) / fulfilled(성공) / rejected(실패), 작업 성공/실패 여부에 따라 promise 객체가 fulfilled나 rejected 각각의 정보를 갖게 됩니다.
- 작업하실 때 catch와 finally를 사용하신 사례가 있다면 말씀해주실 수 있으실까요?
  - catch는 해당 에러의 내용이나 별도의 router 이동을 하게 만들기 위해서 작성했었고, finally는 말 그대로 promise 객체가 fullfilled가 되든 rejected가 되든 항상 마지막에 실행하고자 하는 callback이 있을 때 사용했습니다. 예컨대 promise chaining에서 사용한 어떤 값을 지워줘야 한다거나 최종적으로 별도의 log를 남겨야 할 때 정도가 될 거 같습니다.
- promise에서 resolve와 reject는 어떤걸 의미하는지 알고계신가요?
- try, catch 외 finally를 사용해보신 적이 있으신지 설명해주세요.
- promise의 resolve, reject의 처리 결과는 어떻게 얻을 수 있나요?
- promise와 다른 async/await의 차이는 무엇인가요?
- Promise.all()

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- JS중급 - 자바스크립트 웹 개발 기본기 by 코드잇

# 이벤트 버블링, 캡쳐링에 대해 설명해주세요.

## 내용 정리

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는데, 이런 흐름을 물 속 거품과 닮았다고 해서 이벤트 버블링이라고 부릅니다. focus 이벤트와 같이 버블링 되지 않는 이벤트도 있지만, 거의 모든 이벤트는 버블링이 된다고 볼 수 있습니다. 이벤트 버블링과 반대 방향으로 탐색하는 걸 이벤트 캡쳐링이라고 합니다.
- 프레임워크에 별도의 내장함수나 JavaScript 자체의 stopPropagation()이라는 웹API를 통해서 해당 이벤트가 전파되는 걸 막을 수 있으나 버블링은 이벤트 위임을 통해 사용자의 행동 패턴을 분석하는 등 유용하게 사용될 여지가 있기 때문에 아키텍처를 잘 고려해서 정말 막아야 하는 상황에서만 막는 편이 좋습니다.

## 꼬리 질문

- 이벤트 버블링을 막지 않고 이벤트 위임을 유용하게 사용될 여지가 있다고 했는데, 혹시 어떤 사례가 있을까요?
  - 실제로 분석에 이용해본 경험은 없지만 예컨대 GA 같은 사용자 패턴 분석 툴이 적용되어 있는 경우 depth가 깊은 메뉴에 있어서 사용자가 하위 메뉴를 클릭했을 때 상위 메뉴까지의 이벤트 위임을 통해서 분석에 활용된다는 사례를 본 적이 있긴 합니다.
- 이벤트 캡처링과 버블링 중에 어떤 것이 우선 동작하나요?
- 이벤트 핸들링을 캡쳐링이 아니라 버블링에서 하는 이유가 무엇인가요?
- 이벤트리스너의 DOM 요소를 찾을 때 캡쳐링의 동작 방식에 대해 설명해주실 수 있을까요?
  - 자바스크립트의 이벤트 모델은 기본적으로 캡쳐링과 버블링 두 단계로 이루어지는데, 이 중 캡쳐링 단계는 이벤트가 최상위 요소에서부터 하위 요소로 향하는 단계입니다. 따라서 특별한 설정을 하지 않아도 이벤트가 발생하면 캡쳐링 단계도 일어납니다. 이벤트 리스너를 등록할 때 addEventListener 함수의 세 번째 매개변수로 전달하는 useCapture 매개변수를 true로 설정하면, 해당 이벤트 리스너는 캡쳐링 단계에서 호출됩니다. 그러나 useCapture 매개변수를 생략하거나 false로 설정하면, 기본적으로는 이벤트 리스너가 버블링 단계에서 호출됩니다. 다시 말해, 캡쳐링이 발생하지 않는다는 것이 아니라, useCapture 매개변수를 명시적으로 true로 설정하지 않으면 기본적으로는 버블링 단계에서 이벤트가 처리된다는 것이 맞습니다.

## 참고자료

- https://ko.javascript.info/bubbling-and-capturing
- https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/
- JS중급 - 자바스크립트 웹 개발 기본기 by 코드잇

# 브라우저 렌더링 원리에 대해 설명해주세요.

## 내용 정리

- 우선 브라우저는 사용자의 요청에 따라 서버로부터 HTML, CSS, JavaScript, 그리고 이미지 파일을 포함한 에셋들을 응답 받습니다. HTML, CSS 파일은 랜더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 랜더 트리로 결합됩니다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 출력하게 됩니다.
- 다만 자바스크립트는 랜더링 엔진이 아닌 자바스크립트 엔진이 처리합니다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해서 진행 중이던 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘깁니다. 자바스크립트 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 다시 DOM 생성을 재개합니다.
- 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, JavaScript를 처리하기 때문에 script 태그의 위치에 따라 블로킹이 발생하여 DOM 생성 자체를 지연시킬 수도 있습니다. 따라서 떄에 따라 script 태그의 위치가 중요하게 작용합니다.
- 보편적으로 body 요소 아래에 자바스크립트를 위치하는 것이 좋은 것으로 알고 있습니다. HTML 요소들이 스크립트 로딩 지연으로 인해 랜더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축되고, DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수밖에 없는데 그런 부분을 미연에 방지할 수 있습니다.

## 꼬리 질문

- body 태그를 기준으로 script 태그는 어디에 위치하는 편이 좋을까요? 만약 상단에 script 태그가 위치해야 하는 상황이라면 어떻게 제어해야 할까요?
  - 보편적으로 body 태그 아래에 스크립트 태그를 위치하는 편이 좋고, 만약 상단에 위치해야 한다면 defer, async 문법을 통해서 비동기적으로 처리가 가능합니다.
- DOM 생성 중에 style이나 link 태그를 만나게 되면 어떻게 처리되게 되나요?
  - script 태그와 동일하게 DOM 생성을 일시 중단하고 CSSOM을 생성합니다.
- inline style 사용을 지양해야 하는 이유에 대해서 설명해주실 수 있나요?
  - 성능 최적화와 관련이 있는데, React의 경우 변화 감지 메커니즘을 사용하기 때문에 매번 스타일 객체를 생성할 경우 해당 style 객체의 비교가 항상 false로 나오게 됩니다. 그 과정에서 불필요한 리랜더링이 발생할 가능성이 높아집니다. 그리고 일반적인 개발 환경에서도 reflow가 발생하기 때문에 최적화가 적합하지 못합니다.
- repaint, reflow란?
  - [https://velog.io/@young_pallete/Reflow-Repaint을-알아보자](https://velog.io/@young_pallete/Reflow-Repaint%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

## 참고자료

- https://poiemaweb.com/js-browser
- https://youtu.be/-CATiyw2-Ns
- https://youtu.be/sJ14cWjrNis
- https://ko.javascript.info/script-async-defer

# 이벤트 루프에 대해 설명해주세요.

## 내용 정리

- 브라우저는 싱글쓰레드에서 특정 이벤트에 반응해서 동작을 변경하는 방식(event-driven)으로 작동합니다. 하지만 실제로 동작하는 웹 애플리케이션은 많은 태스크가 동시에 처리되는 것처럼 느껴지는데, 이러한 동시성(Concurrency)을 지원하는 것이 이벤트 루프입니다.
- 이벤트 루프는 태스크가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없으면 잠드는 방식을 반복하는 자바스크립트 내의 루프입니다. 이 이벤트 루프를 기반으로 자바스크립트 엔진은 대부분의 시간 동안 별도의 작업 없이 쉬고 있다가 스크립트나 핸들러, 이벤트가 활성화될 때만 돌아갑니다.

## 꼬리 질문

- promise와 setTimeout의 우선순위는 어떻게 되나요?
  - [https://velog.io/@dbfudgudals/자바스크립트-실행순서를-뜯어보자](https://velog.io/@dbfudgudals/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89%EC%88%9C%EC%84%9C%EB%A5%BC-%EB%9C%AF%EC%96%B4%EB%B3%B4%EC%9E%90)
- 자바스크립트에게 동시성을 지원하는 것이 구체적으로 어떤 의미인가요?
- 콜스택과 콜백큐를 감시한다는 의미가 무엇인가요?
- 콜백큐에는 어떻게 작업이 쌓이게 되나요?
- 멀티스레드처럼 동작하는 이유가 무엇인가요?

## 참고자료

- https://poiemaweb.com/js-event
- https://ko.javascript.info/event-loop

## 스터디 메모

# 실행 컨텍스트에 대해 설명해주세요.

## 내용 정리

- 실행 컨텍스트는 코드를 실행하는데 필요한 환경을 제공하는 객체라고 할 수 있습니다. 여기서 환경이라고 하면 코드를 실행에 영향을 주는 조건이나 상태를 말하는데, 식별자 결정을 더욱 효율적으로 하기 위한 수단으로 필요한 정보를 한데 모아 제공하는 객체가 실행 컨텍스트입니다.
- 예컨대 var를 선언하고 최상단에 var를 console.log로 찍어봤을 때 에러가 나지 않고 undefined 찍히는 호이스팅이 발생하는데, 이런 호이스팅이 생기는 이유는 자바스크립트 엔진이 먼저 전체 코드를 스캔하면서 변수 같은 정보를 실행컨텍스트에 기록해놓기 때문입니다. 이때 나오는 개념이 실행 컨텍스트입니다. (물론 console.log 또한 내장함수이기 때문에 이 함수의 실행 컨텍스트 또한 생기는 게 맞습니다)
- 이때 var를 기록해놓는 곳이 바로 환경 레코드(Environment Record)로 식별자와 식별자에 바인딩된 값을 기록해두는 객체입니다.
- 또한 스코프 체이닝을 위해 외부 환경 정보를 구성하는데, 외부 환경 참조(Outer Environment Reference)는 선언되었을 당시의 상위 Lexical Environment를 참조합니다. 그래서 자바스크립트 엔진은 새로 생성된 실행 컨텍스트에 바깥 렉시컬 환경으로 돌아갈 수 있는 outer를 남겨 놓습니다. 그래서 필요한 경우에 이전 실행 컨텍스트의 환경레코드에 저장된 식별자로 참조할 수 있게 됩니다.
- 식별자 결정(Identifier Resolution - 코드에서 변수나 함수의 값을 결정하는 것)을 하고자 할 때 현재 활성화된 실행 컨텍스트의 환경 레코드를 찾고, 바깥 렉시컬 환경에서 찾아보고, 끝내 없으면 전역 실행 컨텍스트까지 찾게 됩니다. 이러한 과정에서 사용되는 개념이 실행 컨텍스트라고 할 수 있습니다.
- 식별자 결정을 진행할 때 변수 섀도잉(Variable Shadowing)이 발생하는데, 동일한 식별자로 인해 상위 스코프에서 선언된 식별자의 값이 가려지는 현상을 말합니다.
- 식별자를 결정할 때 활용하는 스코프들의 연결리스트를 스코프 체인(Scope Chain)이라고 하고, 이러한 과정 자체를 스코프 체이닝이라고 합니다.

## 꼬리 질문

- 렉시컬 환경에 대해 설명해주세요.
- this binding에 대해 설명해주세요.
- 클로저와 호이스팅에 대해 설명해주세요.

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://www.zerocho.com/category/JavaScript/post/5741d96d094da4986bc950a0
- https://youtu.be/EWfujNzSUmw

# this에 대해 설명해주세요.

## 내용 정리

- 실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장됩니다. 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체(브라우저 환경에서는 window, Node.js 환경에서는 global)가 저장됩니다. 그 외에는 함수를 호출하는 방법에 따라서 this에 저장되는 객체가 달라집니다.
- 객체 내 메소드가 호출되는 경우 그 안에 있는 this는 해당 객체를 가리키지만, 해당 메소드를 별도의 변수에 담아서 전역에서 호출하는 경우에는 다시 window를 가리키게 됩니다. new를 붙여서 생성자 함수를 호출하게 되면 this는 생성자를 통해 생성된 인스턴스, 그 자신이 됩니다. 다만 이벤트 리스너를 사용하는 경우 window가 아닌 이벤트가 발생하는 해당 객체를 가리키게 됩니다. 때문에 이벤트 리스너를 사용하는 경우엔 내부의 this가 바꼈음을 명시적으로 알리거나 ES6의 arrow function을 사용하는 편이 좋습니다. arrow function 사용 시 해당 함수 안에 this는 window가 아닌 상위 함수의 this를 가리키게 됩니다.

## 꼬리 질문

- 화살표 함수와 일반적인 함수 선언문(function 키워드로 정의한 함수)에서 this를 사용할 때 중요한 차이점은 무엇인가요?
- this는 왜 사용하나요?
- this를 명시적으로 binding하는 방법도 있을까요?
- 암시적 binding에 대해 설명해주세요.
- 객체의 내부 메서드 안에 메서드를 작성하게 되면 해당 메서드 안의 this는 무엇을 가리키나요?

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://www.zerocho.com/category/JavaScript/post/5b0645cc7e3e36001bf676eb

# prototype에 대해 설명해주세요.

## 내용 정리

- 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있습니다. 이건 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티나 메소드를 상속 받아서 사용할 수 있게 됩니다. 이러한 부모 객체를 프로토타입(Prototype) 객체 또는 줄여서 프로토타입이라고 합니다.
- 예컨대 하나의 배열을 만들면 new Array() 의 디폴트 생성자가 내부에서 동작해서 해당 Array.prototype이 해당 배열의 프로토타입이 되고, 우리는 그걸 통해 length나 map과 같은 배열과 관련된 내장함수를 사용할 수 있게 됩니다. 이런 내부 동작은 메모리 효율을 높여주는 장점으로 작용합니다.
- 이와 같이 어떤 객체에 특정 프로퍼티나 메서드에 접근할 때 특정 프로퍼티나 메서드가 없다면 내부 링크를 통해 상위 프로토타입으로 접근하는 행위를 프로토타입 체인이라고 하는데, 이런 과정에서 볼 수 있듯이 자바스크립트는 프로토타입 객체지향을 사용하고 있습니다.

## 꼬리 질문

- 상속과 코드의 재사용성을 구현하는 예시를 알 수 있을까요?
- 코드를 작성하실 때 상속이나 재사용성을 사용해본 경험이 있으실까요?
- 다른 언어에서의 OOP와 자바스크립트의 OOP의 차이가 있을까요?
  - **프로토타입 기반 상속:** JavaScript는 프로토타입 기반의 상속을 사용합니다. 이것은 객체 간에 상속 관계를 명시적으로 클래스로 정의하지 않고, 객체를 복제하거나 프로토타입 체인을 통해 상속을 구현합니다. 이는 일부 다른 OOP 언어에서 사용되는 클래스 기반 상속과는 다른 접근 방식입니다.
  - **동적 타이핑:** JavaScript는 동적 타이핑 언어로, 변수의 데이터 타입이 실행 시간에 결정됩니다. 이는 다른 언어에서 볼 수 있는 정적 타이핑과는 다른 접근 방식입니다. 변수의 타입을 명시적으로 선언하지 않아도 되며, 동일한 변수가 다른 타입의 값을 가질 수 있습니다.
  - **함수가 일급 객체:** JavaScript에서 함수는 일급 객체로 취급됩니다. 이것은 함수를 변수에 할당하거나 함수의 인자로 전달하거나 함수를 반환할 수 있다는 것을 의미합니다. 함수를 변수에 저장하고 실행하는 등의 유연한 작업이 가능합니다.
  - **비동기 프로그래밍과 콜백:** JavaScript는 비동기 프로그래밍 모델을 강조하며, 이를 위해 콜백 함수와 프로미스, async/await와 같은 기능을 제공합니다. 이는 다른 언어에서는 덜 강조되는 부분입니다.
  - **싱글 스레드와 이벤트 루프:** JavaScript는 기본적으로 싱글 스레드 모델을 사용하며, 비동기 작업을 효율적으로 처리하기 위해 이벤트 루프를 활용합니다. 이로 인해 동시성과 병렬성 관련 접근 방식이 다른 다중 스레드 언어와는 다릅니다.
  - **전역 객체와 호이스팅:** JavaScript에는 브라우저 환경에서는 **`window`**, Node.js 환경에서는 **`global`**로 알려진 전역 객체가 있습니다. 또한, 변수 및 함수 선언이 스코프의 맨 위로 끌어올려지는 호이스팅 메커니즘이 있습니다.
  - **유연한 문법과 동적 객체:** JavaScript는 유연한 문법을 가지며, 객체의 속성을 동적으로 추가하거나 삭제할 수 있습니다. 이로 인해 런타임 중에 객체의 구조를 변경할 수 있습니다.
- new Array() 생성자로 배열을 생성하는 것과 빈 배열을 넣고 생성하는 것에 차이가 있을까요?
  - new Array() 생성자를 통해 배열을 생성하는 것과 일반적인 대괄호를 통해 배열을 생성하는 것에 속도적으로 큰 차이는 없으나, new Array()를 통한 생성은 직관적이지 않다는 게 가장 차이라고 볼 수 있습니다. 결국은 사람이 하는 일이기에 휴먼 에러를 줄이는 것도 중요한 일이라서 빈 배열을 통한 생성을 주로 하게 된 것이 아닌가 생각이 됩니다.
- proto와 프로토타입의 차이
- class와 프로토타입의 차이

## 참고자료

- https://poiemaweb.com/js-prototype
- https://ko.javascript.info/native-prototypes
- https://youtu.be/wT1Bl5uV27Y?si=24PIg3EQBdHu_fOO
- https://withhsunny.tistory.com/71

## 스터디 메모

- javascript의 모든 객체는 Object.prototype을 상속받아 만들어지게 됩니다.

# oop와 특징에 대해 설명해주세요.

## 내용 정리

- 객체 지향 프로그래밍은 프로퍼티와 메소드로 이루어진 각 객체들의 상호 작용을 중심으로 코드를 작성하는 것을 말합니다. 객체 지향 프로그래밍은 크게 추상화, 캡슐화, 상속, 다형성 이렇게 네 가지의 특징을 갖고 있습니다. 우선 추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미합니다. 추상화는 React 같은 컴포넌트 기반의 라이브러리에서도 사용하는 개념인데 재사용성과 범용성 이 두 가지에 밀접한 관계가 있겠습니다. 캡슐화는 서로 연관되어 있는 속성과 기능들을 하나의 캡슐로 만들어 객체의 특정 프로퍼티에 직접 접근하지 못하도록 막고 외부로부터 보호하는 것을 뜻합니다. 핵심 키워드는 데이터의 보호와 은닉입니다. getter, setter를 통해 캡슐화를 구현할 수 있습니다. 그 다음엔 상속이 있습니다. 상속은 하나의 객체가 다른 객체의 프로퍼티와 메소드를 물려받는 경우입니다. 예컨대 User라는 생성자 메소드를 사용할 때 일반 유저와 프리미엄 유저로 나눠서 생성한다고 가정하면, extends 키워드를 사용해서 일반 유저의 프로퍼티를 상속 받고 프리미엄 유저는 레벨 프로퍼티만 재설정하는 방식으로 선언이 가능합니다. 자연스럽게 코드의 재사용성이 좋아지고 공통 유저의 프로퍼티를 상속 받기 때문에 반복적인 코드의 수정 작업 시 휴먼 에러를 방지할 수 있습니다. 마지막으로는 다형성이 있는데, 다형성이라는 말 그대로 상속을 통해 기능을 확장하거나 변경하는 것이 가능합니다. OOP에서 다형성의 개념을 녹여내는 방법은 두 가지가 있는데, 오버라이딩(Overriding)과 오버로딩(Overloading)입니다. 다만 자바스크립트에서는 문법적으로 오버로딩을 제공하진 않습니다.

## 꼬리 질문

- 그럼 절차 지향 프로그래밍에 대해서도 아시나요? 간략하게 설명 가능하실까요?
  - 쉽게 말해서 변수와 함수를 가지고 작업의 순서에 맞게 코드를 작성하는 것을 뜻하는데, 순차적인 처리가 핵심이고 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다.
- 오버라이딩과 오버로딩에 대해서 설명해주세요.
  - 자식 클래스에서 부모 클래스와 동일한 method 이름을 짓고 재정의해서 사용하는 것을 오버라이딩이라고 합니다.
- 클로저와 캡슐화의 차이가 있을까요?
- 다형성에서 오버라이딩과 오버로딩의 차이가 있을까요?
- 캡슐화의 예시를 들 수 있을까요?
- 각 특징마다 간단한 예시를 들어주실 수 있을까요?

## 참고자료

- JS 중급 - 자바스크립트 객체 지향 기본기 by 코드잇
- [https://velog.io/@zzangzzong/객체지향-프로그래밍Object-Oriented-Programming](https://velog.io/@zzangzzong/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DObject-Oriented-Programming) - Java 기준 설명
- [https://www.codestates.com/blog/content/객체-지향-프로그래밍-특징](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95) - Java 기준 설명
- https://www.zerocho.com/category/JavaScript/post/59c17a58f40d2800197c65d6

# AJAX에 대해 설명해주세요.

## 내용 정리

- Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미합니다. 일반적으로 서버로부터 웹페이지를 받으면 브라우저 화면 전체를 갱신해야 하는데 AJAX를 사용함으로서 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있습니다. 갱신이 필요한 일부만 변경하기 때문에 빠른 퍼포먼스와 상대적으로 부드럽게 웹페이지를 그려낼 수 있습니다. 서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 JSON(JavaScript Object Notation)을 사용하는 것이 일반적입니다.
- 초창기에는 XMLHttpRequest 객체를 이용해서 요청하는 방식으로 처리하곤 했지만 코드가 복잡하고 가독성이 좋지 않다는 단점이 있었습니다. 그래서 최근에는 fetch 함수와 then, catch 메소드 등과 함께 체이닝으로 작성하는 것이 일반적입니다. 물론 axios와 같은 외부 라이브러리를 사용하기도 합니다.

## 꼬리 질문

- CSR과 AJAX의 관련성을 설명해주실 수 있을까요?
- 클라이언트가 response data의 포맷은 어떻게 확인하나요?
- ajax의 단점은 무엇인가요?

## 참고자료

- https://poiemaweb.com/jquery-ajax-json
- [https://inpa.tistory.com/entry/JS-📚-AJAX-서버-요청-및-응답-fetch-api-방식](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-AJAX-%EC%84%9C%EB%B2%84-%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%9D%91%EB%8B%B5-fetch-api-%EB%B0%A9%EC%8B%9D)

## 스터디 메모

- fetch와의 차이점이라면 axios 라이브러리는 XMLHttpRequest 기반으로 동작

# CORS에 대해 설명해주세요.

## 내용 정리

- 우선 CORS를 말하기 전에 SOP에 대해 먼저 알 필요성이 있습니다. SOP는 Same-Origin Policy로 말 그대로 동일 출처 정책인데, 동일한 출처 사이에서만 리소스를 공유할 수 있다는 보안 규칙입니다. 동일 출처의 기준은 스킴(scheme), 도메인, 포트 이 3가지를 기준으로 합니다. 오래 전에는 대부분의 처리가 같은 도메인 내에서 일어났고, 오히려 그 당시에는 다른 출처로 요청을 보내는 것을 악의적인 행위(CSRF, XSS 등)로 간주되기도 했습니다. 따라서 SOP는 보안을 위한 정책이었고 브라우저 차원에서 막는 것이 당연한 일이었습니다. 하지만 웹 생태계가 다양해지고 외부 API를 사용하거나 클라이언트와 서버를 분리해서 개발하는 경우도 많아지게 되면서 여러 서비스들간에 데이터를 주고 받을 필요성이 점점 더 생기게 됩니다. 그래서 별도의 기준이 충족되면 리소스 공유가 되도록 생겨난 개념이 CORS입니다. CORS는 Cross-Origin Resource Sharing의 약자인데, 다른 출처간에 리소스를 공유할 수 있도록 하는 체제 같은 것을 말합니다. Postman으로 API 테스트해보거나 스프링 같은 백엔드에서는 문제없이 데이터를 받아오는데 브라우저, 즉 프론트에서 CORS 에러를 볼 수 있는 이유는 브라우저 차원에서 이러한 이유로 막고 있기 때문입니다.
- 브라우저는 다른 출처끼리의 요청이 보내질 때는 요청에 origin이라는 header를 추가합니다. 이 header에는 요청하는 쪽의 스킴, 도메인, 포트가 담깁니다. 여기서 스킴은 요청할 자원에 접근할 방법, 즉 http, ftp, telnet 등을 말합니다. 그래서 이 요청을 받은 서버는 응답을 보낼 header에 지정된 Access-Control-Allow-Origin 정보를 실어서 보냅니다. 결론적으론 최초에 요청했던 header에 담겼던 스킴, 도메인, 포트 정보가 Access-Control-Allow-Origin 정보에 담겨 있으면 안전한 요청으로 간주하고 응답 데이터를 받아오게 됩니다.
- 추가로 토큰 등 사용자 식별 정보가 담긴 요청에 대해서는 좀 더 엄격합니다. 일단 보내는 쪽에서는 보내는 옵션에 credentials 항목을 true로 세팅해야 하고, 받는 쪽에서도 단순히 모든 출처에 허용한다는 와일드카드 대신에 정확하게 명시해야 하며, Access-Control-Allow-Credentials 항목을 true로 맞춰줘야 합니다.
- CORS와 관련된 요청은 Simple Request와 Preflight Request가 있는데, GET이나 POST 등의 Simple Request는 예비 요청 없이 본 요청만 보내는 것이고, PUT이나 DELETE 등의 Preflight Request는 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 보내서 안전한지 확인하는 과정입니다. 그 외에 별도로 보안을 좀 더 강화한 Credentialed Request 또한 있습니다.

## 꼬리 질문

- CORS가 허용되는 조건이 무엇인가요?
  - 요청을 받는 백엔드쪽에서 이걸 허락할 다른 출처들을 명시해두면 됩니다. CORS 옵션을 넣어서 허용할 사이트들을 명시적으로 적어주면 CORS가 가능해집니다.
- Preflight는 무엇인가요?
  - Preflight는 실제 요청이 CORS를 위반하지 않았는지를 미리 확인하고, 부작용으로부터 서버를 보호하기 위해 전송한다.
- 스킴과 프로토콜은 혼용해서 많이 사용하는데, 차이에 대해서 설명해주실 수 있으실까요?
  - 프로토콜은 컴퓨터나 장치들이 서로 정보를 주고받기 위한 통신 규약이며, 스킴은 URI의 구성 요소로써, 어떤 프로토콜을 사용할지를 나타낼 뿐이다.
- CSRF와 XSS를 언급하셨는데 간략하게 설명해주실 수 있으실까요?
  - CSRF는 Cross Site Request Forgery의 약자로 사이트간의 요청 위조, 즉 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(데이터 수정, 삭제 등)을 특정 웹사이트에 요청하게 하는 공격이라고 볼 수 있습니다. 우리가 흔히 접하는 피싱도 CSRF의 일종이라고 볼 수 있습니다. XSS는 인증된 세션 없이도 공격을 진행할 수 있다는 차이점이 있는데, 쉽게 말해서 XSS는 공격대상이 클라이언트고 CSRF는 서버라고 볼 수 있습니다. XSS는 사용자가 입력 가능한 input이나 textarea 같은 것을 통해 별도의 악성 스크립트가 담긴 글을 올리고 실행시키는 방법입니다. 이를 통해 유저의 쿠키 정보를 탈취, 유저의 비밀번호를 변경하는 api를 호출하거나 하는데, 실제로 특정 글을 클릭했을 때 회원이 탈퇴되어버리는 사건이 있기도 했다고 알고 있습니다.
- a 태그에 href target attribute에 blank를 줌으로서 외부 링크가 새 창으로 열리게 되는데, 이에 따른 보안 대응은 어떻게 하는 편이 좋을까요?
  - target="\_blank"를 rel="noreferrer"와 rel="noopener" 없이 사용하면 웹사이트가 window.opener API 악용 공격에 취약해집니다. 다만, 최근 브라우저(Firefox 79+ 등)는 target="\_blank"를 지정하면 임의로 rel="noopener" 설정과 동일한 보호 수준을 적용합니다.
- Proxy 서버로 데이터를 가져올 수 있다면 CORS를 설정하는 이유는 무엇인가요?
- SOP 정책은 SameSite 쿠키와 같나요?

## 참고자료

- https://www.youtube.com/watch?v=bW31xiNB8Nc
- https://hudi.blog/sop-and-cors/
- [https://velog.io/@wiostz98kr/CORS의-모든-것](https://velog.io/@wiostz98kr/CORS%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83)
- https://ssocoit.tistory.com/235
- [https://velog.io/@tngusglaso/HTML-링크-targerblank와-targerblank의-차이점](https://velog.io/@tngusglaso/HTML-%EB%A7%81%ED%81%AC-targerblank%EC%99%80-targerblank%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90)
- https://developer.mozilla.org/ko/docs/Web/HTML/Element/a#attr-target

# CSR, SSR 차이에 대해 설명해주세요.

## 내용 정리

- CSR과 SSR의 가장 큰 차이는 랜더링을 어디서 하느냐의 차이라고 볼 수 있습니다. CSR은 말 그대로 클라이언트에서 렌더링을 하기 때문에 비어 있는 HTML을 자바스크립트를 통해 그려주는 형식으로 작동합니다. 페이지를 오갈 때 전체 HTML을 받아오는 것이 아니라 일부 영역만 스크립트로 새로 그려주기 때문에 유저 친화적이고 사용자 경험에 유리하다고 볼 수 있습니다. 초기 랜더링을 제외하고는 속도 면에서도 유리합니다. 다만 최초에는 스크립트 전체를 가져오기 때문에 초기 랜더링 속도는 상대적으로 느리고, 말 그대로 빈 HTML에 스크립트로 엘리멘탈들을 그려주기 때문에 SEO에 취약하다는 단점이 있습니다.
- SSR은 반대로 서버에서 랜더링을 진행합니다. HTML과 CSS 등 모든 랜더링을 마친 후에 클라이언트로 전달해주기 때문에 SEO에 대응하기 좋고, 초기 랜더링 속도가 빠릅니다. 다만 페이지 이동 시 전체 HTML을 받아와야 하는 경우들이 있기 때문에 깜빡거림 등 사용자 경험에서 다소 불리할 수 있고, 상황에 따라 조금 다를 수 있지만 일부 서버에 추가 부하가 발생할 수 있다는 단점이 있습니다.
- 다만 최근에는 CSR도 Code Splitting이나 Tree-Shaking을 통해 초기 로딩 속도를 개선하거나 Pre-rendering를 통해 SEO에 대응하고 있기도 합니다.

## 꼬리 질문

- SEO에 대해 간략하게 설명해주실 수 있을까요?
  - 말 그대로 검색 엔진 최적화로 웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정입니다. 검색 랭크 개선이라고 부르는데, 쉽게 말해 검색 결과 첫 페이지에 우리의 서비스가 나올 수 있게끔 만드는 과정이라고도 볼 수 있겠습니다. 일부 SEO 가이드라인은 제공하지만 대체로 대형 검색 엔진의 경우 검색 결과 랭킹을 영업 비밀로 취급하고 있습니다. 다만 큰 틀에서 생각해보면 시맨틱 마크업과 메타 태그가 가장 큰 영향을 미치고, LCP 같은 구글에서 측정하는 웹 퍼포먼스 지수 등이 영향을 끼치는 것으로 알려져 있습니다.
- CSR에서 SEO에 대응할 수는 없나요?
  - 최근에는 CSR도 Code Splitting이나 Tree-Shaking을 통해 초기 로딩 속도를 개선하거나 Pre-rendering를 통해 SEO에 대응하고 있기도 합니다.

## 참고자료

- https://adjh54.tistory.com/53
- https://developer.mozilla.org/ko/docs/Glossary/SEO
- https://minsoftk.tistory.com/68
- [https://min88.tistory.com/entry/CSR-SSR-단점-보완-방법-정리해보기](https://min88.tistory.com/entry/CSR-SSR-%EB%8B%A8%EC%A0%90-%EB%B3%B4%EC%99%84-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0)
- [https://minoo.medium.com/next-js-처럼-server-side-rendering-구현하기-7608e82a0ab1](https://minoo.medium.com/next-js-%EC%B2%98%EB%9F%BC-server-side-rendering-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-7608e82a0ab1)
- https://byseop.netlify.app/csr-seo/

## 스터디 자료

- SEO를 개선해보신 경험이 있으신가요?
- 혹시 배포 후에 구글 검색 결과를 확인하고 SEO를 추가적으로 개선해본 적이 있으신가요?
- SSG에 대해서도 간략하게 알고 계신가요?

# REST API에 대해 설명해주세요.

## 내용 정리

- REST(Representational State Transfer)에서 가장 중요한 기본적인 규칙은 두 가지인데, URI는 자원 자체를 표현하는 데에 집중하고 행위에 대한 정의는 HTTP Method를 통해 하는 것이 REST한 API를 설계하는 중심 규칙이라고 할 수 있습니다. 몇 가지 원칙이 있는데, 리소스명은 동사보다는 명사를 사용합니다. 그리고 URI는 자원을 표현하는데 중점을 두어야 합니다. get 같은 행위에 대한 표현이 들어가서는 안 되고, 그런 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현합니다. REST의 기본 원칙을 성실히 지킨 서비스 디자인을 “RESTful”이라고 표현합니다.

## 꼬리 질문

- HTTP Method의 종류와 역할을 설명해주세요.
  - GET은 모든/특정 리소스를 조회하고, POST는 리소스를 생성합니다. PUT은 리소스 전체를 교체하고, PATCH는 리소스의 일부를 수정합니다. 그리고 DELETE는 모든/특정 리소스를 삭제합니다.
- URL과 URI는 어떻게 다를까요?

## 참고자료

- https://poiemaweb.com/js-rest-api

## 스터디 자료

- Stateless 통신이란 무엇인가요?
  - [https://velog.io/@rlrhs11/Stateless-Stateful-웹서버-통신-방식](https://velog.io/@rlrhs11/Stateless-Stateful-%EC%9B%B9%EC%84%9C%EB%B2%84-%ED%86%B5%EC%8B%A0-%EB%B0%A9%EC%8B%9D)

# Webpack, Babel, Polyfill에 대해 설명해주세요.

## 내용 정리

- 분산된 모듈의 여러 의존성 관계를 정리하고 하나의 파일로 묶어 네트워크 비용을 최소화하는데 이런 과정을 번들링(bundling)이라고 합니다. 웹팩은 이런 번들링을 진행하는 번들러라고 할 수 있습니다. 트랜스파일링이란 특정 언어로 작성된 코드를 비슷한 다른 언어로 변환시키는 과정을 말하는데, 이를 해주는 대표적인 트랜스파일러(transpiler)가 Babel 입니다. 수많은 예시가 있겠지만 예컨대 arrow function으로 작성한 코드를 arrow function이 없던 구 표준을 준수하는 코드로 변환해주는 과정이라고 볼 수 있습니다. Polyfill은 트랜서파일러와는 다르게 좀 더 함수 중심이라고 볼 수 있는데, 예컨대 자바스크립트에 새로운 내장함수가 추가되었거나 했을 때 그 내장함수의 작동 로직을 추가해주는 거라고 볼 수 있습니다. 내장함수의 존재 여부를 체크하고, 없다면 해당 폴리필 스크립트가 실행되게끔 할 수 있습니다. 주로 새로 추가된 내장함수의 경우 MDN 하단에 폴리필 스크립트를 제공해줍니다.

## 꼬리 질문

- 웹팩 공식문서에서 말하는 주요 네 가지 개념에 대해 간략하게 설명해주세요
  - 엔트리(entry)는 말 그대로 웹팩에서 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로라고 할 수 있습니다. 엔트리는 포인트는 경우에 따라 1개가 될 수도, 여러 개가 될 수도 있습니다. 아웃풋(output)은 말 그대로 웹팩을 돌리고 난 뒤에 결과물의 파일 경로를 의미하고, 일반적으로 filename과 path를 지정합니다. 그리고 기본적으로 웹팩은 모든 파일을 모듈로 보고 자바스크립트만 읽어냅니다. 그렇기 때문에 자바스크립트 외에 HTML, CSS, 이미지를 포함한 assets 등을 읽을 수 있게 변환해줘야 하는데, 그 역할을 하는 것이 로더(loader)라고 볼 수 있습니다. 플러그인은 로더가 할 수 없는 추가적인 작업을 수행한다고 인지하고 있습니다.
- 폴리필 스크립트를 사용해 본 경험이 있나요?
- 웹팩을 사용하기 이전과 이후의 차이점에 대해서 설명해주세요

## 참고자료

- [https://velog.io/@dbsbest10/Webpack-과-Babel이란-무엇일까](https://velog.io/@dbsbest10/Webpack-%EA%B3%BC-Babel%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)
- https://juneyr.dev/2019-02-20/webpack-babel
- https://ko.javascript.info/polyfills
- https://joshua1988.github.io/webpack-guide/
- https://tecoble.techcourse.co.kr/post/2021-07-10-webpack-exercise/

# 웹 표준, 웹 접근성, 크로스 브라우징에 대해 설명해주세요.

## 내용 정리

- 웹 표준은 W3C(World Wide Web Consortium)에서 권고하는 웹에서 표준적으로 사용되는 기술이나 규칙을 말하는데, 즉, 웹 사이트를 구성하는 HTML, CSS, JavaScript 등의 언어들이 표준화된 방식으로 작성되어야 한다는 것입니다. 사용자의 기기나 브라우저와 무관하게 동일한 웹페이지가 보이고 정상적으로 작동할 수 있게끔 하는 목적을 두고 있습니다.
- 웹 접근성은 말 그대로 모든 사람들이 웹사이트에서 제공하는 정보를 동등하게 접근하고 이용할 수 있도록 보장하는 개념으로 법적의무사항입니다. 보조과학기술로는 TTS 기술을 활용한 스크린리더, 키보드 오버레이 등이 있습니다.
- 크로스 브라우징은 브라우저 간 웹페이지의 상호 호환성이라고 말할 수 있는데, 쉽게 말해 모든 브라우저에서 의도한 대로 나오게 하는 작업이라고 볼 수 있습니다. 브라우저마다 랜더링 엔진이 다르기 때문에 공통 요소, 혹은 특정 브라우저에 별도로 대응해서 작업을 진행합니다. 실무적으로 번거로운 작업이긴 하지만 IE 퇴출 이후에는 조금 수월해진 부분이 있습니다.

## 꼬리 질문

- 웹 표준, 웹 접근성, 크로스 브라우징을 위해 했던 실질적인 작업이 있나요?
- 웹 접근성 사례에 대해 아시는 정도만 설명해주세요
- 벤더 프리픽스(Vendor Prefix)의 개념에 아시는 바 설명해주세요
  - [https://velog.io/@daymoon\_/CSS-벤더-프리픽스Vendor-Prefix](https://velog.io/@daymoon_/CSS-%EB%B2%A4%EB%8D%94-%ED%94%84%EB%A6%AC%ED%94%BD%EC%8A%A4Vendor-Prefix)

## 참고자료

- http://www.wa.or.kr/m1/sub1.asp
- [https://velog.io/@wonder1247/크로스-브라우징-cross-Browsing에-대하여](https://velog.io/@wonder1247/%ED%81%AC%EB%A1%9C%EC%8A%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95-cross-Browsing%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)
- [https://dori-coding.tistory.com/entry/Front-end-크로스-브라우징Cross-Browsing](https://dori-coding.tistory.com/entry/Front-end-%ED%81%AC%EB%A1%9C%EC%8A%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95Cross-Browsing)
- [https://velog.io/@hoon_dev/웹표준-웹접근성-크로스브라우징이란](https://velog.io/@hoon_dev/%EC%9B%B9%ED%91%9C%EC%A4%80-%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1-%ED%81%AC%EB%A1%9C%EC%8A%A4%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95%EC%9D%B4%EB%9E%80)

# 쿠키, 세션, 웹 스토리지에 대해 설명해주세요.

## 내용 정리

- 쿠키는 브라우저에 저장되는 작은 크기의 문자열인데, 서버가 HTTP Response Headers의 Set-Cookie에 내용을 넣어 전달하면 브라우저는 이 내용을 브라우저에 저장합니다. 클라이언트는 이제부터 매 HTTP Request시 HTTP Header에 쿠키를 담아서 전송하고, 만료 전이라면 쿠키는 브라우저에 저장되어 있어서 항상 요청시 사용 가능합니다. 만료됐다면 클라이언트가 새로 서버에 요청하여 새로 발급하는 형식으로 작동합니다. 쿠키는 클라이언트를 식별하는 유저 인증에 가장 많이 쓰인다고 할 수 있습니다.
- 웹 스토리지는 클라이언트가 데이터를 저장해서 들고 있을 수 있도록 HTML5부터 나온 새로운 방식의 저장소 개념으로 볼 수 있습니다. window 객체의 프로퍼티로 존재하고 key, value의 쌍으로 데이터를 저장하는데, 로컬 스토리지와 세션 스토리지로 나뉩니다. 로컬 스토리지는 브라우저를 종료하더라도 데이터가 남아 있고, 세션 스토리지는 브라우저 닫히면 스토리지가 초기화되는 특징이 있습니다.
- 세션과 쿠키, 스토리지와의 가장 큰 차이점은 저장 위치인데, 세션은 서버에 저장됩니다. 브라우저를 통해 서버에 접속할 때 서버는 세션 id를 쿠키에 담아 되돌려주고, 사용자는 세션 id를 담은 쿠키인 세션 쿠키를 이 후 요청부터 계속해서 함께 전달함으로 서버가 클라이언트를 식별할 수 있게 하는 방식으로 작동합니다. 서버에 저장되기 때문에 쿠키에 비해 상대적으로 안전하지만 서버와 지속적으로 통신을 해야 하기 때문에 서버에 부하가 생길 수 있다는 단점이 있습니다.

## 꼬리 질문

- HTTP Header에 대해서 간략하게 설명해주세요
  - HTTP Header는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송하는 영역이라고 볼 수 있습니다. 크게 General Header(공통 헤더), Request Header(요청 헤더), Response Header(응답 헤더), Entity Header(엔티티 헤더)로 분류할 수 있습니다.
- 로컬 스토리지와 세션 스토리지를 구분해서 설명 주셨는데, 선택의 기준이 있다면 뭘까요?
  - 로컬 스토리지 - 자동 로그인, 세션 스토리지 - 브라우저 영역에서 임시로 저장할 법한 데이터
- 로컬 스토리지에 비해 쿠키를 통한 자동 로그인의 장점은 무엇일까요?

## 참고자료

- https://ko.javascript.info/cookie
- [https://velog.io/@cham/HTTP-Header에는-어떤-정보들이-담겨있을까](https://velog.io/@cham/HTTP-Header%EC%97%90%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%A0%95%EB%B3%B4%EB%93%A4%EC%9D%B4-%EB%8B%B4%EA%B2%A8%EC%9E%88%EC%9D%84%EA%B9%8C)

# HTTP, HTTPS의 차이에 대해 설명해주세요.

## 내용 정리

- HTTP(Hypertext Transfer Protocol)는 클라이언트와 서버 간 통신을 위한 프로토콜, 즉 규칙이자 약속입니다. 사용자가 웹 사이트를 방문하면 사용자의 브라우저가 서버에 HTTP 요청을 전송하고, 웹 서버는 HTTP 응답으로 응답합니다. 서버와 사용자의 브라우저는 데이터를 일반적인 텍스트로 교환합니다. 간단히 말해 HTTP 프로토콜은 네트워크 통신을 작동하게 하는 기본 기술입니다.
- 기존 HTTP의 가장 큰 문제점은 오가는 데이터를 암호화하지 않는 부분인데, 중간에 누군가 민감 정보를 가로채거나 할 수 있다는 점입니다. 그래서 HTTPS(Hypertext Transfer Protocol Secure)는 기존의 HTTP에 Secure라는 붙인 것처럼 확장 버전 또는 더 안전한 버전이라고 볼 수 있습니다. HTTPS에서는 브라우저와 서버가 데이터를 전송하기 전에 SSL(보안 소켓 계층)을 통해 안전하게 암호화된 연결을 만들 수 있게 도와주고, 안전하고 민감 정보를 주고 받을 수 있게끔 합니다.
- 단순히 민감 정보에 대한 보안을 떠나서라도 HTTP로 접속했을 때 사용자 입장에선 다양한 경고 메세지를 통해서 사용자 경험이 안 좋아질 수 있고, 구글에서도 HTTPS를 권장하고 검색 랭킹 알고리즘에 해당 요소를 반영하겠다 밝혔기 때문에 SEO 측면에서도 중요합니다.

## 꼬리 질문

- SSL에서 어떻게 암호화하는지 설명해주실 수 있으신가요?
- SSL 인증서 작동 방식이 어떻게 되나요?
- SSL과 TLS의 차이점이 대해서 설명해주세요
  - https://aws.amazon.com/ko/compare/the-difference-between-ssl-and-tls/
- https의 성능 저하 이슈에 대해서 설명해주실 수 있나요?

## 참고자료

- https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/
- https://www.ascentkorea.com/difference-between-http-and-https/
- https://yozm.wishket.com/magazine/detail/130/

# JavaScript ES6 변경사항에 대해 설명해주세요.

## 내용 정리

- 꽤 많은 부분에서의 추가사항이 있었는데, 우선 let과 const 키워드의 등장으로 좀 더 엄격하고 예측 가능한 코드를 작성할 수 있게 되었고, back tick을 사용한 템플릿 리터럴로 편의성과 가독성을 보완할 수 있었습니다. 또한 arrow function을 통해 간단히 함수를 표현하고, Promise 문법을 통해 callback hell에서 벗어나 효과적으로 비동기 처리가 가능하게 되었습니다. 그리고 프로토타입 기반의 객체 지향 언어인 자바스크립트에서 클래스 기반의 객체 지향 프로그래밍도 할 수 있도록 Class 키워드를 도입하였고, import, from, export, default 키워드를 사용한 모듈화가 도입되었습니다. 그 외에 parameter를 바로 초기화하거나 구조분해할당, String Method 등이 별도로 추가되기도 했습니다.

## 꼬리 질문

- ES6의 여러 추가사항 중에 가장 주요한 기능(혹은 가장 많이 사용하고 있는 기능)을 하나 꼽으라면 뭐가 있을까요?
- ES6 클래스와 ES5 함수 생성자의 차이점은 무엇인가요?
  - 간단한 생성자의 경우에는 매우 유사하나, 주요 차이점은 상속을 사용할 때 발생합니다. 기존의 ES5 함수 생성자를 사용했을 때는 Object.create 등을 사용해서 상속 처리를 해줘야 하나 ES6의 클래스 문법을 통해 생성하면 간단하게 상속 처리가 가능합니다.
- 클래스 문법을 사용해 본 경험이 있나요?
- 모듈화가 생기기 이전에는 어떤 방식을 사용했는지 아시는 부분이 있나요?

## 참고자료

- [https://hanamon.kr/javascript-es6-문법/](https://hanamon.kr/javascript-es6-%EB%AC%B8%EB%B2%95/)
- [https://velog.io/@chris/front-end-interview-handbook-js-4#es6-클래스와-es5-함수-생성자의-차이점은-무엇인가요](https://velog.io/@chris/front-end-interview-handbook-js-4#es6-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-es5-%ED%95%A8%EC%88%98-%EC%83%9D%EC%84%B1%EC%9E%90%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

# JavaScript 데이터 타입에 대해 설명해주세요.

## 내용 정리

- 자바스크립트는 기본적으로 동적 타입 언어로 변수의 타입 지정 없이 값이 할당되는 과정에서 자동으로 변수의 타입이 유연하게 결정됩니다. 우선 크게 자바스크립트의 데이터 타입은 원시 타입과 참조 타입으로 나뉩니다. 원시 타입에는 string, number, boolean, null, undefined, symbol(ES6에서 추가) 이 있고, 참조 타입은 원시 타입을 제외한 거의 모든 것(object, array, function, 정규표현식 등)이라고 볼 수 있습니다. 참조 타입에서의 객체 개념은 식별자로 참조할 수 있는 메모리 상의 값을 말한다고 볼 수 있습니다.

## 꼬리 질문

- 유사 배열에 대해서 간략하게 설명해주실 수 있나요?
  - 예컨대 문자열도 일종의 배열처럼 인덱스를 통해 접근할 수 있는데 이와 같은 특성을 갖는 데이터를 유사 배열이라고 합니다.
- 유사 배열의 인덱스를 통해서 값을 변경할 수 있나요?
  - 아예 새로운 문자열을 재할당하는 것은 가능하나 유사 배열의 인덱스로 접근해서 값을 변경하는 것은 불가능합니다.
- boolean 타입의 false 외에 false로 간주되는 타입은 어떤 게 있을까요?
  - 비어 있는 문자열과 null, undefined, 숫자 0은 false로 간주됩니다.
- null과 undefined의 차이에 대해서 간략하게 설명해주세요
  - null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용합니다. 다만 undefined는 자바스크립트 엔진이 초기화한 값으로 개발자가 의도적으로 변수의 값이 없다는 것을 명시하고 싶을 때는 null을 사용하는 것이 좋습니다.
- undefined를 개발자가 의도적으로 할당하지 않았는데도 할당된 경우는 어떤 과정에 의해서 그렇게 할당되는 건지 설명해주실 수 있을까요?
  - 이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값(Garbage value)이 들어 있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문이다. 이처럼 undefined는 개발자가 의도적으로 할당한 값이 아니라 자바스크립트 엔진에 의해 초기화된 값이다. 때문에 변수의 값이 없다는 것을 명시하고 싶은 경우는 undefined를 할당하는 것이 아니라 null을 할당하는 편을 권장한다.
- symbol에 대해서 설명해주세요
  - symbol은 객체의 프로퍼티 키를 만들기 위해 사용되는데, 유일한 값으로 다른 프로퍼티와의 충돌 위험이 없습니다.
- NaN와 NaN를 비교연산자를 통해 비교하면 어떤 값을 반환 받나요? 명확한 비교를 하고 싶으면 어떻게 해야 하나요?
  - 두 개의 값을 비교하면 false를 반환합니다. 이는 자바스크립트 설계상 생긴 특성으로 알고 있습니다. 따라서 명확하게 비교하고자 한다면 isNaN()이라는 내장함수를 이용해서 비교해야 합니다.
- typeof를 사용해서 null을 확인해보면 어떻게 나오는지 혹시 아시나요?
  - typeof null이 "object"로 반환되는 것은 JavaScript의 역사적인 설계 결함으로 인한 것이며, 이는 현재까지도 수정되지 않은 상태입니다. 이를 고려하여 코드를 작성할 때에는 null을 확인하기 위해 엄격한 비교 연산자(===)를 사용하거나, 다른 방법을 사용하여 확인하는 것이 좋습니다.
- string 타입은 따옴표로 감싸는데 혹시 어떤 이유로 그렇게 처리하는지 아시나요?
  - 자바스크립트 엔진이 식별자로 인식을 할지 안할지 판단하는 근거가 됩니다.

## 참고자료

- 코어 자바스크립트(정재남, 2019)
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures
- https://poiemaweb.com/js-data-type-variable
- https://another-light.tistory.com/105

# CI / CD에 대해 설명해주세요.

## 내용 정리

- CI/CD (Continuous Integration/Continuous Delivery)는 쉽게 말해서 개발 단계를 자동화하여 더욱 짧은 주기로 고객에게 제공하는 방법이라고 볼 수 있습니다. 말 그대로 지속적인 통합, 제공, 배포를 통해 개발팀과 운영팀 사이에 발생하는 문제(일명 "통합 지옥(integration hell)")를 해결하기 위한 솔루션입니다.
- CI는 지속적인 통합(Continuous Integration)을 의미합니다. 새로운 변경 사항이 정기적으로 빌드 및 테스트를 거쳐 공유 저장소에 병합됩니다. 따라서 여러 명의 개발자가 동시에 개발과 관련된 코드 작업을 하는 경우에 충돌에 대한 이슈를 해결할 수 있습니다.
- CD는 지속적인 서비스 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미하며, 지속적인 제공이란 개발자들이 새로 적용한 변경 사항이 테스트를 거쳐서 저장소에 자동으로 업로드되는 것을 뜻하며, 운영팀은 이 저장소에서 실시간으로 프로덕션 환경으로 배포를 진행할 수 있습니다. 이는 개발팀과 타 부서와의 소통 비용을 낮춰주고 원할한 소통을 가능케 합니다. 추가로 고객이 바로 사용 가능한 프로덕션 환경까지 자동으로 릴리즈가 되기 때문에 지속적인 서비스 제공이 가능하고, 그 덕분에 시장 반응 또한 빠르게 확인할 수 있기 때문에 경쟁력을 높일 수 있다는 장점이 있습니다.
- CI/CD와 관련해서 가장 널리 알려진 오픈소스 툴은 Jenkins가 있습니다.

## 꼬리 질문

- CI/CD 환경을 구축해본 경험이 있으신가요?
  - Vercel, Github Action
- CI/CD는 DevOps의 라이프사이클 중 단계로 알려져 있는데, DevOps의 의미에 대해서 간단하게 설명해주세요
  - development인 개발 주체와 operation인 운영 주체의 합성어로 그 둘 사이의 소통, 협업, 통합 및 자동화 등을 강조하는 소프트웨어 개발 방법론으로 인지하고 있습니다. CI/CD 외에 애자일 방법론 등과도 관련이 있다고 볼 수 있습니다.
- CI/CD 파이프라인을 구축했을 때 단점은 없었나요?
  - 복잡성, 초기 비용, 학습 곡선, 보안 문제, 테스트 부족 등
- CI를 진행하던 도중 git conflict 해결한 경험이 있으실까요?
- 프로젝트 초기 단계에 git conflict를 줄이기 위해 하셨던 작업이 있을까요?

## 참고자료

- https://www.redhat.com/ko/topics/devops/what-is-ci-cd
- https://www.nextree.co.kr/p10799/
- https://aws.amazon.com/ko/devops/what-is-devops/

# AWS EC2 / S3 의 용도와 사용방법에 대해 아는대로 말해주세요.

## 내용 정리

- EC2(Elastic Compute Cloud)는 AWS가 제공하는 클라우드 서버입니다. 클라우드 공간 안에 원하는 Linux나 Ubuntu 같은 원하는 OS를 선택해서 서버를 설치할 수 있고, 생성된 EC2 하나를 인스턴스라고 부르는데 일종의 가상 컴퓨터라고 볼 수 있습니다. 그렇기 때문에 소프트웨어나 어플리케이션이 설치 가능합니다. 그리고 스토리지나 네트워크 성능 등 사용자가 선택할 수 있기 때문에 탄력적으로 옵션을 취할 수 있고, 덕분에 사용량 만큼 지불할 수 있는 장점이 있습니다.
- S3(Single Storage Service)는 AWS에서 가장 널리 사용되는 스토리지 중 하나라고 볼 수 있습니다. EC2와의 차이점이라고 한다면 EC2는 서버의 성격이 강해서 대용량 데이터를 저장하진 않습니다. 거대한 하드디스크라고 볼 수 있고, 대부분의 서비스에서 이미지나 영상을 포함한 에셋과 CSS 등을 S3에 저장해서 관리하는 편입니다.

## 꼬리 질문

- AWS 사용해 본 경험이 있으실까요?

## 참고자료

- [https://velog.io/@dat0802/AWSEC2-RDS-S3-Lambda기본-지식과-EC2-Lambda의-차이](https://velog.io/@dat0802/AWSEC2-RDS-S3-Lambda%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D%EA%B3%BC-EC2-Lambda%EC%9D%98-%EC%B0%A8%EC%9D%B4)
- https://austinpark420.github.io/posts/ec2ands3

# 원시값, 참조값에 대해 메모리 관점에서 설명해주세요.

## 내용 정리

- 원시 값은 단순한 데이터이며, 모든 원시 값은 변경이 불가능합니다. 이 불가능하다는 의미를 메모리의 관점에서 예시를 들어 보겠습니다. 변수 number에 1을 할당하고 다음 라인에서 100을 재할당한다면, 기존의 1이라는 원시 값을 수정하는 것이 아니라 새로운 메모리 공간에 100을 저장하고 해당 변수는 100이 담긴 주소를 바라보게 됩니다. 즉, 원시 값은 실제 값이 복사되어서 전달되게 되는데 이걸 Pass by Value, 값에 의한 전달이라고 말합니다.
- 반대로 참조 값을 변수에 할당하면 변수에 참조 값이 저장되는 개념입니다. 원시 값을 제외한 object, array, function 등이 해당되는데 이 또한 메모리 관점에서 설명하자면, 참조 값은 변경이 가능하기에 재할당을 하면 새로운 공간이 할당되는 것이 아니라 기존의 참조 값 자체를 변경합니다. 참조 값은 값 자체가 아니라 참조 값을 들고 있는 메모리 주소를 비교하기 때문에 다른 변수에 동일한 값을 저장하더라도 두 참조 값은 비교연산자를 통해 false가 나오게 됩니다. 원시 값과는 다르게 Pass by Reference, 참조 값이 저장된 메모리 주소 자체가 전달되는 개념입니다. 예컨대 해당 객체를 복사하고 값을 재할당하면 동일한 메모리 주소를 바라보고 있기 때문에 두 객체의 값 모두 변경이 됩니다. 참조값 재할당의 대표적인 사례라고 볼 수 있습니다.

## 꼬리 질문

-

## 참고자료

- https://jsh99.github.io/JavaScript/primitive_reference/

## 스터디 메모

# 얕은복사, 깊은복사에 대해 설명해주세요.

## 내용 정리

- 참조 타입과 원시 타입의 근본적인 차이 중 하나는 참조 타입은 말 그대로 Pass by Reference, 참조에 의해 복사된다는 점입니다. 그래서 우리가 변수를 복사하듯 새로운 변수에 기존 변수를 복사하면 동일한 메모리 주소를 바라보게 되고, 복사한 변수의 값을 변경하면 두 변수 모두 값이 변하게 됩니다.
- 만약에 아예 독립적인 객체로 복사하고 싶다면 빈 객체를 하나 선언하고 대상이 되는 객체의 프로퍼티 전부를 반복문을 통해 복사해서 넣거나 Object.assign() 메소드를 활용해서 복사를 하면 됩니다. 다만 객체 안쪽에 프로퍼티가 다시 객체인 경우, 즉 중첩객체인 경우에는 또 다시 참조값이 복사되기 때문에 완전히 독립적인 복사가 불가능합니다. 그래서 이를 얕은 복사(Shallow copy)라고 부르고, 별도의 깊은 복사(Deep copy)가 존재합니다.
- 중첩 객체까지 복사가 가능한 깊은 복사(Deep copy)는 표준 알고리즘이 있긴 하지만 주로 전개 연산자나 lodash 라이브러리의 내장 함수인 \_.cloneDeep() 함수를 통해서 구현하는 편입니다.

## 꼬리 질문

-

## 참고자료

- https://ko.javascript.info/object-copy

## 스터디 메모

# undefined, null, undeclared의 차이에 대해 설명해주세요.

## 내용 정리

- undefined는 개발자가 의도적으로 할당한 값이 아니라 자바스크립트 엔진에 의해 초기화된 값이라고 볼 수 있습니다. 다시 말해 값이 없는 게 아니라 값이 할당된 적이 없다는 뜻입니다. null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용합니다. 그리고 undeclared는 접근 가능한 스코프에 변수 선언조차 되어 있지 않은 상태를 뜻합니다.

## 꼬리 질문

- undefined를 개발자가 의도적으로 할당하지 않았는데도 할당된 경우는 어떤 과정에 의해서 그렇게 할당되는 건지 설명해주실 수 있을까요?
  - 이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값(Garbage value)이 들어 있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문이다. 이처럼 undefined는 개발자가 의도적으로 할당한 값이 아니라 자바스크립트 엔진에 의해 초기화된 값이다. 때문에 변수의 값이 없다는 것을 명시하고 싶은 경우는 undefined를 할당하는 것이 아니라 null을 할당하는 편을 권장한다.
- typeof를 사용해서 null을 확인해보면 어떻게 나오는지 혹시 아시나요?
  - typeof null이 "object"로 반환되는 것은 JavaScript의 역사적인 설계 결함으로 인한 것이며, 이는 현재까지도 수정되지 않은 상태입니다. 이를 고려하여 코드를 작성할 때에는 null을 확인하기 위해 엄격한 비교 연산자(===)를 사용하거나, 다른 방법을 사용하여 확인하는 것이 좋습니다.

## 참고자료

- https://poiemaweb.com/js-data-type-variable

## 스터디 메모

# 쓰로틀링, 디바운싱에 대해 설명해주세요.

## 내용 정리

- 쓰로틀링(throttling)은 간단히 말해 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것을 의미합니다. 예컨대 스크롤 이벤트는 빈번하게 실행되기 때문에 별도의 복잡한 함수가 실행된다면 상당한 렉이 발생할 수 있습니다. 이럴 때 몇 초에 한 번, 또는 몇 밀리초에 한 번씩만 실행되게 제한을 두는 쓰로틀링을 걸어둡니다.
- 디바운싱(debouncing)은 연달아 호출되는 함수들 중 마지막 함수, 혹은 가장 처음 함수만 호출하도록 하는 것을 말합니다. 요즘 익숙한 자동완성 검색에 주로 사용한다고 볼 수 있는데, 예를 들어 ‘디바운싱’이라는 키워드를 검색하는데 매번 키 입력이 있을 때마다 검색이 된다면 ‘디ㅂ’ 같은 불필요한 호출이 생기게 됩니다. 이때 setTimeout 같은 함수로 일종의 타이머를 세팅해서 입력을 다 끝내고 200ms 뒤에 호출을 하게 설정할 수 있습니다. 그 외에 다양한 예시가 있겠지만 블로그 글쓰기 에디터의 자동저장 기능 같은 거에 사용될 수 있습니다.

## 꼬리 질문

- 쓰로틀링이나 디바운싱을 적용해 본 경험이 있나요?

## 참고자료

- https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa
- https://onlydev.tistory.com/151

## 스터디 메모
